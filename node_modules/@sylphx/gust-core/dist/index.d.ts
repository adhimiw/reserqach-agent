/**
* Response types and helpers
* Immutable response objects
*/
/**
* Response body type
* - string | Buffer: Buffered response (sent all at once)
* - AsyncIterable<Uint8Array>: Streaming response (sent chunk by chunk)
* - null: No body
*/
type ResponseBody = string | Buffer | AsyncIterable<Uint8Array> | null;
type ServerResponse = {
	readonly status: number;
	readonly headers: Readonly<Record<string, string>>;
	readonly body: ResponseBody;
};
/**
* Check if body is a streaming response (AsyncIterable)
*/
declare const isStreamingBody: (body: ResponseBody) => body is AsyncIterable<Uint8Array>;
declare const response: (body?: string | Buffer | null, init?: {
	status?: number;
	headers?: Record<string, string>;
}) => ServerResponse;
declare const json: <T>(data: T, init?: {
	status?: number;
	headers?: Record<string, string>;
}) => ServerResponse;
declare const text: (data: string, init?: {
	status?: number;
	headers?: Record<string, string>;
}) => ServerResponse;
declare const html: (data: string, init?: {
	status?: number;
	headers?: Record<string, string>;
}) => ServerResponse;
declare const redirect: (url: string, status?: 301 | 302 | 303 | 307 | 308) => ServerResponse;
declare const notFound: (message?: string) => ServerResponse;
declare const badRequest: (message?: string) => ServerResponse;
declare const unauthorized: (message?: string) => ServerResponse;
declare const forbidden: (message?: string) => ServerResponse;
declare const serverError: (message?: string) => ServerResponse;
/**
* Generic handler type
* Takes any context and returns a response
*/
type Handler<Ctx = unknown> = (ctx: Ctx) => ServerResponse | Promise<ServerResponse>;
/**
* Generic wrapper type
* Transforms a handler into another handler
*/
type Wrapper<Ctx = unknown> = (handler: Handler<Ctx>) => Handler<Ctx>;
/**
* Compose wrappers from left to right (outer to inner)
* compose(a, b, c)(handler) = a(b(c(handler)))
*
* Example:
*   compose(withLog, withAuth, withCache)(myHandler)
*   Request flow: withLog -> withAuth -> withCache -> myHandler
*/
declare const compose: <Ctx>(...wrappers: Wrapper<Ctx>[]) => Wrapper<Ctx>;
/**
* Pipe wrappers from left to right (inner to outer)
* pipe(a, b, c)(handler) = c(b(a(handler)))
*/
declare const pipe: <Ctx>(...wrappers: Wrapper<Ctx>[]) => Wrapper<Ctx>;
/**
* WASM Core - Loads and initializes the WASM module
* Universal: works in Browser, Bun, Node.js, Deno
*/
interface ParseResult {
	state: number;
	method: number;
	path_start: number;
	path_end: number;
	query_start: number;
	query_end: number;
	headers_count: number;
	body_start: number;
	header_offsets: Uint32Array;
	free(): void;
}
interface RouteMatch {
	found: boolean;
	handler_id: number;
	params: string[];
	free(): void;
}
interface WasmRouter {
	insert(method: string, path: string, handler_id: number): void;
	find(method: string, path: string): RouteMatch;
	free(): void;
}
interface WasmCore {
	parse_http(buf: Uint8Array): ParseResult;
	method_to_string(code: number): string;
	WasmRouter: new () => WasmRouter;
}
/**
* Initialize WASM module (auto-detects environment)
* @param wasmUrl - Optional URL to WASM file (browser only)
*/
declare function initWasm(wasmUrl?: string): Promise<WasmCore>;
/**
* Get initialized WASM core (throws if not initialized)
*/
declare function getWasm(): WasmCore;
/**
* Check if WASM is initialized
*/
declare function isWasmReady(): boolean;
declare const Methods: {
	readonly GET: 0;
	readonly POST: 1;
	readonly PUT: 2;
	readonly DELETE: 3;
	readonly PATCH: 4;
	readonly HEAD: 5;
	readonly OPTIONS: 6;
	readonly CONNECT: 7;
	readonly TRACE: 8;
};
type MethodCode = (typeof Methods)[keyof typeof Methods];
declare const MethodNames: Record<MethodCode, string>;
export { unauthorized, text, serverError, response, redirect, pipe, notFound, json, isWasmReady, isStreamingBody, initWasm, html, getWasm, forbidden, compose, badRequest, Wrapper, WasmRouter, WasmCore, ServerResponse, RouteMatch, ResponseBody, ParseResult, Methods, MethodNames, MethodCode, Handler };
