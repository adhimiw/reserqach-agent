import {
  __require,
  __toESM
} from "./shared/chunk-1dqs11h6.js";

// src/compose.ts
var compose = (...wrappers) => (handler) => wrappers.reduceRight((h, wrapper) => wrapper(h), handler);
var pipe = (...wrappers) => (handler) => wrappers.reduce((h, wrapper) => wrapper(h), handler);
// src/core.ts
var wasmCore = null;
var isBrowser = typeof globalThis !== "undefined" && "window" in globalThis;
var _isNode = typeof process !== "undefined" && process.versions?.node;
async function initWasmServer() {
  const { readFile } = await import("node:fs/promises");
  const { fileURLToPath } = await import("node:url");
  const { dirname, join } = await import("node:path");
  const __filename2 = fileURLToPath(import.meta.url);
  const __dirname2 = dirname(__filename2);
  const wasmPath = join(__dirname2, "wasm", "gust_wasm_bg.wasm");
  const wasmBuffer = await readFile(wasmPath);
  const wasmModule = await import("./shared/chunk-9x668qbv.js");
  wasmModule.initSync(wasmBuffer);
  return {
    parse_http: wasmModule.parse_http,
    method_to_string: wasmModule.method_to_string,
    WasmRouter: wasmModule.WasmRouter
  };
}
async function initWasmBrowser(wasmUrl) {
  const wasmModule = await import("./shared/chunk-9x668qbv.js");
  const url = wasmUrl || new URL("./wasm/gust_wasm_bg.wasm", import.meta.url).href;
  await wasmModule.default(url);
  return {
    parse_http: wasmModule.parse_http,
    method_to_string: wasmModule.method_to_string,
    WasmRouter: wasmModule.WasmRouter
  };
}
async function initWasm(wasmUrl) {
  if (wasmCore)
    return wasmCore;
  wasmCore = isBrowser ? await initWasmBrowser(wasmUrl) : await initWasmServer();
  return wasmCore;
}
function getWasm() {
  if (!wasmCore) {
    throw new Error("WASM not initialized. Call initWasm() first.");
  }
  return wasmCore;
}
function isWasmReady() {
  return wasmCore !== null;
}
var Methods = {
  GET: 0,
  POST: 1,
  PUT: 2,
  DELETE: 3,
  PATCH: 4,
  HEAD: 5,
  OPTIONS: 6,
  CONNECT: 7,
  TRACE: 8
};
var MethodNames = {
  0: "GET",
  1: "POST",
  2: "PUT",
  3: "DELETE",
  4: "PATCH",
  5: "HEAD",
  6: "OPTIONS",
  7: "CONNECT",
  8: "TRACE"
};
// src/response.ts
var isStreamingBody = (body) => body !== null && typeof body === "object" && !Buffer.isBuffer(body) && (Symbol.asyncIterator in body);
var response = (body = null, init = {}) => ({
  status: init.status ?? 200,
  headers: init.headers ?? {},
  body
});
var json = (data, init = {}) => ({
  status: init.status ?? 200,
  headers: {
    "content-type": "application/json",
    ...init.headers
  },
  body: JSON.stringify(data)
});
var text = (data, init = {}) => ({
  status: init.status ?? 200,
  headers: {
    "content-type": "text/plain",
    ...init.headers
  },
  body: data
});
var html = (data, init = {}) => ({
  status: init.status ?? 200,
  headers: {
    "content-type": "text/html",
    ...init.headers
  },
  body: data
});
var redirect = (url, status = 302) => ({
  status,
  headers: { location: url },
  body: null
});
var notFound = (message = "Not Found") => json({ error: message }, { status: 404 });
var badRequest = (message = "Bad Request") => json({ error: message }, { status: 400 });
var unauthorized = (message = "Unauthorized") => json({ error: message }, { status: 401 });
var forbidden = (message = "Forbidden") => json({ error: message }, { status: 403 });
var serverError = (message = "Internal Server Error") => json({ error: message }, { status: 500 });
export {
  unauthorized,
  text,
  serverError,
  response,
  redirect,
  pipe,
  notFound,
  json,
  isWasmReady,
  isStreamingBody,
  initWasm,
  html,
  getWasm,
  forbidden,
  compose,
  badRequest,
  Methods,
  MethodNames
};
