import { Handler as Handler5, ResponseBody, ServerResponse as ServerResponse15, Wrapper as Wrapper12 } from "@sylphx/gust-core";
import { badRequest, compose, forbidden, getWasm, html, initWasm as initWasm2, isStreamingBody, isWasmReady, json, notFound, pipe, redirect, response, serverError, text, unauthorized } from "@sylphx/gust-core";
import { ServerResponse as ServerResponse2, Wrapper } from "@sylphx/gust-core";
import { Socket } from "node:net";
import { ParseResult as ParseResult2 } from "@sylphx/gust-core";
/**
* Request context with HTTP data and user's app context
*
* @example
* ```typescript
* type App = { db: Database; user: User }
*
* get<App>('/users', ({ ctx }) => {
*   ctx.method      // HTTP request data
*   ctx.app.db      // User's app context
*   ctx.app.user    // Per-request context
* })
* ```
*/
type Context<App = Record<string, never>> = {
	readonly method: string;
	readonly path: string;
	readonly query: string;
	readonly headers: Readonly<Record<string, string>>;
	readonly params: Readonly<Record<string, string>>;
	readonly body: Buffer;
	readonly json: <T>() => T;
	readonly raw: Buffer;
	readonly socket: Socket;
	readonly app: App;
};
/**
* Handler arguments with context and validated input
*/
type HandlerArgs<
	App = Record<string, never>,
	Input = void
> = {
	readonly ctx: Context<App>;
	readonly input: Input;
};
/**
* Route handler function
*/
type RouteHandler<
	App = Record<string, never>,
	Input = void
> = (args: HandlerArgs<App, Input>) => import("@sylphx/gust-core").ServerResponse | Promise<import("@sylphx/gust-core").ServerResponse>;
/**
* Raw parsed context (internal - before app is added)
* @internal
*/
type RawContext = Omit<Context<never>, "app">;
/**
* Create raw context from parsed request
* Returns RawContext (without app) - app is added by serve()
*/
declare const createRawContext: (socket: Socket, raw: Buffer, parsed: ParseResult2, headers: Record<string, string>, params?: Record<string, string>) => RawContext;
/**
* Add app context to raw context
* @internal
*/
declare const withApp: <App>(raw: RawContext, app: App) => Context<App>;
/**
* Create context with updated params
* @internal
*/
declare const withParams: <App>(ctx: Context<App>, params: Record<string, string>) => Context<App>;
/**
* Parse headers from raw buffer using WASM offsets
* @internal
*/
declare const parseHeaders: (raw: Buffer, offsets: Uint32Array, count: number) => Record<string, string>;
/**
* BaseContext - alias for Context with empty app
* @deprecated Use Context<App> directly
*/
type BaseContext = Context<Record<string, never>>;
/**
* Legacy alias for createRawContext
* @deprecated Use createRawContext instead
*/
declare const createContext: typeof createRawContext;
type BasicAuthOptions = {
	/** Validate credentials (return true if valid) */
	readonly validate: (username: string, password: string, ctx: Context) => boolean | Promise<boolean>;
	/** Realm for WWW-Authenticate header */
	readonly realm?: string;
	/** Skip auth for certain requests */
	readonly skip?: (ctx: Context) => boolean;
	/** Custom unauthorized response */
	readonly onUnauthorized?: (ctx: Context) => ServerResponse2;
};
/**
* Parse Basic Auth header
*/
declare const parseBasicAuth: (header: string) => {
	username: string;
	password: string;
} | null;
/**
* Create Basic Auth header value
*/
declare const createBasicAuth: (username: string, password: string) => string;
/**
* Basic Auth middleware
*/
declare const basicAuth: (options: BasicAuthOptions) => Wrapper<Context>;
/**
* Simple Basic Auth with static credentials
*/
declare const simpleBasicAuth: (username: string, password: string, realm?: string) => Wrapper<Context>;
type BearerAuthOptions = {
	/** Validate token (return true if valid) */
	readonly validate: (token: string, ctx: Context) => boolean | Promise<boolean>;
	/** Skip auth for certain requests */
	readonly skip?: (ctx: Context) => boolean;
	/** Custom unauthorized response */
	readonly onUnauthorized?: (ctx: Context) => ServerResponse2;
	/** Token header name (default: authorization) */
	readonly header?: string;
	/** Token prefix (default: Bearer) */
	readonly prefix?: string;
};
/**
* Parse Bearer token from header
*/
declare const parseBearerToken: (header: string, prefix?: string) => string | null;
/**
* Bearer token middleware
*/
declare const bearerAuth: (options: BearerAuthOptions) => Wrapper<Context>;
/**
* API Key middleware (from header or query)
*/
type ApiKeyOptions = {
	/** Validate API key */
	readonly validate: (key: string, ctx: Context) => boolean | Promise<boolean>;
	/** Header name (default: x-api-key) */
	readonly header?: string;
	/** Query parameter name (default: api_key) */
	readonly query?: string;
	/** Skip auth for certain requests */
	readonly skip?: (ctx: Context) => boolean;
	/** Custom unauthorized response */
	readonly onUnauthorized?: (ctx: Context) => ServerResponse2;
};
declare const apiKeyAuth: (options: ApiKeyOptions) => Wrapper<Context>;
/**
* Simple API key validation with static keys
*/
declare const simpleApiKey: (validKeys: string[], options?: Partial<Omit<ApiKeyOptions, "validate">>) => Wrapper<Context>;
type HmacOptions = {
	/** Secret key for HMAC */
	readonly secret: string;
	/** Algorithm (default: sha256) */
	readonly algorithm?: string;
	/** Header name for signature (default: x-signature) */
	readonly header?: string;
	/** Skip verification for certain requests */
	readonly skip?: (ctx: Context) => boolean;
};
/**
* Generate HMAC signature
*/
declare const generateHmac: (data: string | Buffer, secret: string, algorithm?: string) => string;
/**
* Verify HMAC signature
*/
declare const verifyHmac: (data: string | Buffer, signature: string, secret: string, algorithm?: string) => boolean;
/**
* HMAC signature verification middleware
*/
declare const hmacAuth: (options: HmacOptions) => Wrapper<Context>;
/**
* Body and Query String Parsing
* JSON, URL-encoded form, multipart, and query string parsing
*/
type ParsedBody = {
	readonly json: <T = unknown>() => T;
	readonly text: () => string;
	readonly form: () => Record<string, string>;
	readonly raw: Buffer;
};
/**
* Parse query string into object
*/
declare const parseQuery: (queryString: string) => Record<string, string | string[]>;
/**
* Stringify object to query string
*/
declare const stringifyQuery: (params: Record<string, string | string[] | number | boolean | undefined>) => string;
/**
* Parse URL-encoded form body
*/
declare const parseFormBody: (body: Buffer | string) => Record<string, string>;
/**
* Parse JSON body safely
*/
declare const parseJsonBody: <T = unknown>(body: Buffer | string) => T;
/**
* Multipart boundary parser
*/
type MultipartPart = {
	readonly name: string;
	readonly filename?: string;
	readonly contentType?: string;
	readonly data: Buffer;
};
/**
* Parse multipart form data
*/
declare const parseMultipart: (body: Buffer, boundary: string) => MultipartPart[];
/**
* Extract boundary from Content-Type header
*/
declare const extractBoundary: (contentType: string) => string | null;
/**
* Get content type without parameters
*/
declare const getContentType: (contentTypeHeader: string | undefined) => string;
/**
* Check if content type is JSON
*/
declare const isJsonContent: (contentType: string) => boolean;
/**
* Check if content type is form
*/
declare const isFormContent: (contentType: string) => boolean;
/**
* Check if content type is multipart
*/
declare const isMultipartContent: (contentType: string) => boolean;
import { ServerResponse as ServerResponse3, Wrapper as Wrapper2 } from "@sylphx/gust-core";
type BodyLimitOptions = {
	/** Max body size in bytes (default: 1MB) */
	readonly maxSize?: number;
	/** Custom error response */
	readonly onLimit?: (ctx: Context, size: number) => ServerResponse3;
	/** Skip limit check for certain requests */
	readonly skip?: (ctx: Context) => boolean;
};
/**
* Parse size string to bytes
* Supports: 1kb, 1mb, 1gb, or raw number
*/
declare const parseSize: (size: string | number) => number;
/**
* Format bytes to human readable
*/
declare const formatSize: (bytes: number) => string;
/**
* Create body size limit wrapper
*/
declare const bodyLimit: (options?: BodyLimitOptions) => Wrapper2<Context>;
/**
* Preset: 100KB limit (for JSON APIs)
*/
declare const jsonLimit: () => Wrapper2<Context>;
/**
* Preset: 10MB limit (for file uploads)
*/
declare const uploadLimit: () => Wrapper2<Context>;
/**
* Preset: 50MB limit (for large uploads)
*/
declare const largeUploadLimit: () => Wrapper2<Context>;
import { ServerResponse as ServerResponse4, Wrapper as Wrapper3 } from "@sylphx/gust-core";
type CacheEntry = {
	/** Cached response */
	response: ServerResponse4;
	/** Timestamp when cached */
	timestamp: number;
	/** Cache key */
	key: string;
	/** TTL in milliseconds */
	ttl: number;
	/** Cache tags for invalidation */
	tags?: string[];
};
type CacheStore = {
	/** Get cached entry */
	get: (key: string) => Promise<CacheEntry | null>;
	/** Set cache entry */
	set: (key: string, entry: CacheEntry) => Promise<void>;
	/** Delete cache entry */
	delete: (key: string) => Promise<void>;
	/** Delete entries by tag */
	deleteByTag?: (tag: string) => Promise<void>;
	/** Clear all entries */
	clear: () => Promise<void>;
};
type CacheOptions = {
	/** Cache store (default: MemoryCache) */
	readonly store?: CacheStore;
	/** TTL in milliseconds (default: 5 minutes) */
	readonly ttl?: number;
	/** Generate cache key */
	readonly key?: (ctx: Context) => string;
	/** Skip caching for certain requests */
	readonly skip?: (ctx: Context) => boolean;
	/** Skip caching certain responses */
	readonly skipResponse?: (res: ServerResponse4) => boolean;
	/** Cache tags for invalidation */
	readonly tags?: (ctx: Context) => string[];
	/** HTTP methods to cache (default: GET, HEAD) */
	readonly methods?: string[];
	/** Status codes to cache (default: 200) */
	readonly statusCodes?: number[];
	/** Add cache headers */
	readonly cacheControl?: boolean;
	/** Stale-while-revalidate in milliseconds */
	readonly staleWhileRevalidate?: number;
};
declare class MemoryCache implements CacheStore {
	private cache;
	private tagIndex;
	private cleanupInterval;
	constructor(cleanupMs?: number);
	private removeFromTagIndex;
	get(key: string): Promise<CacheEntry | null>;
	set(key: string, entry: CacheEntry): Promise<void>;
	delete(key: string): Promise<void>;
	deleteByTag(tag: string): Promise<void>;
	clear(): Promise<void>;
	/**
	* Get cache stats
	*/
	stats(): {
		size: number;
		tags: number;
	};
	/**
	* Close and cleanup
	*/
	close(): void;
}
declare class LRUCache implements CacheStore {
	private cache;
	private readonly maxSize;
	constructor(maxSize?: number);
	get(key: string): Promise<CacheEntry | null>;
	set(key: string, entry: CacheEntry): Promise<void>;
	delete(key: string): Promise<void>;
	clear(): Promise<void>;
	stats(): {
		size: number;
		maxSize: number;
	};
}
/**
* Generate cache key from request
*/
declare const defaultCacheKey: (ctx: Context) => string;
/**
* Generate cache key with headers
*/
declare const varyingCacheKey: (headers: string[]) => (ctx: Context) => string;
/**
* Response caching middleware
*/
declare const cache: (options?: CacheOptions) => Wrapper3<Context>;
/**
* Cache invalidation helper
*/
declare const invalidateCache: (store: CacheStore, keyOrTag: string, isTag?: boolean) => Promise<void>;
/**
* No-cache middleware (prevent caching)
*/
declare const noCache: () => Wrapper3<Context>;
/**
* ETag-based conditional caching
*/
declare const etag: () => Wrapper3<Context>;
import { EventEmitter } from "node:events";
import { ServerResponse as ServerResponse5, Wrapper as Wrapper4 } from "@sylphx/gust-core";
type CircuitState = "closed" | "open" | "half-open";
type CircuitBreakerOptions = {
	/** Failure threshold to open circuit (default: 5) */
	readonly failureThreshold?: number;
	/** Success threshold to close circuit (default: 2) */
	readonly successThreshold?: number;
	/** Time in ms before trying again (default: 30s) */
	readonly resetTimeout?: number;
	/** Time window for counting failures (default: 60s) */
	readonly failureWindow?: number;
	/** Timeout for each request (default: 10s) */
	readonly timeout?: number;
	/** Custom fallback response */
	readonly fallback?: (ctx: Context, error: Error) => ServerResponse5 | Promise<ServerResponse5>;
	/** Consider response a failure */
	readonly isFailure?: (res: ServerResponse5) => boolean;
	/** Name for this circuit (for monitoring) */
	readonly name?: string;
	/** On state change callback */
	readonly onStateChange?: (state: CircuitState, name: string) => void;
};
type CircuitStats = {
	state: CircuitState;
	failures: number;
	successes: number;
	lastFailure: number | null;
	lastSuccess: number | null;
	totalRequests: number;
	totalFailures: number;
	totalSuccesses: number;
};
/**
* Circuit Breaker
*
* Uses native Rust implementation when available for maximum performance.
* Falls back to pure TypeScript for edge/serverless environments.
*/
declare class CircuitBreaker extends EventEmitter {
	private native;
	private state;
	private failures;
	private successes;
	private lastFailure;
	private lastSuccess;
	private totalRequests;
	private totalFailures;
	private totalSuccesses;
	private nextAttempt;
	private readonly failureThreshold;
	private readonly successThreshold;
	private readonly resetTimeout;
	private readonly failureWindow;
	private readonly timeout;
	private readonly name;
	constructor(options?: CircuitBreakerOptions);
	/** Check if using native implementation */
	get isNative(): boolean;
	/**
	* Get current state
	*/
	getState(): CircuitState;
	/**
	* Get statistics
	*/
	getStats(): CircuitStats;
	/**
	* Check if request can proceed
	*/
	canRequest(): boolean;
	/**
	* Record success
	*/
	recordSuccess(): void;
	/**
	* Record failure
	*/
	recordFailure(): void;
	/**
	* Force open the circuit
	*/
	open(): void;
	/**
	* Force close the circuit
	*/
	close(): void;
	/**
	* Reset the circuit
	*/
	reset(): void;
	private toOpen;
	private toHalfOpen;
	private toClosed;
}
/**
* Circuit breaker middleware
*/
declare const circuitBreaker: (options?: CircuitBreakerOptions) => Wrapper4<Context>;
declare const getCircuitBreaker: (name: string, options?: CircuitBreakerOptions) => CircuitBreaker;
/**
* Wrap async function with circuit breaker
*/
declare const withCircuitBreaker: <T extends (...args: unknown[]) => Promise<unknown>>(fn: T, options?: CircuitBreakerOptions) => T;
type BulkheadOptions = {
	/** Max concurrent requests (default: 10) */
	readonly maxConcurrent?: number;
	/** Max queue size (default: 100) */
	readonly maxQueue?: number;
	/** Queue timeout in ms (default: 30s) */
	readonly queueTimeout?: number;
	/** Custom rejection response */
	readonly onReject?: (ctx: Context) => ServerResponse5;
};
/**
* Bulkhead middleware (limit concurrency)
*
* Uses native Rust implementation when available for maximum performance.
* Falls back to pure TypeScript for edge/serverless environments.
*/
declare const bulkhead: (options?: BulkheadOptions) => Wrapper4<Context>;
import { Worker as ClusterWorker } from "node:cluster";
import { EventEmitter as EventEmitter2 } from "node:events";
import { Handler } from "@sylphx/gust-core";
import { ServerResponse as ServerResponse6 } from "@sylphx/gust-core";
/** Extract param names from path string */
type ExtractParams<Path extends string> = Path extends `${string}:${infer Param}/${infer Rest}` ? Param | ExtractParams<`/${Rest}`> : Path extends `${string}:${infer Param}` ? Param : never;
/** Check if path has params */
type HasParams<Path extends string> = ExtractParams<Path> extends never ? false : true;
/** Params object type for handler context (always string) */
type ParamsFor<Path extends string> = HasParams<Path> extends true ? { [K in ExtractParams<Path>] : string } : Record<string, string>;
/**
* Handler function type for routes
* Receives { ctx, input } and returns a ServerResponse
*/
type RouteHandlerFn<
	App = Record<string, never>,
	TPath extends string = string,
	Input = void
> = (args: {
	readonly ctx: Context<App> & {
		readonly params: ParamsFor<TPath>;
	};
	readonly input: Input;
}) => ServerResponse6 | Promise<ServerResponse6>;
/**
* Route definition with method, path, and handler
*/
type Route<
	TMethod extends string = string,
	TPath extends string = string,
	App = Record<string, never>
> = {
	readonly method: TMethod;
	readonly path: TPath;
	readonly handler: RouteHandlerFn<App, TPath>;
};
type Routes<App = unknown> = Route<string, string, App>[];
/**
* Create a GET route
*
* @example
* ```typescript
* // Without app context
* const users = get('/users', ({ ctx }) => json(ctx.query))
*
* // With app context
* const users = get<App>('/users', ({ ctx }) => json(ctx.app.db.getUsers()))
* ```
*/
declare const get: <
	App = Record<string, never>,
	TPath extends string = string
>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"GET", TPath, App>;
declare const post: <
	App = Record<string, never>,
	TPath extends string = string
>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"POST", TPath, App>;
declare const put: <
	App = Record<string, never>,
	TPath extends string = string
>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"PUT", TPath, App>;
declare const patch: <
	App = Record<string, never>,
	TPath extends string = string
>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"PATCH", TPath, App>;
declare const del: <
	App = Record<string, never>,
	TPath extends string = string
>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"DELETE", TPath, App>;
declare const head: <
	App = Record<string, never>,
	TPath extends string = string
>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"HEAD", TPath, App>;
declare const options: <
	App = Record<string, never>,
	TPath extends string = string
>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"OPTIONS", TPath, App>;
declare const all: <
	App = Record<string, never>,
	TPath extends string = string
>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"*", TPath, App>;
/**
* Prefix routes with a path segment (for nested routes)
*
* @example
* ```typescript
* const memberRoutes = routes('/members', [
*   get('/', ({ ctx }) => json(getAll())),
*   get('/:id', ({ ctx }) => json(getOne(ctx.params.id))),
* ])
*
* // Nested
* const adminRoutes = routes('/admin', [
*   get('/dashboard', ...),
*   ...routes('/users', [
*     get('/', ...),        // /admin/users
*     get('/:id', ...),     // /admin/users/:id
*   ]),
* ])
*
* serve({
*   routes: [
*     get('/', () => json({ home: true })),
*     ...memberRoutes,
*     ...adminRoutes,
*   ],
* })
* ```
*/
declare const routes: <App = Record<string, never>>(prefix: string, routeList: Route<string, string, App>[]) => Route<string, string, App>[];
/**
* Typed route builders for a specific App context
*/
type TypedRouteBuilders<App> = {
	get: <TPath extends string>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"GET", TPath, App>;
	post: <TPath extends string>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"POST", TPath, App>;
	put: <TPath extends string>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"PUT", TPath, App>;
	patch: <TPath extends string>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"PATCH", TPath, App>;
	del: <TPath extends string>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"DELETE", TPath, App>;
	head: <TPath extends string>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"HEAD", TPath, App>;
	options: <TPath extends string>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"OPTIONS", TPath, App>;
	all: <TPath extends string>(path: TPath, handler: RouteHandlerFn<App, TPath>) => Route<"*", TPath, App>;
	routes: (prefix: string, routeList: Route<string, string, App>[]) => Route<string, string, App>[];
};
/**
* Create typed route builders for a specific App context
*
* This factory pattern provides full type inference for app context
* without repeating the type parameter on every route.
*
* @example
* ```typescript
* type AppContext = { db: Database; user: User | null }
*
* const { get, post, routes } = createRouter<AppContext>()
*
* // Full type inference - ctx.app.db and ctx.app.user are typed
* const users = get('/users', ({ ctx }) => json(ctx.app.db.getUsers()))
*
* // Nested routes
* const memberRoutes = routes('/members', [
*   get('/', ({ ctx }) => json(ctx.app.db.getMembers())),
*   get('/:id', ({ ctx }) => json(ctx.app.db.getMember(ctx.params.id))),
* ])
*
* serve({
*   routes: [users, ...memberRoutes],
*   context: () => ({ db: createDb(), user: null }),
*   port: 3000,
* })
* ```
*/
declare const createRouter: <App>() => TypedRouteBuilders<App>;
type TlsOptions = {
	/** TLS certificate (PEM format) */
	readonly cert: string | Buffer;
	/** TLS private key (PEM format) */
	readonly key: string | Buffer;
	/** CA certificate chain (optional) */
	readonly ca?: string | Buffer | Array<string | Buffer>;
	/** Passphrase for encrypted key (optional) */
	readonly passphrase?: string;
};
/**
* Context provider function - creates app context for each request
* Can be sync (static context) or async (per-request context)
*/
type ContextProvider<App> = (raw: RawContext) => App | Promise<App>;
/**
* Middleware type - polymorphic over App
*
* Middleware works with any App type, making it usable as both
* global middleware and route-level middleware.
*
* @example
* ```typescript
* // Middleware that works with any App
* const cors = (options?: CorsOptions): Middleware =>
*   <App>(handler: Handler<Context<App>>) =>
*     async (ctx: Context<App>) => {
*       // Add CORS headers
*       const res = await handler(ctx)
*       return { ...res, headers: { ...res.headers, ...corsHeaders } }
*     }
*
* // Usage - no type annotations needed
* serve({
*   middleware: cors(),
*   routes: [...]
* })
* ```
*/
/**
* Middleware with bounded polymorphism
*
* - `Middleware` = `Middleware<unknown>` = universal, works with any App
* - `Middleware<R>` = bounded, requires App extends R
*
* @example
* ```typescript
* // Universal middleware - no App requirements
* const cors = (): Middleware => ...
*
* // Bounded middleware - requires App with userId
* const rateLimit = <App extends { userId: string }>(): Middleware<App> => ...
* ```
*/
type Middleware<RequiredApp = unknown> = <App extends RequiredApp>(handler: Handler<Context<App>>) => Handler<Context<App>>;
/**
* Serve options
*/
type ServeOptions<App = Record<string, never>> = {
	readonly port?: number;
	readonly hostname?: string;
	/** Routes created with get(), post(), etc. */
	readonly routes: Route<string, string, App>[];
	/** Global middleware - wraps the entire router
	* Use Middleware (universal) or Middleware<App> (bounded) */
	readonly middleware?: Middleware<Partial<App>>;
	/** Context provider - creates app context for each request */
	readonly context?: ContextProvider<App>;
	readonly onListen?: (info: {
		port: number;
		hostname: string;
		tls: boolean;
	}) => void;
	readonly onError?: (error: Error) => void;
	readonly keepAliveTimeout?: number;
	readonly maxRequestsPerConnection?: number;
	readonly requestTimeout?: number;
	readonly maxHeaderSize?: number;
	/** Maximum body size in bytes (default: 1MB) */
	readonly maxBodySize?: number;
	/** TLS configuration for HTTPS */
	readonly tls?: TlsOptions;
	/** Enable HTTP/2 (only with TLS) */
	readonly http2?: boolean;
};
type Server = {
	readonly port: number;
	readonly hostname: string;
	readonly tls: boolean;
	/** Stop server immediately */
	readonly stop: () => Promise<void>;
	/** Graceful shutdown - wait for active requests to complete */
	readonly shutdown: (timeout?: number) => Promise<void>;
	/** Get active connection count */
	readonly connections: () => number;
};
/**
* Start the HTTP/HTTPS server
*
* @example
* ```ts
* type App = { db: Database }
* const { get } = createRouter<App>()
*
* serve({
*   routes: [get('/users', ({ ctx }) => json(ctx.app.db.getUsers()))],
*   context: () => ({ db: createDb() }),
*   middleware: cors(),
*   port: 3000,
* })
* ```
*
* Architecture:
* - Primary: Rust native server via napi-rs (~220k req/s) - full feature support
* - Fallback: Node.js net/tls + WASM HTTP parser (edge/serverless)
*/
declare const serve: <App = Record<string, never>>(options: ServeOptions<App>) => Promise<Server>;
type ClusterOptions = {
	/** Number of workers (default: native recommended or CPU count) */
	readonly workers?: number;
	/** Restart workers on crash (default: true) */
	readonly autoRestart?: boolean;
	/** Max restarts per worker per minute (default: 5) */
	readonly maxRestarts?: number;
	/** Graceful shutdown timeout in ms (default: 30s) */
	readonly shutdownTimeout?: number;
	/** On worker start */
	readonly onWorkerStart?: (worker: ClusterWorker) => void;
	/** On worker exit */
	readonly onWorkerExit?: (worker: ClusterWorker, code: number, signal: string) => void;
	/** On all workers ready */
	readonly onReady?: () => void;
	/** On rolling restart complete */
	readonly onRestart?: () => void;
	/** On scale change */
	readonly onScale?: (workerCount: number) => void;
};
type ClusterInfo = {
	/** Is this the master process? */
	readonly isMaster: boolean;
	/** Worker ID (0 for master) */
	readonly workerId: number;
	/** Total number of workers */
	readonly workerCount: number;
	/** Process ID */
	readonly pid: number;
};
declare class ClusterManager extends EventEmitter2 {
	private workers;
	private restartCounts;
	private isShuttingDown;
	private readyWorkers;
	private readonly workerCount;
	private readonly autoRestart;
	private readonly maxRestarts;
	private readonly shutdownTimeout;
	constructor(options?: ClusterOptions);
	/**
	* Start cluster
	*/
	start(): void;
	/**
	* Fork a new worker
	*/
	private forkWorker;
	/**
	* Maybe restart a worker (with rate limiting)
	*/
	private maybeRestart;
	/**
	* Graceful shutdown
	*/
	shutdown(): Promise<void>;
	/**
	* Get cluster info
	*/
	info(): {
		workers: number;
		pids: number[];
	};
	/**
	* Send message to all workers
	*/
	broadcast(message: object | string | number | boolean): void;
	/**
	* Send message to specific worker
	*/
	sendTo(workerId: number, message: object | string | number | boolean): boolean;
	/**
	* Rolling restart - zero-downtime restart of all workers
	*
	* Restarts workers one at a time, waiting for each new worker
	* to be ready before stopping the old one.
	*/
	rollingRestart(): Promise<void>;
	/**
	* Scale up - add workers
	*/
	scaleUp(count?: number): void;
	/**
	* Scale down - remove workers
	*/
	scaleDown(count?: number): Promise<void>;
	/**
	* Set target worker count (scales up or down as needed)
	*/
	setWorkerCount(count: number): Promise<void>;
}
/**
* Get cluster info for current process
*/
declare const getClusterInfo: () => ClusterInfo;
/**
* Check if running in cluster mode
*/
declare const isCluster: () => boolean;
/**
* Check if this is the primary process
*/
declare const isPrimary: () => boolean;
/**
* Check if this is a worker process
*/
declare const isWorker: () => boolean;
type ClusterServeOptions = ServeOptions & ClusterOptions;
/**
* Start server in cluster mode
*
* Usage:
* ```ts
* import { clusterServe } from '@sylphx/gust'
*
* clusterServe({
*   port: 3000,
*   fetch: (ctx) => json({ hello: 'world' }),
*   workers: 4,
* })
* ```
*/
declare const clusterServe: (options: ClusterServeOptions, serverFn?: () => Promise<Server>) => Promise<ClusterManager | Server>;
/**
* Simple cluster wrapper
*
* Usage:
* ```ts
* import { cluster } from '@sylphx/gust'
*
* cluster(() => {
*   // Your server code here
*   serve({ ... })
* })
* ```
*/
declare const runCluster: (workerFn: () => void | Promise<void>, options?: ClusterOptions) => void;
/**
* Sticky sessions for WebSocket (based on IP)
* Note: Requires custom load balancer setup
*/
declare const stickySession: (ip: string, workerCount: number) => number;
type CompressionOptions = {
	/** Minimum size to compress (default: 1024 bytes) */
	readonly threshold?: number;
	/** Compression level (1-9, default: 6) */
	readonly level?: number;
	/** Encodings to support (default: ['br', 'gzip', 'deflate']) */
	readonly encodings?: Array<"br" | "gzip" | "deflate">;
	/** MIME types to compress */
	readonly mimeTypes?: string[];
};
/**
* Create compression middleware
*
* Compresses responses using gzip, deflate, or brotli.
* Works as both global middleware and route-level middleware.
*
* @example
* ```typescript
* serve({
*   middleware: compress(),
*   routes: [...]
* })
* ```
*/
declare const compress: (options?: CompressionOptions) => Middleware;
/**
* Convenience wrapper for gzip-only compression
*/
declare const gzip: (level?: number) => Middleware;
/**
* Convenience wrapper for brotli-only compression
*/
declare const brotli: (level?: number) => Middleware;
/**
* Cookie parsing and serialization
* RFC 6265 compliant cookie handling
*/
type CookieOptions = {
	/** Cookie domain */
	readonly domain?: string;
	/** Cookie path */
	readonly path?: string;
	/** Expiration date */
	readonly expires?: Date;
	/** Max age in seconds */
	readonly maxAge?: number;
	/** HTTP only flag */
	readonly httpOnly?: boolean;
	/** Secure flag (HTTPS only) */
	readonly secure?: boolean;
	/** SameSite attribute */
	readonly sameSite?: "Strict" | "Lax" | "None";
	/** Partitioned attribute (CHIPS) */
	readonly partitioned?: boolean;
};
type Cookie = {
	readonly name: string;
	readonly value: string;
} & CookieOptions;
/**
* Parse Cookie header string into key-value pairs
*/
declare const parseCookies: (cookieHeader: string) => Record<string, string>;
/**
* Serialize cookie for Set-Cookie header
*/
declare const serializeCookie: (name: string, value: string, options?: CookieOptions) => string;
/**
* Create a delete cookie string (sets expiration in past)
*/
declare const deleteCookie: (name: string, options?: Pick<CookieOptions, "domain" | "path">) => string;
/**
* Get cookies from context headers
*/
declare const getCookies: (headers: Record<string, string>) => Record<string, string>;
/**
* Get a specific cookie value
*/
declare const getCookie: (headers: Record<string, string>, name: string) => string | undefined;
/**
* Create Set-Cookie header value for a single cookie
*/
declare const setCookie: (name: string, value: string, options?: CookieOptions) => string;
/**
* Create multiple Set-Cookie headers
* Returns array of header values (HTTP allows multiple Set-Cookie headers)
*/
declare const setCookies: (cookies: Cookie[]) => string[];
type CorsOptions = {
	/** Allowed origins (string, array, or function) */
	readonly origin?: string | string[] | ((origin: string) => boolean);
	/** Allowed HTTP methods */
	readonly methods?: string[];
	/** Allowed headers */
	readonly allowedHeaders?: string[];
	/** Exposed headers */
	readonly exposedHeaders?: string[];
	/** Allow credentials */
	readonly credentials?: boolean;
	/** Max age for preflight cache (seconds) */
	readonly maxAge?: number;
	/** Handle preflight automatically */
	readonly preflight?: boolean;
};
/**
* Create CORS middleware
*
* Handles preflight OPTIONS requests and adds CORS headers to responses.
* Works as both global middleware and route-level middleware.
*
* @example
* ```typescript
* // Global middleware
* serve({
*   middleware: cors({ origin: 'https://example.com' }),
*   routes: [...]
* })
*
* // Route-level (via compose)
* get('/api', compose(cors(), handler))
* ```
*/
declare const cors: (options?: CorsOptions) => Middleware;
/**
* Simple CORS - allows all origins
* Convenience wrapper for development
*/
declare const simpleCors: () => Middleware;
import { ServerResponse as ServerResponse7, Wrapper as Wrapper5 } from "@sylphx/gust-core";
type CsrfOptions = {
	/** Secret for token generation */
	readonly secret: string;
	/** Cookie name (default: _csrf) */
	readonly cookie?: string;
	/** Header name (default: x-csrf-token) */
	readonly header?: string;
	/** Form field name (default: _csrf) */
	readonly field?: string;
	/** Token length in bytes (default: 32) */
	readonly tokenLength?: number;
	/** Cookie options */
	readonly cookieOptions?: Omit<CookieOptions, "httpOnly">;
	/** HTTP methods to protect (default: POST, PUT, PATCH, DELETE) */
	readonly methods?: string[];
	/** Skip CSRF for certain requests */
	readonly skip?: (ctx: Context) => boolean;
	/** Custom error response */
	readonly onError?: (ctx: Context) => ServerResponse7;
};
/**
* Generate CSRF token from secret
* Uses native random for salt, HMAC for signing.
*/
declare const generateCsrfToken: (secret: string, salt?: string) => string;
/**
* Verify CSRF token against secret
*/
declare const verifyCsrfToken: (token: string, secret: string) => boolean;
/**
* Get CSRF token for context (for templates)
*/
declare const getCsrfToken: (ctx: Context) => string | undefined;
/**
* CSRF protection middleware
*/
declare const csrf: (options: CsrfOptions) => Wrapper5<Context>;
/**
* Double Submit Cookie pattern (simpler, stateless)
*/
declare const csrfDoubleSubmit: (options?: Omit<CsrfOptions, "secret">) => Wrapper5<Context>;
/**
* Generate HTML input field for CSRF token
*/
declare const csrfField: (ctx: Context, fieldName?: string) => string;
/**
* Generate meta tag for CSRF token (for AJAX)
*/
declare const csrfMeta: (ctx: Context, name?: string) => string;
import { Handler as Handler2, ServerResponse as ServerResponse8 } from "@sylphx/gust-core";
type HealthStatus = "healthy" | "unhealthy" | "degraded";
type HealthCheck = {
	/** Check name */
	name: string;
	/** Check function */
	check: () => boolean | Promise<boolean>;
	/** Is this check critical? (default: true) */
	critical?: boolean;
	/** Timeout in ms (default: 5000) */
	timeout?: number;
};
type HealthResult = {
	status: HealthStatus;
	checks: Record<string, {
		status: "pass" | "fail";
		duration: number;
		message?: string;
	}>;
	timestamp: string;
	uptime: number;
};
type HealthOptions = {
	/** Health checks to run */
	readonly checks?: HealthCheck[];
	/** Include detailed check results */
	readonly detailed?: boolean;
	/** Custom healthy response */
	readonly onHealthy?: (result: HealthResult) => ServerResponse8;
	/** Custom unhealthy response */
	readonly onUnhealthy?: (result: HealthResult) => ServerResponse8;
};
/**
* Run health checks
*/
declare const runHealthChecks: (checks: HealthCheck[]) => Promise<HealthResult>;
/**
* Simple health check handler (always returns 200)
*/
declare const healthCheck: () => Handler2<Context>;
/**
* Detailed health check handler
*/
declare const health: (options?: HealthOptions) => Handler2<Context>;
/**
* Kubernetes liveness probe
* Returns 200 if the process is running
*/
declare const liveness: () => Handler2<Context>;
/**
* Kubernetes readiness probe
* Returns 200 if the service is ready to accept traffic
*/
declare const readiness: (checks?: HealthCheck[]) => Handler2<Context>;
/**
* Startup probe
* Returns 200 once initial startup is complete
*/
declare const startup: (isReady: () => boolean | Promise<boolean>) => Handler2<Context>;
/**
* Memory usage check
*/
declare const memoryCheck: (maxHeapPercent?: number) => HealthCheck;
/**
* Event loop lag check
*/
declare const eventLoopCheck: (maxLagMs?: number) => HealthCheck;
/**
* External service check (HTTP)
*/
declare const httpCheck: (name: string, url: string, expectedStatus?: number) => HealthCheck;
/**
* Custom check factory
*/
declare const customCheck: (name: string, check: () => boolean | Promise<boolean>, options?: Partial<Omit<HealthCheck, "name" | "check">>) => HealthCheck;
type Metrics = {
	uptime: number;
	memory: {
		heapUsed: number;
		heapTotal: number;
		external: number;
		rss: number;
	};
	cpu: {
		user: number;
		system: number;
	};
};
/**
* Get current metrics
*/
declare const getMetrics: () => Metrics;
/**
* Metrics endpoint handler
*/
declare const metrics: () => Handler2<Context>;
/**
* Prometheus-format metrics
*/
declare const prometheusMetrics: (prefix?: string) => Handler2<Context>;
import { ServerHttp2Stream } from "node:http2";
import { Handler as Handler3 } from "@sylphx/gust-core";
type Http2Context = {
	/** HTTP method */
	readonly method: string;
	/** Request path */
	readonly path: string;
	/** Query string (including ?) */
	readonly query: string;
	/** Request headers */
	readonly headers: Record<string, string>;
	/** Request body */
	readonly body: Buffer;
	/** HTTP/2 stream */
	readonly stream: ServerHttp2Stream;
	/** Authority (host) */
	readonly authority: string;
	/** Scheme (https) */
	readonly scheme: string;
	/** Route params (set by router) */
	params?: Record<string, string>;
};
type Http2Options = {
	/** Port (default: 443 for secure, 8443 for insecure) */
	readonly port?: number;
	/** Hostname (default: 0.0.0.0) */
	readonly hostname?: string;
	/** Request handler */
	readonly fetch: Handler3<Http2Context>;
	/** TLS certificate (required for secure server) */
	readonly cert?: string | Buffer;
	/** TLS private key (required for secure server) */
	readonly key?: string | Buffer;
	/** Allow HTTP/2 over plain TCP (h2c) - not recommended for production */
	readonly allowHttp1?: boolean;
	/** On listen callback */
	readonly onListen?: (info: {
		port: number;
		hostname: string;
	}) => void;
	/** On error callback */
	readonly onError?: (error: Error) => void;
	/** Max concurrent streams per connection (default: 100) */
	readonly maxConcurrentStreams?: number;
	/** Initial window size (default: 65535) */
	readonly initialWindowSize?: number;
	/** Max header list size (default: 16KB) */
	readonly maxHeaderListSize?: number;
};
type Http2ServerInstance = {
	readonly port: number;
	readonly hostname: string;
	readonly stop: () => Promise<void>;
	readonly push: (stream: ServerHttp2Stream, path: string, headers?: Record<string, string>) => ServerHttp2Stream | null;
};
/**
* Start HTTP/2 server (secure)
*/
declare const serveHttp2: (options: Http2Options) => Promise<Http2ServerInstance>;
type PushOptions = {
	/** Content type */
	readonly contentType?: string;
	/** Cache control */
	readonly cacheControl?: string;
	/** Additional headers */
	readonly headers?: Record<string, string>;
};
/**
* Push a resource to the client
*/
declare const pushResource: (stream: ServerHttp2Stream, path: string, content: string | Buffer, options?: PushOptions) => boolean;
/**
* Push multiple resources
*/
declare const pushResources: (stream: ServerHttp2Stream, resources: Array<{
	path: string;
	content: string | Buffer;
	options?: PushOptions;
}>) => number;
/**
* Get negotiated protocol from TLS socket
*/
declare const getAlpnProtocol: (socket: {
	alpnProtocol?: string;
}) => string;
/**
* Check if connection is HTTP/2
*/
declare const isHttp2: (socket: {
	alpnProtocol?: string;
}) => boolean;
/**
* Generate Link header for preload hints
*/
declare const preloadHint: (resources: Array<{
	path: string;
	as: string;
	crossorigin?: boolean;
}>) => string;
type PreloadResource = {
	path: string;
	as: string;
	crossorigin?: boolean;
};
/**
* Common preload types
*/
declare const preload: {
	script: (path: string) => PreloadResource;
	style: (path: string) => PreloadResource;
	image: (path: string) => PreloadResource;
	font: (path: string, crossorigin?: boolean) => PreloadResource;
	fetch: (path: string) => PreloadResource;
};
import { ServerResponse as ServerResponse9, Wrapper as Wrapper6 } from "@sylphx/gust-core";
type JwtHeader = {
	alg: "HS256" | "HS384" | "HS512";
	typ: "JWT";
};
type JwtPayload = {
	/** Subject (user ID) */
	sub?: string;
	/** Issuer */
	iss?: string;
	/** Audience */
	aud?: string | string[];
	/** Expiration time (Unix timestamp) */
	exp?: number;
	/** Not before (Unix timestamp) */
	nbf?: number;
	/** Issued at (Unix timestamp) */
	iat?: number;
	/** JWT ID */
	jti?: string;
	/** Custom claims */
	[key: string]: unknown;
};
type JwtOptions = {
	/** Secret key for signing */
	readonly secret: string;
	/** Algorithm (default: HS256) */
	readonly algorithm?: "HS256" | "HS384" | "HS512";
	/** Token expiration in seconds (default: 1 hour) */
	readonly expiresIn?: number;
	/** Issuer */
	readonly issuer?: string;
	/** Audience */
	readonly audience?: string | string[];
};
type VerifyOptions = {
	/** Secret key */
	readonly secret: string;
	/** Expected algorithms */
	readonly algorithms?: ("HS256" | "HS384" | "HS512")[];
	/** Expected issuer */
	readonly issuer?: string;
	/** Expected audience */
	readonly audience?: string | string[];
	/** Clock tolerance in seconds (default: 0) */
	readonly clockTolerance?: number;
	/** Ignore expiration */
	readonly ignoreExpiration?: boolean;
};
type JwtResult<T = JwtPayload> = {
	valid: true;
	payload: T;
	header: JwtHeader;
} | {
	valid: false;
	error: string;
};
/**
* Create a JWT token
*/
declare const createJwt: (payload: JwtPayload, options: JwtOptions) => string;
/**
* Verify and decode a JWT token
*/
declare const verifyJwt: <T extends JwtPayload = JwtPayload>(token: string, options: VerifyOptions) => JwtResult<T>;
/**
* Decode JWT without verification (unsafe - for debugging only)
*/
declare const decodeJwt: <T extends JwtPayload = JwtPayload>(token: string) => {
	header: JwtHeader;
	payload: T;
} | null;
/**
* Check if token is expired (without full verification)
*/
declare const isJwtExpired: (token: string) => boolean;
/**
* Get JWT payload from context
*/
declare const getJwtPayload: <T extends JwtPayload = JwtPayload>(ctx: Context) => T | undefined;
type JwtAuthOptions = {
	/** Secret key */
	readonly secret: string;
	/** Allowed algorithms */
	readonly algorithms?: ("HS256" | "HS384" | "HS512")[];
	/** Expected issuer */
	readonly issuer?: string;
	/** Expected audience */
	readonly audience?: string | string[];
	/** Clock tolerance in seconds */
	readonly clockTolerance?: number;
	/** Skip auth for certain requests */
	readonly skip?: (ctx: Context) => boolean;
	/** Custom error response */
	readonly onError?: (ctx: Context, error: string) => ServerResponse9;
	/** Get token from request (default: Authorization Bearer) */
	readonly getToken?: (ctx: Context) => string | null;
};
/**
* JWT authentication middleware
*/
declare const jwtAuth: (options: JwtAuthOptions) => Wrapper6<Context>;
/**
* Optional JWT - validates if present, continues if not
*/
declare const optionalJwt: (options: Omit<JwtAuthOptions, "skip">) => Wrapper6<Context>;
import { Wrapper as Wrapper7 } from "@sylphx/gust-core";
/**
* Span attributes following OpenTelemetry semantic conventions
*/
type SpanAttributes = Record<string, string | number | boolean | undefined>;
/**
* Span context for distributed tracing
*/
type SpanContext = {
	traceId: string;
	spanId: string;
	traceFlags: number;
	traceState?: string;
};
/**
* Span for tracing
*/
type Span = {
	name: string;
	context: SpanContext;
	parentSpanId?: string;
	startTime: number;
	endTime?: number;
	attributes: SpanAttributes;
	status: "ok" | "error" | "unset";
	events: SpanEvent[];
};
/**
* Span event
*/
type SpanEvent = {
	name: string;
	time: number;
	attributes?: SpanAttributes;
};
/**
* Tracer interface (compatible with OpenTelemetry)
*/
type Tracer = {
	startSpan: (name: string, attributes?: SpanAttributes) => Span;
	endSpan: (span: Span, status?: "ok" | "error") => void;
	addEvent: (span: Span, name: string, attributes?: SpanAttributes) => void;
	setAttributes: (span: Span, attributes: SpanAttributes) => void;
	export: (spans: Span[]) => Promise<void>;
};
/**
* Span exporter interface
*/
type SpanExporter = {
	export: (spans: Span[]) => Promise<void>;
	shutdown?: () => Promise<void>;
};
/**
* Generate 16-byte trace ID (32 hex chars)
* Uses native Rust implementation when available.
*/
declare const generateTraceId: () => string;
/**
* Generate 8-byte span ID (16 hex chars)
* Uses native Rust implementation when available.
*/
declare const generateSpanId: () => string;
/**
* Parse W3C traceparent header
* Format: version-traceId-spanId-traceFlags
* Example: 00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01
*
* Uses native Rust implementation when available.
*/
declare const parseTraceparent: (header: string) => SpanContext | null;
/**
* Format W3C traceparent header
* Uses native Rust implementation when available.
*/
declare const formatTraceparent: (ctx: SpanContext) => string;
/**
* Parse W3C tracestate header
*/
declare const parseTracestate: (header: string) => Record<string, string>;
/**
* Format W3C tracestate header
*/
declare const formatTracestate: (state: Record<string, string>) => string;
/**
* Create a simple tracer (in-memory, for development)
*/
declare const createTracer: (exporter?: SpanExporter) => Tracer;
/**
* Console exporter (for development)
*/
declare const consoleExporter: SpanExporter;
/**
* OTLP HTTP exporter (for production)
*/
declare const createOtlpExporter: (endpoint: string, headers?: Record<string, string>) => SpanExporter;
/**
* Get current span from context
*/
declare const getSpan: (ctx: Context) => Span | undefined;
type OtelOptions = {
	/** Tracer instance */
	readonly tracer: Tracer;
	/** Service name */
	readonly serviceName?: string;
	/** Skip tracing for certain requests */
	readonly skip?: (ctx: Context) => boolean;
	/** Sample rate (0-1, default: 1) */
	readonly sampleRate?: number;
	/** Add request headers to span */
	readonly captureHeaders?: string[];
	/** Add response headers to span */
	readonly captureResponseHeaders?: string[];
};
/**
* OpenTelemetry middleware
*/
declare const otel: (options: OtelOptions) => Wrapper7<Context>;
/**
* Child span helper for manual instrumentation
*/
declare const startChildSpan: (ctx: Context, tracer: Tracer, name: string, attributes?: SpanAttributes) => Span;
type Counter = {
	add: (value: number, attributes?: SpanAttributes) => void;
};
type Histogram = {
	record: (value: number, attributes?: SpanAttributes) => void;
};
type Gauge = {
	set: (value: number, attributes?: SpanAttributes) => void;
};
/**
* Simple metrics collector
*
* Uses native Rust implementation when available for maximum performance.
* Falls back to pure TypeScript for edge/serverless environments.
*/
declare class MetricsCollector {
	private native;
	private counters;
	private histograms;
	private gauges;
	constructor();
	/** Check if using native implementation */
	get isNative(): boolean;
	createCounter(name: string): Counter;
	createHistogram(name: string): Histogram;
	createGauge(name: string): Gauge;
	/**
	* Export metrics in Prometheus format
	*/
	toPrometheus(): string;
}
import { Wrapper as Wrapper8 } from "@sylphx/gust-core";
type ProxyInfo = {
	/** Client IP address */
	readonly ip: string;
	/** Original host */
	readonly host: string;
	/** Original protocol (http/https) */
	readonly protocol: "http" | "https";
	/** Original port */
	readonly port: number;
	/** Full original URL */
	readonly url: string;
	/** Forwarded IPs chain */
	readonly ips: string[];
};
/**
* Get proxy info from context
*/
declare const getProxyInfo: (ctx: Context) => ProxyInfo | undefined;
/**
* Get client IP (considering proxies)
*/
declare const getClientIp: (ctx: Context) => string;
type ProxyOptions = {
	/** Trust proxy (true = trust all, number = trust N proxies, string[] = trusted IPs) */
	readonly trust?: boolean | number | string[];
	/** Custom header for IP (default: x-forwarded-for) */
	readonly ipHeader?: string;
	/** Custom header for host (default: x-forwarded-host) */
	readonly hostHeader?: string;
	/** Custom header for protocol (default: x-forwarded-proto) */
	readonly protoHeader?: string;
	/** Custom header for port (default: x-forwarded-port) */
	readonly portHeader?: string;
};
/**
* Create proxy headers wrapper
*/
declare const proxy: (options?: ProxyOptions) => Wrapper8<Context>;
/**
* Trust localhost/loopback proxies
*/
declare const trustLocalProxy: () => Wrapper8<Context>;
/**
* Trust first proxy (for single reverse proxy setups)
*/
declare const trustFirstProxy: () => Wrapper8<Context>;
import { ServerResponse as ServerResponse10 } from "@sylphx/gust-core";
type Range = {
	/** Start byte (inclusive) */
	start: number;
	/** End byte (inclusive) */
	end: number;
};
type ParsedRange = {
	/** Unit (usually 'bytes') */
	unit: string;
	/** Parsed ranges */
	ranges: Range[];
};
/**
* Parse Range header
* Format: bytes=0-499, 500-999, -500 (last 500), 500- (from 500 to end)
*/
declare const parseRange: (rangeHeader: string, fileSize: number) => ParsedRange | null;
/**
* Check if range is satisfiable
*/
declare const isRangeSatisfiable: (ranges: Range[], fileSize: number) => boolean;
/**
* Create Content-Range header value
*/
declare const contentRange: (start: number, end: number, total: number) => string;
type RangeFileOptions = {
	/** Root directory */
	root: string;
	/** Max age for Cache-Control (default: 1 day) */
	maxAge?: number;
	/** Allowed extensions (default: all) */
	extensions?: string[];
};
/**
* Serve file with range support (for video/audio streaming)
* Writes directly to socket for streaming
*/
declare const serveRangeFile: (ctx: Context, filePath: string, options?: Partial<RangeFileOptions>) => Promise<ServerResponse10 | null>;
type RangeOptions = {
	/** Root directory for files */
	root: string;
	/** URL prefix to strip (default: /) */
	prefix?: string;
	/** Max age for caching (default: 1 day) */
	maxAge?: number;
	/** Allowed extensions */
	extensions?: string[];
};
/**
* Create range-supporting file server middleware
* Use for video/audio streaming endpoints
*/
declare const rangeServer: (options: RangeOptions) => (ctx: Context) => Promise<ServerResponse10 | null>;
/**
* Check if request accepts range
*/
declare const acceptsRange: (ctx: Context) => boolean;
/**
* Get requested range info
*/
declare const getRange: (ctx: Context, fileSize: number) => Range | null;
import { ServerResponse as ServerResponse11 } from "@sylphx/gust-core";
/**
* Rate limit options with typed App context
*
* @example
* ```typescript
* // Universal (IP-based) - works with any App
* rateLimit({ max: 100, windowMs: 60000 })
*
* // Typed - requires App with userId
* rateLimit({
*   max: 100,
*   windowMs: 60000,
*   keyGenerator: (ctx: Context<{ userId: string }>) => ctx.app.userId
* })
* ```
*/
type RateLimitOptions<RequiredApp = unknown> = {
	/** Maximum requests per window */
	readonly max: number;
	/** Window size in milliseconds */
	readonly windowMs: number;
	/** Key generator (default: IP address) */
	readonly keyGenerator?: (ctx: Context<RequiredApp>) => string;
	/** Skip rate limiting for certain requests */
	readonly skip?: (ctx: Context<RequiredApp>) => boolean;
	/** Custom response when rate limited */
	readonly onLimitReached?: (ctx: Context<RequiredApp>) => ServerResponse11;
	/** Include rate limit headers in response */
	readonly headers?: boolean;
	/** Use sliding window (more accurate but uses more memory) */
	readonly slidingWindow?: boolean;
};
/**
* Create rate limiting middleware
*
* Limits requests based on IP address or custom key.
* Returns bounded middleware when typed options are provided.
*
* @example
* ```typescript
* // Universal - works with any App
* rateLimit({ max: 100, windowMs: 60000 })
*
* // Bounded - requires App with userId
* rateLimit({
*   max: 100,
*   windowMs: 60000,
*   keyGenerator: (ctx: Context<{ userId: string }>) => ctx.app.userId
* })
* ```
*/
declare const rateLimit: <RequiredApp = unknown>(options: RateLimitOptions<RequiredApp>) => Middleware<RequiredApp>;
/**
* Create a rate limiter with custom store (for distributed systems)
*/
type RateLimitStore2 = {
	increment(key: string, windowMs: number): Promise<{
		count: number;
		resetTime: number;
	}>;
	get(key: string): Promise<{
		count: number;
		resetTime: number;
	} | null>;
};
declare const rateLimitWithStore: <RequiredApp = unknown>(options: Omit<RateLimitOptions<RequiredApp>, "slidingWindow"> & {
	store: RateLimitStore2;
}) => Middleware<RequiredApp>;
type SecurityOptions = {
	/** Content Security Policy */
	readonly contentSecurityPolicy?: string | false;
	/** Cross-Origin-Embedder-Policy */
	readonly crossOriginEmbedderPolicy?: "require-corp" | "credentialless" | false;
	/** Cross-Origin-Opener-Policy */
	readonly crossOriginOpenerPolicy?: "same-origin" | "same-origin-allow-popups" | "unsafe-none" | false;
	/** Cross-Origin-Resource-Policy */
	readonly crossOriginResourcePolicy?: "same-origin" | "same-site" | "cross-origin" | false;
	/** Referrer-Policy */
	readonly referrerPolicy?: string | false;
	/** Strict-Transport-Security (HSTS) */
	readonly hsts?: {
		maxAge: number;
		includeSubDomains?: boolean;
		preload?: boolean;
	} | false;
	/** X-Content-Type-Options */
	readonly noSniff?: boolean;
	/** X-DNS-Prefetch-Control */
	readonly dnsPrefetchControl?: boolean;
	/** X-Download-Options */
	readonly ieNoOpen?: boolean;
	/** X-Frame-Options */
	readonly frameguard?: "DENY" | "SAMEORIGIN" | false;
	/** X-Permitted-Cross-Domain-Policies */
	readonly permittedCrossDomainPolicies?: "none" | "master-only" | "by-content-type" | "all" | false;
	/** X-XSS-Protection (legacy) */
	readonly xssFilter?: boolean;
};
/**
* Create security headers middleware
*
* Adds security headers to responses (Helmet-style).
* Works as both global middleware and route-level middleware.
*
* @example
* ```typescript
* serve({
*   middleware: security(),
*   routes: [...]
* })
* ```
*/
declare const security: (options?: SecurityOptions) => Middleware;
/**
* Pre-configured security for strict mode
*/
declare const strictSecurity: () => Middleware;
/**
* Pre-configured security for API servers
*/
declare const apiSecurity: () => Middleware;
import { Wrapper as Wrapper9 } from "@sylphx/gust-core";
type SessionData = Record<string, unknown>;
type Session<T extends SessionData = SessionData> = {
	/** Session ID */
	readonly id: string;
	/** Session data */
	data: T;
	/** Is this a new session? */
	readonly isNew: boolean;
	/** Has the session been modified? */
	readonly isModified: boolean;
	/** Regenerate session ID (for security after login) */
	regenerate: () => Promise<void>;
	/** Destroy session */
	destroy: () => Promise<void>;
	/** Touch session (update expiry) */
	touch: () => void;
	/** Save session */
	save: () => Promise<void>;
};
type SessionStore = {
	/** Get session data */
	get: (id: string) => Promise<SessionData | null>;
	/** Set session data */
	set: (id: string, data: SessionData, maxAge: number) => Promise<void>;
	/** Delete session */
	destroy: (id: string) => Promise<void>;
	/** Touch session (update expiry) */
	touch: (id: string, maxAge: number) => Promise<void>;
};
type SessionOptions = {
	/** Cookie name (default: sid) */
	readonly name?: string;
	/** Secret for signing session ID */
	readonly secret: string;
	/** Session store (default: MemoryStore) */
	readonly store?: SessionStore;
	/** Max age in milliseconds (default: 24 hours) */
	readonly maxAge?: number;
	/** Cookie options */
	readonly cookie?: Omit<CookieOptions, "maxAge">;
	/** Generate session ID */
	readonly genid?: () => string;
	/** Rolling sessions (reset maxAge on each request) */
	readonly rolling?: boolean;
	/** Save uninitialized sessions */
	readonly saveUninitialized?: boolean;
	/** Resave unchanged sessions */
	readonly resave?: boolean;
};
/**
* Generate secure session ID
* Uses native Rust/WASM for random generation.
*/
declare const generateSessionId: () => string;
declare class MemoryStore implements SessionStore {
	private sessions;
	private cleanupInterval;
	constructor();
	get(id: string): Promise<SessionData | null>;
	set(id: string, data: SessionData, maxAge: number): Promise<void>;
	destroy(id: string): Promise<void>;
	touch(id: string, maxAge: number): Promise<void>;
	/**
	* Get all sessions (for debugging)
	*/
	all(): Map<string, {
		data: SessionData;
		expires: number;
	}>;
	/**
	* Clear all sessions
	*/
	clear(): void;
	/**
	* Stop cleanup interval
	*/
	close(): void;
}
/**
* Get session from context
*/
declare const getSession: <T extends SessionData = SessionData>(ctx: Context) => Session<T> | undefined;
/**
* Session middleware
*/
declare const session: (options: SessionOptions) => Wrapper9<Context>;
/**
* Flash messages (one-time session messages)
*/
declare const flash: <T = string>(ctx: Context, key: string, value?: T) => T | T[] | undefined;
import { EventEmitter as EventEmitter3 } from "node:events";
import { Socket as Socket2 } from "node:net";
import { TLSSocket } from "node:tls";
import { ServerResponse as ServerResponse12 } from "@sylphx/gust-core";
/**
* SSE event data
*/
type SSEEvent = {
	/** Event data (string or object to be JSON serialized) */
	readonly data: unknown;
	/** Event ID for reconnection */
	readonly id?: string | number;
	/** Event type (e.g., 'message', 'update') */
	readonly event?: string;
	/** Reconnection interval in ms */
	readonly retry?: number;
};
/**
* SSE emit function for push-based handlers
*/
type SSEEmit = (event: SSEEvent) => void;
/**
* Cleanup function returned by handlers
*/
type SSECleanup = () => void;
/**
* Generator source: pull-based, yields events
*/
type SSEGenerator = () => AsyncGenerator<SSEEvent>;
/**
* Handler source: push-based, calls emit()
*/
type SSEHandler = (emit: SSEEmit) => Promise<void | SSECleanup>;
/**
* Source type for unified events() API
*/
type SSESource = SSEGenerator | SSEHandler;
/**
* Options for SSE response
*/
type SSEOptions = {
	/** HTTP status code (default: 200) */
	status?: number;
	/** Additional headers */
	headers?: Record<string, string>;
};
/**
* Format SSE event to wire format
*/
declare const formatSSEEvent: (event: SSEEvent) => string;
/**
* Simple event helper (just data, optional id)
*/
declare const sseEvent: (data: unknown, id?: string | number) => string;
/**
* Create an SSE streaming response
*
* Unified API that works with both generators (pull-based) and handlers (push-based).
* The library automatically detects which type based on the function signature.
*
* @example Generator (pull-based) - for known sequences
* ```ts
* app.get('/countdown', () =>
*   sse(async function* () {
*     for (let i = 10; i >= 0; i--) {
*       yield { data: { count: i } }
*       await sleep(1000)
*     }
*   })
* )
* ```
*
* @example Handler (push-based) - for external events
* ```ts
* app.get('/notifications', () =>
*   sse(async (emit) => {
*     emit({ data: 'connected' })
*
*     const handler = (data) => emit({ data })
*     pubsub.subscribe('updates', handler)
*
*     // Return cleanup function
*     return () => pubsub.unsubscribe('updates', handler)
*   })
* )
* ```
*/
declare const sse: (source: SSESource, options?: SSEOptions) => ServerResponse12;
/** @deprecated Use sse() instead */
type SSEMessage = {
	event?: string;
	data: string | object;
	id?: string;
	retry?: number;
};
/** @deprecated Use sse() instead */
declare const formatSSE: (msg: SSEMessage) => string;
/** @deprecated Use sse() instead */
declare const sseRaw: (source: AsyncIterable<Uint8Array> | (() => AsyncGenerator<Uint8Array>), init?: {
	status?: number;
	headers?: Record<string, string>;
}) => ServerResponse12;
/** @deprecated Use sse() instead */
declare const sseStream: (source: AsyncIterable<SSEEvent> | (() => AsyncGenerator<SSEEvent>), init?: {
	status?: number;
	headers?: Record<string, string>;
}) => ServerResponse12;
/** @deprecated Use sse() instead */
declare function textStream(source: AsyncIterable<string> | (() => AsyncGenerator<string>)): AsyncIterable<Uint8Array>;
/**
* Native SSE Writer interface
*/
interface NativeSseWriter {
	readonly id: number;
	send(data: string): Promise<boolean>;
	sendEvent(data: string, id?: string, event?: string): Promise<boolean>;
	close(): void;
}
/**
* Native response with SSE streaming support
*/
type NativeSSEResponse = {
	status: number;
	headers: Record<string, string>;
	body: string;
	sseWriterId: number;
};
/**
* GustServer interface for SSE methods
*/
interface GustServerSSE {
	createSseWriter(): number;
	sendSse(writerId: number, data: string): Promise<boolean>;
	sendSseEvent(writerId: number, data: string, id?: string, event?: string): Promise<boolean>;
	closeSse(writerId: number): void;
}
/**
* Create native SSE response (for GustServer direct integration)
*
* This uses channel-based streaming for true push-based SSE with backpressure.
* Use this when you need the lowest latency and are using GustServer directly.
*
* @example
* ```ts
* server.setFallback(async (ctx) => {
*   if (ctx.path === '/events') {
*     return nativeSSE(server, async (writer) => {
*       await writer.sendEvent(JSON.stringify({ type: 'connected' }))
*       // Stream events...
*     })
*   }
* })
* ```
*/
declare const nativeSSE: (server: GustServerSSE, handler: (writer: NativeSseWriter) => Promise<void>, options?: SSEOptions) => NativeSSEResponse;
/** Check if native SSE is available */
declare const isNativeSSEAvailable: () => boolean;
/**
* SSE client connection (socket-based)
*/
declare class SSEClient extends EventEmitter3 {
	private socket;
	private closed;
	private lastEventId;
	constructor(socket: Socket2 | TLSSocket, lastEventId?: string);
	private setupSocket;
	send(msg: SSEMessage): boolean;
	comment(text: string): boolean;
	ping(): boolean;
	close(): void;
	get isOpen(): boolean;
	get eventId(): string | null;
}
/**
* Create SSE response headers
*/
declare const sseHeaders: () => string;
/**
* Upgrade connection to SSE
*/
declare const createSSE: (socket: Socket2 | TLSSocket, headers: Record<string, string>) => SSEClient;
import { Handler as Handler4 } from "@sylphx/gust-core";
type StaticOptions = {
	readonly root: string;
	readonly index?: string | string[];
	readonly maxAge?: number;
	readonly immutable?: boolean;
	readonly dotfiles?: "allow" | "deny" | "ignore";
	readonly etag?: boolean;
	readonly lastModified?: boolean;
};
/**
* Create static file serving handler
*/
declare const serveStatic: (options: StaticOptions) => Handler4<Context>;
import { EventEmitter as EventEmitter4 } from "node:events";
import { Socket as Socket3 } from "node:net";
import { TLSSocket as TLSSocket2 } from "node:tls";
import { ServerResponse as ServerResponse13 } from "@sylphx/gust-core";
/**
* Streaming writer for chunked transfer encoding
*/
declare class StreamWriter extends EventEmitter4 {
	private socket;
	private closed;
	private headersSent;
	constructor(socket: Socket3 | TLSSocket2);
	private setupSocket;
	/**
	* Send response headers
	*/
	writeHead(status: number, headers?: Record<string, string>): boolean;
	/**
	* Write a chunk of data
	*/
	write(data: string | Buffer): boolean;
	/**
	* Write JSON data
	*/
	writeJson(data: unknown): boolean;
	/**
	* End the stream
	*/
	end(data?: string | Buffer): void;
	/**
	* Check if stream is open
	*/
	get isOpen(): boolean;
	/**
	* Check if headers have been sent
	*/
	get headersWritten(): boolean;
}
/**
* Create a streaming response
*/
declare const createStream: (socket: Socket3 | TLSSocket2, status?: number, headers?: Record<string, string>) => StreamWriter;
/**
* Create a JSON stream (newline-delimited JSON)
*/
declare const createJsonStream: (socket: Socket3 | TLSSocket2) => StreamWriter;
/**
* Stream helper for async iterables
*/
declare const streamFrom: <T>(writer: StreamWriter, source: AsyncIterable<T>, transform?: (item: T) => string | Buffer) => Promise<void>;
/**
* Create async generator stream
*/
declare const streamGenerator: <T>(writer: StreamWriter, generator: () => AsyncGenerator<T, void, unknown>, transform?: (item: T) => string | Buffer) => Promise<void>;
/**
* Pipe readable stream to writer
*/
declare const pipeStream: (writer: StreamWriter, readable: NodeJS.ReadableStream) => Promise<void>;
/**
* Create a generic streaming response
*
* @example
* ```ts
* const handler = async (ctx) => {
*   return stream(async function* () {
*     yield new TextEncoder().encode('chunk 1')
*     yield new TextEncoder().encode('chunk 2')
*   })
* }
* ```
*/
declare const stream: (source: AsyncIterable<Uint8Array> | (() => AsyncGenerator<Uint8Array>), init?: {
	status?: number;
	headers?: Record<string, string>;
}) => ServerResponse13;
/**
* Create a streaming response from text generator
*
* @example
* ```ts
* const handler = async (ctx) => {
*   return streamText(async function* () {
*     yield 'Hello '
*     yield 'World!'
*   })
* }
* ```
*/
declare const streamText: (source: AsyncIterable<string> | (() => AsyncGenerator<string>), init?: {
	status?: number;
	headers?: Record<string, string>;
}) => ServerResponse13;
/**
* Create a newline-delimited JSON (NDJSON) streaming response
*
* @example
* ```ts
* const handler = async (ctx) => {
*   return ndjsonStream(async function* () {
*     yield { id: 1, name: 'Alice' }
*     yield { id: 2, name: 'Bob' }
*   })
* }
* ```
*/
declare const ndjsonStream: <T>(source: AsyncIterable<T> | (() => AsyncGenerator<T>), init?: {
	status?: number;
	headers?: Record<string, string>;
}) => ServerResponse13;
/**
* Convert Node.js readable stream to AsyncIterable
*/
declare function nodeStreamToAsyncIterable(readable: NodeJS.ReadableStream): AsyncIterable<Uint8Array>;
/**
* Stream a file using AsyncIterable
*
* @example
* ```ts
* import { createReadStream } from 'node:fs'
*
* const handler = async (ctx) => {
*   return streamFile(createReadStream('/path/to/file'))
* }
* ```
*/
declare const streamFile: (readable: NodeJS.ReadableStream, init?: {
	status?: number;
	headers?: Record<string, string>;
}) => ServerResponse13;
import { Wrapper as Wrapper10 } from "@sylphx/gust-core";
type TracingOptions = {
	/** Header name for request ID (default: x-request-id) */
	readonly header?: string;
	/** Generate custom request ID */
	readonly generator?: () => string;
	/** Trust incoming request ID header */
	readonly trustIncoming?: boolean;
	/** Add request ID to response */
	readonly setResponse?: boolean;
};
/**
* Generate UUID v4
* Uses native random bytes with UUID v4 formatting.
*/
declare const generateUUID: () => string;
/**
* Generate short ID (8 hex chars)
* Uses native span ID generation.
*/
declare const generateShortId: () => string;
/**
* Generate nanoid-style ID
* Uses native random with base62 encoding.
*/
declare const generateNanoId: (size?: number) => string;
/**
* Get request ID from context
*/
declare const getRequestId: (ctx: Context) => string | undefined;
/**
* Create request ID/tracing wrapper
*/
declare const tracing: (options?: TracingOptions) => Wrapper10<Context>;
/**
* Logging wrapper with request ID
*/
type LogFn = (msg: string, data?: Record<string, unknown>) => void;
type LoggingOptions = {
	/** Log function */
	readonly log?: LogFn;
	/** Include request timing */
	readonly timing?: boolean;
	/** Skip logging for certain requests */
	readonly skip?: (ctx: Context) => boolean;
};
declare const logging: (options?: LoggingOptions) => Wrapper10<Context>;
import { ServerResponse as ServerResponse14, Wrapper as Wrapper11 } from "@sylphx/gust-core";
type ValidationError = {
	path: string;
	message: string;
	value?: unknown;
};
type ValidationResult<T> = {
	valid: true;
	data: T;
} | {
	valid: false;
	errors: ValidationError[];
};
type Validator<T> = {
	validate: (data: unknown) => ValidationResult<T>;
};
type Schema = {
	type: "string" | "number" | "boolean" | "object" | "array" | "any";
	required?: boolean;
	nullable?: boolean;
	minLength?: number;
	maxLength?: number;
	pattern?: RegExp | string;
	format?: "email" | "url" | "uuid" | "date" | "datetime";
	enum?: string[];
	min?: number;
	max?: number;
	integer?: boolean;
	properties?: Record<string, Schema>;
	additionalProperties?: boolean;
	items?: Schema;
	minItems?: number;
	maxItems?: number;
	uniqueItems?: boolean;
	custom?: (value: unknown) => boolean | string;
};
/**
* Validate value against schema
*/
declare const validateSchema: (value: unknown, schema: Schema, path?: string) => ValidationError[];
/**
* Create validator from schema
*/
declare const createValidator: <T>(schema: Schema) => Validator<T>;
/**
* String validator
*/
declare const string: (options?: Partial<Schema>) => Schema;
/**
* Number validator
*/
declare const number: (options?: Partial<Schema>) => Schema;
/**
* Boolean validator
*/
declare const boolean: (options?: Partial<Schema>) => Schema;
/**
* Object validator
*/
declare const object: (properties: Record<string, Schema>, options?: Partial<Schema>) => Schema;
/**
* Array validator
*/
declare const array: (items: Schema, options?: Partial<Schema>) => Schema;
/**
* Email validator
*/
declare const email: (options?: Partial<Schema>) => Schema;
/**
* URL validator
*/
declare const url: (options?: Partial<Schema>) => Schema;
/**
* UUID validator
*/
declare const uuid: (options?: Partial<Schema>) => Schema;
/**
* Optional modifier
*/
declare const optional: (schema: Schema) => Schema;
/**
* Nullable modifier
*/
declare const nullable: (schema: Schema) => Schema;
type ValidateOptions = {
	/** Schema for body */
	readonly body?: Schema;
	/** Schema for query parameters */
	readonly query?: Schema;
	/** Schema for path parameters (from router) */
	readonly params?: Schema;
	/** Custom error response */
	readonly onError?: (errors: ValidationError[]) => ServerResponse14;
};
/**
* Get validated data from context
*/
declare const getValidated: <T = unknown>(ctx: Context) => T | undefined;
/**
* Get validated query from context
*/
declare const getValidatedQuery: <T = Record<string, string>>(ctx: Context) => T | undefined;
/**
* Validation middleware
*/
declare const validate: (options: ValidateOptions) => Wrapper11<Context>;
/**
* Shorthand for body-only validation
*/
declare const validateBody: (schema: Schema) => Wrapper11<Context>;
/**
* Shorthand for query-only validation
*/
declare const validateQuery: (schema: Schema) => Wrapper11<Context>;
/**
* Initialize the WASM module (async version)
* For explicit initialization before use.
*/
declare const initWasm: () => Promise<boolean>;
/**
* Check if WASM is available
*/
declare const isWasmAvailable: () => boolean;
import { EventEmitter as EventEmitter5 } from "node:events";
import { Socket as Socket4 } from "node:net";
import { TLSSocket as TLSSocket3 } from "node:tls";
type WebSocketMessage = {
	readonly type: "text" | "binary";
	readonly data: string | Buffer;
};
type WebSocketEvents = {
	open: () => void;
	message: (msg: WebSocketMessage) => void;
	close: (code: number, reason: string) => void;
	error: (error: Error) => void;
	ping: (data: Buffer) => void;
	pong: (data: Buffer) => void;
};
declare class WebSocket extends EventEmitter5 {
	private socket;
	private closed;
	private fragments;
	private fragmentOpcode;
	constructor(socket: Socket4 | TLSSocket3);
	private setupSocket;
	private processFrames;
	private handleFrame;
	private sendFrame;
	/**
	* Send text message
	*/
	send(data: string | Buffer): void;
	/**
	* Send ping
	*/
	ping(data?: Buffer): void;
	/**
	* Close connection
	*/
	close(code?: number, reason?: string): void;
	/**
	* Check if connection is open
	*/
	get isOpen(): boolean;
}
/**
* Generate WebSocket accept key
* Uses native Rust/WASM implementation.
*/
declare const generateAcceptKey: (key: string) => string;
/**
* Check if request is a WebSocket upgrade request
*/
declare const isWebSocketUpgrade: (headers: Record<string, string>) => boolean;
/**
* Create WebSocket handshake response
*/
declare const createHandshakeResponse: (key: string) => string;
/**
* Upgrade HTTP connection to WebSocket
*/
declare const upgradeToWebSocket: (socket: Socket4 | TLSSocket3, headers: Record<string, string>) => WebSocket | null;
type WebSocketHandler = (ws: WebSocket, headers: Record<string, string>) => void;
/**
* Create a WebSocket route handler
*/
declare const websocket: (handler: WebSocketHandler) => {
	isWebSocket: true;
	handler: WebSocketHandler;
};
/**
* WebSocket close info
*/
type WebSocketCloseInfo = {
	readonly code: number;
	readonly reason: string;
};
/**
* Pure WebSocket session with AsyncIterable messages
* - messages: AsyncIterable for incoming messages
* - send: Function to send messages
* - close: Function to close connection
* - closed: Promise that resolves when connection closes
*/
type WebSocketSession = {
	readonly messages: AsyncIterable<WebSocketMessage>;
	readonly send: (data: string | Buffer) => void;
	readonly ping: (data?: Buffer) => void;
	readonly close: (code?: number, reason?: string) => void;
	readonly closed: Promise<WebSocketCloseInfo>;
	readonly isOpen: boolean;
};
/**
* Session-based WebSocket handler
*/
type WebSocketSessionHandler = (session: WebSocketSession, headers: Record<string, string>) => Promise<void>;
/**
* Create a WebSocket session from raw WebSocket
*/
declare const createWebSocketSession: (ws: WebSocket) => WebSocketSession;
/**
* Create a session-based WebSocket route handler
*
* @example
* ```ts
* const echo = websocketSession(async (session) => {
*   for await (const msg of session.messages) {
*     session.send(`Echo: ${msg.data}`)
*   }
*   // Loop exits when connection closes
*   const { code, reason } = await session.closed
*   console.log(`Closed: ${code} ${reason}`)
* })
* ```
*/
declare const websocketSession: (handler: WebSocketSessionHandler) => {
	isWebSocket: true;
	handler: WebSocketHandler;
};
export { withParams, withCircuitBreaker, withApp, websocketSession, websocket, verifyJwt, verifyHmac, verifyCsrfToken, varyingCacheKey, validateSchema, validateQuery, validateBody, validate, uuid, url, uploadLimit, upgradeToWebSocket, unauthorized, trustLocalProxy, trustFirstProxy, tracing, textStream, text, stringifyQuery, string, strictSecurity, streamText, streamGenerator, streamFrom, streamFile, stream, stickySession, startup, startChildSpan, sseStream, sseRaw, sseHeaders, sseEvent, sse, simpleCors, simpleBasicAuth, simpleApiKey, setCookies, setCookie, session, serverError, serveStatic, serveRangeFile, serveHttp2, serve, serializeCookie, security, runHealthChecks, runCluster, routes, response, redirect, readiness, rateLimitWithStore, rateLimit, rangeServer, put, pushResources, pushResource, proxy, prometheusMetrics, preloadHint, preload, post, pipeStream, pipe, patch, parseTracestate, parseTraceparent, parseSize, parseRange, parseQuery, parseMultipart, parseJsonBody, parseHeaders, parseFormBody, parseCookies, parseBearerToken, parseBasicAuth, otel, options, optionalJwt, optional, object, number, nullable, notFound, nodeStreamToAsyncIterable, noCache, ndjsonStream, nativeSSE, metrics, memoryCheck, logging, liveness, largeUploadLimit, jwtAuth, jsonLimit, json, isWorker, isWebSocketUpgrade, isWasmReady, isStreamingBody, isWasmAvailable as isServeWasmAvailable, isRangeSatisfiable, isPrimary, isNativeSSEAvailable, isMultipartContent, isJwtExpired, isJsonContent, isHttp2, isFormContent, isCluster, invalidateCache, initWasm2 as initWasm, initWasm as initServeWasm, httpCheck, html, hmacAuth, healthCheck, health, head, gzip, getWasm, getValidatedQuery, getValidated, getSpan, getSession, getRequestId, getRange, getProxyInfo, getMetrics, getJwtPayload, getCsrfToken, getCookies, getCookie, getContentType, getClusterInfo, getClientIp, getCircuitBreaker, getAlpnProtocol, get, generateUUID, generateTraceId, generateSpanId, generateShortId, generateSessionId, generateNanoId, generateHmac, generateCsrfToken, generateAcceptKey, formatTracestate, formatTraceparent, formatSize, formatSSEEvent, formatSSE, forbidden, flash, extractBoundary, eventLoopCheck, etag, email, deleteCookie, del, defaultCacheKey, decodeJwt, customCheck, csrfMeta, csrfField, csrfDoubleSubmit, csrf, createWebSocketSession, createValidator, createTracer, createStream, createSSE, createRouter, createRawContext, createOtlpExporter, createJwt, createJsonStream, createHandshakeResponse, createContext, createBasicAuth, cors, contentRange, consoleExporter, compress, compose, clusterServe, circuitBreaker, cache, bulkhead, brotli, boolean, bodyLimit, bearerAuth, basicAuth, badRequest, array, apiSecurity, apiKeyAuth, all, acceptsRange, Wrapper12 as Wrapper, WebSocketSessionHandler, WebSocketSession, WebSocketMessage, WebSocketHandler, WebSocketEvents, WebSocketCloseInfo, WebSocket, VerifyOptions, Validator, ValidationResult, ValidationError, ValidateOptions, TypedRouteBuilders, TracingOptions, Tracer, TlsOptions, StreamWriter, StaticOptions, SpanExporter, SpanEvent, SpanContext, SpanAttributes, Span, SessionStore, SessionOptions, SessionData, Session, ServerResponse15 as ServerResponse, Server, ServeOptions, SecurityOptions, Schema, SSESource, SSEOptions, SSEMessage, SSEHandler, SSEGenerator, SSEEvent, SSEEmit, SSEClient, SSECleanup, Routes, RouteHandlerFn, RouteHandler, Route, ResponseBody, RawContext, RateLimitStore2, RateLimitOptions, RangeOptions, RangeFileOptions, Range, PushOptions, ProxyOptions, ProxyInfo, ParsedRange, ParsedBody, OtelOptions, NativeSseWriter, NativeSSEResponse, MultipartPart, Middleware, MetricsCollector, Metrics, MemoryStore, MemoryCache, LoggingOptions, LogFn, LRUCache, JwtResult, JwtPayload, JwtOptions, JwtHeader, JwtAuthOptions, Http2ServerInstance, Http2Options, Http2Context, HmacOptions, Histogram, HealthStatus, HealthResult, HealthOptions, HealthCheck, HandlerArgs, Handler5 as Handler, Gauge, CsrfOptions, Counter, CorsOptions, CookieOptions, Cookie, ContextProvider, Context, CompressionOptions, ClusterServeOptions, ClusterOptions, ClusterManager, ClusterInfo, CircuitStats, CircuitState, CircuitBreakerOptions, CircuitBreaker, CacheStore, CacheOptions, CacheEntry, BulkheadOptions, BodyLimitOptions, BearerAuthOptions, BasicAuthOptions, BaseContext, ApiKeyOptions };
