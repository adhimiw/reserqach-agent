import { createRequire } from "node:module";
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// src/wasm/gust_wasm.js
var exports_gust_wasm = {};
__export(exports_gust_wasm, {
  validate_string: () => validate_string,
  validate_number: () => validate_number,
  seed_rng: () => seed_rng,
  parse_websocket_frame: () => parse_websocket_frame,
  parse_traceparent: () => parse_traceparent,
  parse_http: () => parse_http,
  method_to_string: () => method_to_string,
  initSync: () => initSync,
  generate_websocket_mask: () => generate_websocket_mask,
  generate_websocket_accept: () => generate_websocket_accept,
  generate_trace_id: () => generate_trace_id,
  generate_span_id: () => generate_span_id,
  format_traceparent: () => format_traceparent,
  encode_websocket_text: () => encode_websocket_text,
  encode_websocket_pong: () => encode_websocket_pong,
  encode_websocket_ping: () => encode_websocket_ping,
  encode_websocket_close: () => encode_websocket_close,
  encode_websocket_binary: () => encode_websocket_binary,
  default: () => gust_wasm_default,
  WsFrameResult: () => WsFrameResult,
  WasmValidationResult: () => WasmValidationResult,
  WasmSpanContext: () => WasmSpanContext,
  WasmRouter: () => WasmRouter,
  RouteMatch: () => RouteMatch,
  ParseResult: () => ParseResult
});
function getArrayJsValueFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  const mem = getDataViewMemory0();
  const result = [];
  for (let i = ptr;i < ptr + 4 * len; i += 4) {
    result.push(wasm.__wbindgen_externrefs.get(mem.getUint32(i, true)));
  }
  wasm.__externref_drop_slice(ptr, len);
  return result;
}
function getArrayU32FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return decodeText(ptr, len);
}
function getUint32ArrayMemory0() {
  if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {
    cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);
  }
  return cachedUint32ArrayMemory0;
}
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
function isLikeNone(x) {
  return x === undefined || x === null;
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8ArrayMemory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === undefined) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (;offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = cachedTextEncoder.encodeInto(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function decodeText(ptr, len) {
  numBytesDecoded += len;
  if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {
    cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    numBytesDecoded = len;
  }
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}

class ParseResult {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ParseResult.prototype);
    obj.__wbg_ptr = ptr;
    ParseResultFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ParseResultFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_parseresult_free(ptr, 0);
  }
  get header_offsets() {
    const ret = wasm.parseresult_header_offsets(this.__wbg_ptr);
    var v1 = getArrayU32FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v1;
  }
  get state() {
    const ret = wasm.__wbg_get_parseresult_state(this.__wbg_ptr);
    return ret;
  }
  set state(arg0) {
    wasm.__wbg_set_parseresult_state(this.__wbg_ptr, arg0);
  }
  get method() {
    const ret = wasm.__wbg_get_parseresult_method(this.__wbg_ptr);
    return ret;
  }
  set method(arg0) {
    wasm.__wbg_set_parseresult_method(this.__wbg_ptr, arg0);
  }
  get path_start() {
    const ret = wasm.__wbg_get_parseresult_path_start(this.__wbg_ptr);
    return ret >>> 0;
  }
  set path_start(arg0) {
    wasm.__wbg_set_parseresult_path_start(this.__wbg_ptr, arg0);
  }
  get path_end() {
    const ret = wasm.__wbg_get_parseresult_path_end(this.__wbg_ptr);
    return ret >>> 0;
  }
  set path_end(arg0) {
    wasm.__wbg_set_parseresult_path_end(this.__wbg_ptr, arg0);
  }
  get query_start() {
    const ret = wasm.__wbg_get_parseresult_query_start(this.__wbg_ptr);
    return ret >>> 0;
  }
  set query_start(arg0) {
    wasm.__wbg_set_parseresult_query_start(this.__wbg_ptr, arg0);
  }
  get query_end() {
    const ret = wasm.__wbg_get_parseresult_query_end(this.__wbg_ptr);
    return ret >>> 0;
  }
  set query_end(arg0) {
    wasm.__wbg_set_parseresult_query_end(this.__wbg_ptr, arg0);
  }
  get headers_count() {
    const ret = wasm.__wbg_get_parseresult_headers_count(this.__wbg_ptr);
    return ret >>> 0;
  }
  set headers_count(arg0) {
    wasm.__wbg_set_parseresult_headers_count(this.__wbg_ptr, arg0);
  }
  get body_start() {
    const ret = wasm.__wbg_get_parseresult_body_start(this.__wbg_ptr);
    return ret >>> 0;
  }
  set body_start(arg0) {
    wasm.__wbg_set_parseresult_body_start(this.__wbg_ptr, arg0);
  }
}

class RouteMatch {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(RouteMatch.prototype);
    obj.__wbg_ptr = ptr;
    RouteMatchFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RouteMatchFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_routematch_free(ptr, 0);
  }
  get params() {
    const ret = wasm.routematch_params(this.__wbg_ptr);
    var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v1;
  }
  get found() {
    const ret = wasm.__wbg_get_routematch_found(this.__wbg_ptr);
    return ret !== 0;
  }
  set found(arg0) {
    wasm.__wbg_set_routematch_found(this.__wbg_ptr, arg0);
  }
  get handler_id() {
    const ret = wasm.__wbg_get_routematch_handler_id(this.__wbg_ptr);
    return ret >>> 0;
  }
  set handler_id(arg0) {
    wasm.__wbg_set_routematch_handler_id(this.__wbg_ptr, arg0);
  }
}

class WasmRouter {
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    WasmRouterFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_wasmrouter_free(ptr, 0);
  }
  constructor() {
    const ret = wasm.wasmrouter_new();
    this.__wbg_ptr = ret >>> 0;
    WasmRouterFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  find(method, path) {
    const ptr0 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm.wasmrouter_find(this.__wbg_ptr, ptr0, len0, ptr1, len1);
    return RouteMatch.__wrap(ret);
  }
  insert(method, path, handler_id) {
    const ptr0 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    wasm.wasmrouter_insert(this.__wbg_ptr, ptr0, len0, ptr1, len1, handler_id);
  }
}

class WasmSpanContext {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(WasmSpanContext.prototype);
    obj.__wbg_ptr = ptr;
    WasmSpanContextFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    WasmSpanContextFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_wasmspancontext_free(ptr, 0);
  }
  get span_id() {
    let deferred1_0;
    let deferred1_1;
    try {
      const ret = wasm.wasmspancontext_span_id(this.__wbg_ptr);
      deferred1_0 = ret[0];
      deferred1_1 = ret[1];
      return getStringFromWasm0(ret[0], ret[1]);
    } finally {
      wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  get trace_id() {
    let deferred1_0;
    let deferred1_1;
    try {
      const ret = wasm.wasmspancontext_trace_id(this.__wbg_ptr);
      deferred1_0 = ret[0];
      deferred1_1 = ret[1];
      return getStringFromWasm0(ret[0], ret[1]);
    } finally {
      wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  get trace_flags() {
    const ret = wasm.__wbg_get_wasmspancontext_trace_flags(this.__wbg_ptr);
    return ret;
  }
  set trace_flags(arg0) {
    wasm.__wbg_set_wasmspancontext_trace_flags(this.__wbg_ptr, arg0);
  }
}

class WasmValidationResult {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(WasmValidationResult.prototype);
    obj.__wbg_ptr = ptr;
    WasmValidationResultFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    WasmValidationResultFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_wasmvalidationresult_free(ptr, 0);
  }
  get valid() {
    const ret = wasm.__wbg_get_wasmvalidationresult_valid(this.__wbg_ptr);
    return ret !== 0;
  }
  set valid(arg0) {
    wasm.__wbg_set_wasmvalidationresult_valid(this.__wbg_ptr, arg0);
  }
  get errors() {
    const ret = wasm.wasmvalidationresult_errors(this.__wbg_ptr);
    var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v1;
  }
}

class WsFrameResult {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(WsFrameResult.prototype);
    obj.__wbg_ptr = ptr;
    WsFrameResultFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    WsFrameResultFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_wsframeresult_free(ptr, 0);
  }
  get close_reason() {
    let deferred1_0;
    let deferred1_1;
    try {
      const ret = wasm.wsframeresult_close_reason(this.__wbg_ptr);
      deferred1_0 = ret[0];
      deferred1_1 = ret[1];
      return getStringFromWasm0(ret[0], ret[1]);
    } finally {
      wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  get payload() {
    const ret = wasm.wsframeresult_payload(this.__wbg_ptr);
    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    return v1;
  }
  get complete() {
    const ret = wasm.__wbg_get_wsframeresult_complete(this.__wbg_ptr);
    return ret !== 0;
  }
  set complete(arg0) {
    wasm.__wbg_set_wsframeresult_complete(this.__wbg_ptr, arg0);
  }
  get incomplete() {
    const ret = wasm.__wbg_get_wsframeresult_incomplete(this.__wbg_ptr);
    return ret !== 0;
  }
  set incomplete(arg0) {
    wasm.__wbg_set_wsframeresult_incomplete(this.__wbg_ptr, arg0);
  }
  get error() {
    const ret = wasm.__wbg_get_wsframeresult_error(this.__wbg_ptr);
    return ret !== 0;
  }
  set error(arg0) {
    wasm.__wbg_set_wsframeresult_error(this.__wbg_ptr, arg0);
  }
  get fin() {
    const ret = wasm.__wbg_get_wsframeresult_fin(this.__wbg_ptr);
    return ret !== 0;
  }
  set fin(arg0) {
    wasm.__wbg_set_wsframeresult_fin(this.__wbg_ptr, arg0);
  }
  get opcode() {
    const ret = wasm.__wbg_get_wsframeresult_opcode(this.__wbg_ptr);
    return ret;
  }
  set opcode(arg0) {
    wasm.__wbg_set_wsframeresult_opcode(this.__wbg_ptr, arg0);
  }
  get bytes_consumed() {
    const ret = wasm.__wbg_get_wsframeresult_bytes_consumed(this.__wbg_ptr);
    return ret >>> 0;
  }
  set bytes_consumed(arg0) {
    wasm.__wbg_set_wsframeresult_bytes_consumed(this.__wbg_ptr, arg0);
  }
  get close_code() {
    const ret = wasm.__wbg_get_wsframeresult_close_code(this.__wbg_ptr);
    return ret;
  }
  set close_code(arg0) {
    wasm.__wbg_set_wsframeresult_close_code(this.__wbg_ptr, arg0);
  }
}
function encode_websocket_binary(data, fin) {
  const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.encode_websocket_binary(ptr0, len0, fin);
  var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v2;
}
function encode_websocket_close(code, reason) {
  var ptr0 = isLikeNone(reason) ? 0 : passStringToWasm0(reason, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  var len0 = WASM_VECTOR_LEN;
  const ret = wasm.encode_websocket_close(isLikeNone(code) ? 16777215 : code, ptr0, len0);
  var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v2;
}
function encode_websocket_ping(data) {
  const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.encode_websocket_ping(ptr0, len0);
  var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v2;
}
function encode_websocket_pong(data) {
  const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.encode_websocket_pong(ptr0, len0);
  var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v2;
}
function encode_websocket_text(text, fin) {
  const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.encode_websocket_text(ptr0, len0, fin);
  var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v2;
}
function format_traceparent(trace_id, span_id, trace_flags) {
  let deferred3_0;
  let deferred3_1;
  try {
    const ptr0 = passStringToWasm0(trace_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(span_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm.format_traceparent(ptr0, len0, ptr1, len1, trace_flags);
    deferred3_0 = ret[0];
    deferred3_1 = ret[1];
    return getStringFromWasm0(ret[0], ret[1]);
  } finally {
    wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
  }
}
function generate_span_id() {
  let deferred1_0;
  let deferred1_1;
  try {
    const ret = wasm.generate_span_id();
    deferred1_0 = ret[0];
    deferred1_1 = ret[1];
    return getStringFromWasm0(ret[0], ret[1]);
  } finally {
    wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
  }
}
function generate_trace_id() {
  let deferred1_0;
  let deferred1_1;
  try {
    const ret = wasm.generate_trace_id();
    deferred1_0 = ret[0];
    deferred1_1 = ret[1];
    return getStringFromWasm0(ret[0], ret[1]);
  } finally {
    wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
  }
}
function generate_websocket_accept(key) {
  let deferred2_0;
  let deferred2_1;
  try {
    const ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.generate_websocket_accept(ptr0, len0);
    deferred2_0 = ret[0];
    deferred2_1 = ret[1];
    return getStringFromWasm0(ret[0], ret[1]);
  } finally {
    wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
  }
}
function generate_websocket_mask() {
  const ret = wasm.generate_websocket_mask();
  var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v1;
}
function method_to_string(code) {
  let deferred1_0;
  let deferred1_1;
  try {
    const ret = wasm.method_to_string(code);
    deferred1_0 = ret[0];
    deferred1_1 = ret[1];
    return getStringFromWasm0(ret[0], ret[1]);
  } finally {
    wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
  }
}
function parse_http(buf) {
  const ptr0 = passArray8ToWasm0(buf, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.parse_http(ptr0, len0);
  return ParseResult.__wrap(ret);
}
function parse_traceparent(header) {
  const ptr0 = passStringToWasm0(header, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.parse_traceparent(ptr0, len0);
  return ret === 0 ? undefined : WasmSpanContext.__wrap(ret);
}
function parse_websocket_frame(data) {
  const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.parse_websocket_frame(ptr0, len0);
  return WsFrameResult.__wrap(ret);
}
function seed_rng(seed) {
  wasm.seed_rng(seed);
}
function validate_number(value, min, max, is_integer) {
  const ret = wasm.validate_number(value, !isLikeNone(min), isLikeNone(min) ? 0 : min, !isLikeNone(max), isLikeNone(max) ? 0 : max, is_integer);
  return WasmValidationResult.__wrap(ret);
}
function validate_string(value, min_length, max_length, format) {
  const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  var ptr1 = isLikeNone(format) ? 0 : passStringToWasm0(format, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  var len1 = WASM_VECTOR_LEN;
  const ret = wasm.validate_string(ptr0, len0, isLikeNone(min_length) ? 4294967297 : min_length >>> 0, isLikeNone(max_length) ? 4294967297 : max_length >>> 0, ptr1, len1);
  return WasmValidationResult.__wrap(ret);
}
async function __wbg_load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e) {
        const validResponse = module.ok && EXPECTED_RESPONSE_TYPES.has(module.type);
        if (validResponse && module.headers.get("Content-Type") !== "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg___wbindgen_throw_dd24417ed36fc46e = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbindgen_cast_2241b6af4c4b2941 = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return ret;
  };
  imports.wbg.__wbindgen_init_externref_table = function() {
    const table = wasm.__wbindgen_externrefs;
    const offset = table.grow(4);
    table.set(0, undefined);
    table.set(offset + 0, undefined);
    table.set(offset + 1, null);
    table.set(offset + 2, true);
    table.set(offset + 3, false);
  };
  return imports;
}
function __wbg_finalize_init(instance, module) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedDataViewMemory0 = null;
  cachedUint32ArrayMemory0 = null;
  cachedUint8ArrayMemory0 = null;
  wasm.__wbindgen_start();
  return wasm;
}
function initSync(module) {
  if (wasm !== undefined)
    return wasm;
  if (typeof module !== "undefined") {
    if (Object.getPrototypeOf(module) === Object.prototype) {
      ({ module } = module);
    } else {
      console.warn("using deprecated parameters for `initSync()`; pass a single object instead");
    }
  }
  const imports = __wbg_get_imports();
  if (!(module instanceof WebAssembly.Module)) {
    module = new WebAssembly.Module(module);
  }
  const instance = new WebAssembly.Instance(module, imports);
  return __wbg_finalize_init(instance, module);
}
async function __wbg_init(module_or_path) {
  if (wasm !== undefined)
    return wasm;
  if (typeof module_or_path !== "undefined") {
    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
      ({ module_or_path } = module_or_path);
    } else {
      console.warn("using deprecated parameters for the initialization function; pass a single object instead");
    }
  }
  if (typeof module_or_path === "undefined") {
    module_or_path = new URL("gust_wasm_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports();
  if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
    module_or_path = fetch(module_or_path);
  }
  const { instance, module } = await __wbg_load(await module_or_path, imports);
  return __wbg_finalize_init(instance, module);
}
var wasm, cachedDataViewMemory0 = null, cachedUint32ArrayMemory0 = null, cachedUint8ArrayMemory0 = null, cachedTextDecoder, MAX_SAFARI_DECODE_BYTES = 2146435072, numBytesDecoded = 0, cachedTextEncoder, WASM_VECTOR_LEN = 0, ParseResultFinalization, RouteMatchFinalization, WasmRouterFinalization, WasmSpanContextFinalization, WasmValidationResultFinalization, WsFrameResultFinalization, EXPECTED_RESPONSE_TYPES, gust_wasm_default;
var init_gust_wasm = __esm(() => {
  cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
  cachedTextDecoder.decode();
  cachedTextEncoder = new TextEncoder;
  if (!("encodeInto" in cachedTextEncoder)) {
    cachedTextEncoder.encodeInto = function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
  }
  ParseResultFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_parseresult_free(ptr >>> 0, 1));
  RouteMatchFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_routematch_free(ptr >>> 0, 1));
  WasmRouterFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_wasmrouter_free(ptr >>> 0, 1));
  WasmSpanContextFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_wasmspancontext_free(ptr >>> 0, 1));
  WasmValidationResultFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_wasmvalidationresult_free(ptr >>> 0, 1));
  WsFrameResultFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_wsframeresult_free(ptr >>> 0, 1));
  if (Symbol.dispose)
    ParseResult.prototype[Symbol.dispose] = ParseResult.prototype.free;
  if (Symbol.dispose)
    RouteMatch.prototype[Symbol.dispose] = RouteMatch.prototype.free;
  if (Symbol.dispose)
    WasmRouter.prototype[Symbol.dispose] = WasmRouter.prototype.free;
  if (Symbol.dispose)
    WasmSpanContext.prototype[Symbol.dispose] = WasmSpanContext.prototype.free;
  if (Symbol.dispose)
    WasmValidationResult.prototype[Symbol.dispose] = WasmValidationResult.prototype.free;
  if (Symbol.dispose)
    WsFrameResult.prototype[Symbol.dispose] = WsFrameResult.prototype.free;
  EXPECTED_RESPONSE_TYPES = new Set(["basic", "cors", "default"]);
  gust_wasm_default = __wbg_init;
});

// src/wasm-loader.ts
import { readFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
var __dirname = "/home/runner/work/gust/gust/packages/serve/src", wasmModule = null, wasmLoadAttempted = false, wasmLoadError = null, getModuleDir = () => {
  try {
    return dirname(fileURLToPath(import.meta.url));
  } catch {
    return __dirname;
  }
}, initWasmSync = () => {
  if (wasmLoadAttempted)
    return wasmModule !== null;
  wasmLoadAttempted = true;
  try {
    const wasm2 = (init_gust_wasm(), __toCommonJS(exports_gust_wasm));
    if (typeof wasm2.initSync === "function") {
      try {
        const wasmPath = join(getModuleDir(), "wasm", "gust_wasm_bg.wasm");
        const wasmBytes = readFileSync(wasmPath);
        wasm2.initSync({ module: wasmBytes });
      } catch {}
    }
    if (wasm2.seed_rng) {
      wasm2.seed_rng(BigInt(Date.now()));
    }
    wasmModule = wasm2;
    return true;
  } catch (e) {
    wasmLoadError = e;
    return false;
  }
}, initWasm = async () => {
  if (wasmLoadAttempted)
    return wasmModule !== null;
  if (initWasmSync())
    return true;
  wasmLoadAttempted = true;
  try {
    const wasm2 = await Promise.resolve().then(() => (init_gust_wasm(), exports_gust_wasm));
    if (typeof wasm2.default === "function") {
      await wasm2.default();
    }
    if (wasm2.seed_rng) {
      wasm2.seed_rng(BigInt(Date.now()));
    }
    wasmModule = wasm2;
    return true;
  } catch (e) {
    wasmLoadError = e;
    return false;
  }
}, ensureWasm = () => {
  if (!wasmModule && !wasmLoadAttempted) {
    initWasmSync();
  }
  return wasmModule;
}, isWasmAvailable = () => {
  return ensureWasm() !== null;
}, wasmGenerateWebSocketAccept = (key) => {
  const wasm2 = ensureWasm();
  if (!wasm2?.generate_websocket_accept)
    return null;
  try {
    return wasm2.generate_websocket_accept(key);
  } catch {
    return null;
  }
}, wasmEncodeWebSocketText = (text, fin = true) => {
  const wasm2 = ensureWasm();
  if (!wasm2?.encode_websocket_text)
    return null;
  try {
    return wasm2.encode_websocket_text(text, fin);
  } catch {
    return null;
  }
}, wasmEncodeWebSocketBinary = (data, fin = true) => {
  const wasm2 = ensureWasm();
  if (!wasm2?.encode_websocket_binary)
    return null;
  try {
    return wasm2.encode_websocket_binary(data, fin);
  } catch {
    return null;
  }
}, wasmEncodeWebSocketPing = (data) => {
  const wasm2 = ensureWasm();
  if (!wasm2?.encode_websocket_ping)
    return null;
  try {
    return wasm2.encode_websocket_ping(data ?? new Uint8Array(0));
  } catch {
    return null;
  }
}, wasmEncodeWebSocketPong = (data) => {
  const wasm2 = ensureWasm();
  if (!wasm2?.encode_websocket_pong)
    return null;
  try {
    return wasm2.encode_websocket_pong(data ?? new Uint8Array(0));
  } catch {
    return null;
  }
}, wasmEncodeWebSocketClose = (code, reason) => {
  const wasm2 = ensureWasm();
  if (!wasm2?.encode_websocket_close)
    return null;
  try {
    return wasm2.encode_websocket_close(code, reason);
  } catch {
    return null;
  }
}, wasmGenerateTraceId = () => {
  const wasm2 = ensureWasm();
  if (!wasm2?.generate_trace_id)
    return null;
  try {
    return wasm2.generate_trace_id();
  } catch {
    return null;
  }
}, wasmGenerateSpanId = () => {
  const wasm2 = ensureWasm();
  if (!wasm2?.generate_span_id)
    return null;
  try {
    return wasm2.generate_span_id();
  } catch {
    return null;
  }
}, wasmParseTraceparent = (header) => {
  const wasm2 = ensureWasm();
  if (!wasm2?.parse_traceparent)
    return null;
  try {
    const result = wasm2.parse_traceparent(header);
    if (!result)
      return null;
    return {
      traceId: result.trace_id,
      spanId: result.span_id,
      traceFlags: result.trace_flags
    };
  } catch {
    return null;
  }
}, wasmFormatTraceparent = (traceId, spanId, traceFlags) => {
  const wasm2 = ensureWasm();
  if (!wasm2?.format_traceparent)
    return null;
  try {
    return wasm2.format_traceparent(traceId, spanId, traceFlags);
  } catch {
    return null;
  }
};
var init_wasm_loader = () => {};

// ../../crates/gust-napi/gust-napi.darwin-arm64.node
var require_gust_napi_darwin_arm64 = __commonJS((exports, module) => {
  module.exports = __require("./gust-napi.darwin-arm64-z7mdz0pp.node");
});

// ../../crates/gust-napi/index.js
var require_gust_napi = __commonJS((exports, module) => {
  var __dirname = "/home/runner/work/gust/gust/crates/gust-napi";
  var { existsSync, readFileSync: readFileSync2 } = __require("node:fs");
  var { join: join2 } = __require("node:path");
  var { platform, arch } = process;
  var nativeBinding = null;
  var localFileExisted = false;
  var loadError = null;
  function isMusl() {
    if (!process.report || typeof process.report.getReport !== "function") {
      try {
        const lddPath = __require("node:child_process").execSync("which ldd").toString().trim();
        return readFileSync2(lddPath, "utf8").includes("musl");
      } catch {
        return true;
      }
    } else {
      const { glibcVersionRuntime } = process.report.getReport().header;
      return !glibcVersionRuntime;
    }
  }
  switch (platform) {
    case "darwin":
      switch (arch) {
        case "arm64":
          localFileExisted = existsSync(join2(__dirname, "gust-napi.darwin-arm64.node"));
          try {
            if (localFileExisted) {
              nativeBinding = require_gust_napi_darwin_arm64();
            } else {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"@gust/napi-darwin-arm64");})();
            }
          } catch (e) {
            loadError = e;
          }
          break;
        case "x64":
          localFileExisted = existsSync(join2(__dirname, "gust-napi.darwin-x64.node"));
          try {
            if (localFileExisted) {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"./gust-napi.darwin-x64.node");})();
            } else {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"@gust/napi-darwin-x64");})();
            }
          } catch (e) {
            loadError = e;
          }
          break;
        default:
          throw new Error(`Unsupported architecture on macOS: ${arch}`);
      }
      break;
    case "linux":
      switch (arch) {
        case "x64":
          if (isMusl()) {
            localFileExisted = existsSync(join2(__dirname, "gust-napi.linux-x64-musl.node"));
            try {
              if (localFileExisted) {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"./gust-napi.linux-x64-musl.node");})();
              } else {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"@gust/napi-linux-x64-musl");})();
              }
            } catch (e) {
              loadError = e;
            }
          } else {
            localFileExisted = existsSync(join2(__dirname, "gust-napi.linux-x64-gnu.node"));
            try {
              if (localFileExisted) {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"./gust-napi.linux-x64-gnu.node");})();
              } else {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"@gust/napi-linux-x64-gnu");})();
              }
            } catch (e) {
              loadError = e;
            }
          }
          break;
        case "arm64":
          if (isMusl()) {
            localFileExisted = existsSync(join2(__dirname, "gust-napi.linux-arm64-musl.node"));
            try {
              if (localFileExisted) {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"./gust-napi.linux-arm64-musl.node");})();
              } else {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"@gust/napi-linux-arm64-musl");})();
              }
            } catch (e) {
              loadError = e;
            }
          } else {
            localFileExisted = existsSync(join2(__dirname, "gust-napi.linux-arm64-gnu.node"));
            try {
              if (localFileExisted) {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"./gust-napi.linux-arm64-gnu.node");})();
              } else {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"@gust/napi-linux-arm64-gnu");})();
              }
            } catch (e) {
              loadError = e;
            }
          }
          break;
        default:
          throw new Error(`Unsupported architecture on Linux: ${arch}`);
      }
      break;
    default:
      throw new Error(`Unsupported platform: ${platform}`);
  }
  if (!nativeBinding) {
    if (loadError) {
      throw loadError;
    }
    throw new Error(`Failed to load native binding`);
  }
  var { GustServer, isIoUringAvailable, getCpuCount } = nativeBinding;
  exports.GustServer = GustServer;
  exports.isIoUringAvailable = isIoUringAvailable;
  exports.getCpuCount = getCpuCount;
});

// src/native.ts
var nativeBinding = null, nativeLoadAttempted = false, nativeLoadError = null, loadNative = () => {
  if (nativeLoadAttempted)
    return nativeBinding;
  nativeLoadAttempted = true;
  try {
    nativeBinding = (()=>{throw new Error("Cannot require module "+"@sylphx/gust-napi");})();
    return nativeBinding;
  } catch (e) {
    try {
      nativeBinding = require_gust_napi();
      return nativeBinding;
    } catch {
      nativeLoadError = e;
      return null;
    }
  }
}, isNativeAvailable = () => {
  return loadNative() !== null;
}, loadNativeBinding = () => {
  return loadNative();
}, getRecommendedWorkers = () => {
  const binding = loadNative();
  if (!binding)
    return 1;
  try {
    return binding.getRecommendedWorkers();
  } catch {
    return 1;
  }
}, isTlsAvailable = () => {
  const binding = loadNative();
  if (!binding)
    return false;
  try {
    return binding.isTlsAvailable();
  } catch {
    return false;
  }
}, createNativeCircuitBreaker = (config) => {
  const binding = loadNative();
  if (!binding?.CircuitBreaker)
    return null;
  try {
    return new binding.CircuitBreaker(config);
  } catch {
    return null;
  }
}, createNativeBulkhead = (config) => {
  const binding = loadNative();
  if (!binding?.Bulkhead)
    return null;
  try {
    return new binding.Bulkhead(config);
  } catch {
    return null;
  }
}, nativeGenerateTraceId = () => {
  const binding = loadNative();
  if (binding?.generateTraceId) {
    try {
      return binding.generateTraceId();
    } catch {}
  }
  return wasmGenerateTraceId();
}, nativeGenerateSpanId = () => {
  const binding = loadNative();
  if (binding?.generateSpanId) {
    try {
      return binding.generateSpanId();
    } catch {}
  }
  return wasmGenerateSpanId();
}, nativeParseTraceparent = (header) => {
  const binding = loadNative();
  if (binding?.parseTraceparent) {
    try {
      return binding.parseTraceparent(header);
    } catch {}
  }
  return wasmParseTraceparent(header);
}, nativeFormatTraceparent = (traceId, spanId, traceFlags) => {
  const binding = loadNative();
  if (binding?.formatTraceparent) {
    try {
      return binding.formatTraceparent(traceId, spanId, traceFlags);
    } catch {}
  }
  return wasmFormatTraceparent(traceId, spanId, traceFlags);
}, createNativeMetricsCollector = () => {
  const binding = loadNative();
  if (!binding?.MetricsCollector)
    return null;
  try {
    return new binding.MetricsCollector;
  } catch {
    return null;
  }
}, nativeGenerateWebSocketAccept = (key) => {
  const binding = loadNative();
  if (binding?.generateWebsocketAccept) {
    try {
      return binding.generateWebsocketAccept(key);
    } catch {}
  }
  return wasmGenerateWebSocketAccept(key);
}, nativeEncodeWebSocketText = (text, fin = true) => {
  const binding = loadNative();
  if (binding?.encodeWebsocketText) {
    try {
      const arr = binding.encodeWebsocketText(text, fin);
      return Buffer.from(arr);
    } catch {}
  }
  const wasmResult = wasmEncodeWebSocketText(text, fin);
  if (wasmResult)
    return Buffer.from(wasmResult);
  return null;
}, nativeEncodeWebSocketBinary = (data, fin = true) => {
  const binding = loadNative();
  if (binding?.encodeWebsocketBinary) {
    try {
      const arr = Array.isArray(data) ? data : Array.from(data);
      const result = binding.encodeWebsocketBinary(arr, fin);
      return Buffer.from(result);
    } catch {}
  }
  const uint8 = data instanceof Buffer ? new Uint8Array(data) : new Uint8Array(data);
  const wasmResult = wasmEncodeWebSocketBinary(uint8, fin);
  if (wasmResult)
    return Buffer.from(wasmResult);
  return null;
}, nativeEncodeWebSocketPing = (data) => {
  const binding = loadNative();
  if (binding?.encodeWebsocketPing) {
    try {
      const arr = data ? Array.isArray(data) ? data : Array.from(data) : undefined;
      const result = binding.encodeWebsocketPing(arr);
      return Buffer.from(result);
    } catch {}
  }
  const uint8 = data ? data instanceof Buffer ? new Uint8Array(data) : new Uint8Array(data) : undefined;
  const wasmResult = wasmEncodeWebSocketPing(uint8);
  if (wasmResult)
    return Buffer.from(wasmResult);
  return null;
}, nativeEncodeWebSocketPong = (data) => {
  const binding = loadNative();
  if (binding?.encodeWebsocketPong) {
    try {
      const arr = data ? Array.isArray(data) ? data : Array.from(data) : undefined;
      const result = binding.encodeWebsocketPong(arr);
      return Buffer.from(result);
    } catch {}
  }
  const uint8 = data ? data instanceof Buffer ? new Uint8Array(data) : new Uint8Array(data) : undefined;
  const wasmResult = wasmEncodeWebSocketPong(uint8);
  if (wasmResult)
    return Buffer.from(wasmResult);
  return null;
}, nativeEncodeWebSocketClose = (code, reason) => {
  const binding = loadNative();
  if (binding?.encodeWebsocketClose) {
    try {
      const result = binding.encodeWebsocketClose(code, reason);
      return Buffer.from(result);
    } catch {}
  }
  const wasmResult = wasmEncodeWebSocketClose(code, reason);
  if (wasmResult)
    return Buffer.from(wasmResult);
  return null;
};
var init_native = __esm(() => {
  init_wasm_loader();
});

// src/context.ts
import { MethodNames } from "@sylphx/gust-core";
var createRawContext = (socket, raw, parsed, headers, params = {}) => {
  const decoder = new TextDecoder;
  const method = MethodNames[parsed.method] || "UNKNOWN";
  const path = decoder.decode(raw.subarray(parsed.path_start, parsed.path_end));
  const query = parsed.query_start > 0 ? decoder.decode(raw.subarray(parsed.query_start, parsed.query_end)) : "";
  const body = raw.subarray(parsed.body_start);
  return {
    method,
    path,
    query,
    headers,
    params,
    body,
    json: () => JSON.parse(body.toString()),
    raw,
    socket
  };
}, withApp = (raw, app) => ({ ...raw, app }), withParams = (ctx, params) => ({
  ...ctx,
  params: { ...ctx.params, ...params }
}), parseHeaders = (raw, offsets, count) => {
  const headers = {};
  const decoder = new TextDecoder;
  for (let i = 0;i < count; i++) {
    const nameStart = offsets[i * 4];
    const nameEnd = offsets[i * 4 + 1];
    const valueStart = offsets[i * 4 + 2];
    const valueEnd = offsets[i * 4 + 3];
    const name = decoder.decode(raw.subarray(nameStart, nameEnd)).toLowerCase();
    const value = decoder.decode(raw.subarray(valueStart, valueEnd));
    headers[name] = value;
  }
  return headers;
}, createContext;
var init_context = __esm(() => {
  createContext = createRawContext;
});

// src/serve.ts
var exports_serve = {};
__export(exports_serve, {
  serve: () => serve
});
import { createServer } from "node:net";
import { createServer as createTlsServer } from "node:tls";
import { getWasm, initWasm as initWasm2, isStreamingBody, serverError } from "@sylphx/gust-core";
var DEFAULT_KEEP_ALIVE_TIMEOUT = 5000, DEFAULT_MAX_REQUESTS = 100, DEFAULT_REQUEST_TIMEOUT = 30000, DEFAULT_MAX_HEADER_SIZE = 8192, STATUS_LINES, CONN_KEEP_ALIVE = `connection: keep-alive\r
`, CONN_CLOSE = `connection: close\r
`, EMPTY_BUFFER, createHandler = (routes) => {
  let wasmRouter = null;
  const handlers = [];
  const initRouter = () => {
    if (wasmRouter)
      return wasmRouter;
    const wasm2 = getWasm();
    wasmRouter = new wasm2.WasmRouter;
    for (const route of routes) {
      const handlerId = handlers.length;
      handlers.push(route.handler);
      wasmRouter.insert(route.method, route.path, handlerId);
      if (route.method === "*") {
        for (const method of ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]) {
          wasmRouter.insert(method, route.path, handlerId);
        }
      }
    }
    return wasmRouter;
  };
  return async (ctx) => {
    const r = initRouter();
    const match = r.find(ctx.method, ctx.path);
    if (!match.found) {
      match.free();
      return { status: 404, headers: { "content-type": "text/plain" }, body: "Not Found" };
    }
    const h = handlers[match.handler_id];
    const params = {};
    const paramArray = match.params;
    for (let i = 0;i < paramArray.length; i += 2) {
      const key = paramArray[i];
      const value = paramArray[i + 1];
      if (key !== undefined && value !== undefined) {
        params[key] = value;
      }
    }
    match.free();
    if (!h) {
      return { status: 404, headers: { "content-type": "text/plain" }, body: "Not Found" };
    }
    const ctxWithParams = { ...ctx, params: { ...ctx.params, ...params } };
    return h({ ctx: ctxWithParams, input: undefined });
  };
}, createEntryHandler = (routes, contextProvider, middleware) => {
  const routerHandler = createHandler(routes);
  const finalHandler = middleware ? middleware(routerHandler) : routerHandler;
  return async (raw) => {
    const app = contextProvider ? await contextProvider(raw) : {};
    const ctx = withApp(raw, app);
    return finalHandler(ctx);
  };
}, serve = async (options) => {
  const port = options.port ?? (options.tls ? 443 : 3000);
  const hostname = options.hostname ?? "0.0.0.0";
  const useTls = !!options.tls;
  const handler = createEntryHandler(options.routes, options.context, options.middleware);
  if (isNativeAvailable()) {
    if (useTls && !isTlsAvailable()) {
      return serveJs(options, handler, port, hostname, useTls);
    }
    const nativeServer = await serveNative(options, handler, port, hostname, useTls);
    if (nativeServer) {
      return nativeServer;
    }
  }
  return serveJs(options, handler, port, hostname, useTls);
}, serveNative = async (options, handler, port, hostname, useTls) => {
  const binding = loadNativeBinding();
  if (!binding)
    return null;
  try {
    const server = new binding.GustServer;
    if (useTls && options.tls) {
      const tlsConfig = {};
      if (typeof options.tls.cert === "string") {
        tlsConfig.cert = options.tls.cert;
      } else if (Buffer.isBuffer(options.tls.cert)) {
        tlsConfig.cert = options.tls.cert.toString("utf-8");
      }
      if (typeof options.tls.key === "string") {
        tlsConfig.key = options.tls.key;
      } else if (Buffer.isBuffer(options.tls.key)) {
        tlsConfig.key = options.tls.key.toString("utf-8");
      }
      await server.enableTls(tlsConfig);
      if (options.http2) {
        await server.enableHttp2();
      }
    }
    if (options.requestTimeout !== undefined) {
      await server.setRequestTimeout(options.requestTimeout);
    }
    if (options.maxBodySize !== undefined) {
      await server.setMaxBodySize(options.maxBodySize);
    }
    if (options.keepAliveTimeout !== undefined) {
      await server.setKeepAliveTimeout(options.keepAliveTimeout);
    }
    if (options.maxHeaderSize !== undefined) {
      await server.setMaxHeaderSize(options.maxHeaderSize);
    }
    server.setFallback(async (ctx) => {
      try {
        const bodyBuffer = ctx.body ? Buffer.from(ctx.body) : Buffer.alloc(0);
        const rawCtx = {
          method: ctx.method,
          path: ctx.path,
          query: ctx.query ?? "",
          headers: ctx.headers,
          params: ctx.params,
          body: bodyBuffer,
          json: () => {
            try {
              return JSON.parse(ctx.body || "{}");
            } catch {
              return {};
            }
          },
          raw: bodyBuffer,
          socket: null
        };
        const response4 = await handler(rawCtx);
        const headers = {};
        if (response4.headers) {
          for (const key in response4.headers) {
            headers[key] = String(response4.headers[key]);
          }
        }
        const body = response4.body === null ? "" : typeof response4.body === "string" ? response4.body : Buffer.isBuffer(response4.body) ? response4.body.toString() : String(response4.body);
        return {
          status: response4.status,
          headers,
          body
        };
      } catch (err) {
        options.onError?.(err);
        return {
          status: 500,
          headers: { "content-type": "text/plain" },
          body: "Internal Server Error"
        };
      }
    });
    server.serveWithHostname(port, hostname).catch((err) => {
      options.onError?.(err);
    });
    options.onListen?.({ port, hostname, tls: useTls });
    return {
      port,
      hostname,
      tls: useTls,
      connections: () => server.activeConnections(),
      stop: async () => {
        await server.shutdown();
      },
      shutdown: async (timeout = 30000) => {
        await server.gracefulShutdown(timeout);
      }
    };
  } catch (err) {
    options.onError?.(err);
    return null;
  }
}, serveJs = async (options, handler, port, hostname, useTls) => {
  await initWasm2();
  const wasm2 = getWasm();
  const keepAliveTimeout = options.keepAliveTimeout ?? DEFAULT_KEEP_ALIVE_TIMEOUT;
  const maxRequests = options.maxRequestsPerConnection ?? DEFAULT_MAX_REQUESTS;
  const requestTimeout = options.requestTimeout ?? DEFAULT_REQUEST_TIMEOUT;
  const maxHeaderSize = options.maxHeaderSize ?? DEFAULT_MAX_HEADER_SIZE;
  const activeConnections = new Set;
  let isShuttingDown = false;
  const connectionConfig = {
    keepAliveTimeout,
    maxRequests,
    requestTimeout,
    maxHeaderSize,
    onError: options.onError
  };
  return new Promise((resolve, reject) => {
    const server = useTls ? createTlsServer({
      cert: options.tls?.cert,
      key: options.tls?.key,
      ca: options.tls?.ca,
      passphrase: options.tls?.passphrase
    }, (socket) => {
      if (isShuttingDown) {
        socket.end();
        return;
      }
      activeConnections.add(socket);
      socket.on("close", () => activeConnections.delete(socket));
      handleConnection(socket, handler, wasm2, connectionConfig);
    }) : createServer((socket) => {
      if (isShuttingDown) {
        socket.end();
        return;
      }
      activeConnections.add(socket);
      socket.on("close", () => activeConnections.delete(socket));
      handleConnection(socket, handler, wasm2, connectionConfig);
    });
    server.on("error", reject);
    server.listen(port, hostname, () => {
      const serverInfo = {
        port,
        hostname,
        tls: useTls,
        connections: () => activeConnections.size,
        stop: () => new Promise((res) => {
          for (const socket of activeConnections) {
            socket.destroy();
          }
          activeConnections.clear();
          server.close(() => res());
        }),
        shutdown: (timeout = 30000) => new Promise((res) => {
          isShuttingDown = true;
          server.close(() => {
            res();
          });
          const checkInterval = setInterval(() => {
            if (activeConnections.size === 0) {
              clearInterval(checkInterval);
              res();
            }
          }, 100);
          setTimeout(() => {
            clearInterval(checkInterval);
            for (const socket of activeConnections) {
              socket.destroy();
            }
            activeConnections.clear();
            res();
          }, timeout);
        })
      };
      options.onListen?.({ port, hostname, tls: useTls });
      resolve(serverInfo);
    });
  });
}, handleConnection = (socket, handler, wasm2, config) => {
  const state = {
    buffer: EMPTY_BUFFER,
    requestCount: 0,
    idleTimer: null,
    requestTimer: null,
    isProcessing: false
  };
  const resetIdleTimer = config.keepAliveTimeout > 0 ? () => {
    if (state.idleTimer)
      clearTimeout(state.idleTimer);
    state.idleTimer = setTimeout(() => socket.end(), config.keepAliveTimeout);
  } : () => {};
  const clearTimers = () => {
    if (state.idleTimer) {
      clearTimeout(state.idleTimer);
      state.idleTimer = null;
    }
    if (state.requestTimer) {
      clearTimeout(state.requestTimer);
      state.requestTimer = null;
    }
  };
  const startRequestTimeout = config.requestTimeout > 0 ? () => {
    if (state.requestTimer)
      clearTimeout(state.requestTimer);
    state.requestTimer = setTimeout(() => {
      if (state.isProcessing) {
        clearTimers();
        socket.write(`HTTP/1.1 408 Request Timeout\r
Connection: close\r
\r
`);
        socket.end();
      }
    }, config.requestTimeout);
  } : () => {};
  const clearRequestTimeout = () => {
    if (state.requestTimer) {
      clearTimeout(state.requestTimer);
      state.requestTimer = null;
    }
  };
  resetIdleTimer();
  socket.on("data", async (chunk) => {
    resetIdleTimer();
    state.buffer = state.buffer.length === 0 ? chunk : Buffer.concat([state.buffer, chunk]);
    const headerEnd = state.buffer.indexOf(`\r
\r
`);
    if (headerEnd === -1 && state.buffer.length > config.maxHeaderSize) {
      clearTimers();
      socket.write(`HTTP/1.1 431 Request Header Fields Too Large\r
Connection: close\r
\r
`);
      socket.end();
      return;
    }
    while (state.buffer.length > 0) {
      const parsed = wasm2.parse_http(new Uint8Array(state.buffer));
      if (parsed.state === 0) {
        parsed.free();
        return;
      }
      if (parsed.state === 2) {
        parsed.free();
        clearTimers();
        socket.write(`HTTP/1.1 400 Bad Request\r
Connection: close\r
\r
`);
        socket.end();
        return;
      }
      state.requestCount++;
      state.isProcessing = true;
      startRequestTimeout();
      const requestBuffer = state.buffer;
      try {
        const headers = parseHeaders(requestBuffer, parsed.header_offsets, parsed.headers_count);
        const ctx = createRawContext(socket, requestBuffer, parsed, headers);
        const connectionHeader = headers.connection?.toLowerCase() || "";
        const keepAlive = connectionHeader !== "close";
        const shouldClose = !keepAlive || state.requestCount >= config.maxRequests;
        const requestEnd = parsed.body_start + (headers["content-length"] ? parseInt(headers["content-length"], 10) : 0);
        parsed.free();
        const response4 = await handler(ctx);
        clearRequestTimeout();
        state.isProcessing = false;
        sendResponse(socket, response4, shouldClose);
        if (shouldClose) {
          clearTimers();
          socket.end();
          return;
        }
        state.buffer = state.buffer.length > requestEnd ? state.buffer.subarray(requestEnd) : EMPTY_BUFFER;
      } catch (error) {
        config.onError?.(error);
        clearTimers();
        sendResponse(socket, serverError(), true);
        socket.end();
        return;
      }
    }
  });
  socket.on("close", clearTimers);
  socket.on("error", (err) => {
    clearTimers();
    config.onError?.(err);
  });
}, sendResponse = (socket, response4, shouldClose) => {
  if (isStreamingBody(response4.body)) {
    sendStreamingResponse(socket, response4, shouldClose);
    return;
  }
  const statusLine = STATUS_LINES[response4.status] || `HTTP/1.1 ${response4.status} Unknown\r
`;
  const connHeader = shouldClose ? CONN_CLOSE : CONN_KEEP_ALIVE;
  const body = response4.body;
  const bodyLen = body !== null ? Buffer.byteLength(body) : 0;
  let headers = statusLine;
  for (const key in response4.headers) {
    headers += `${key}: ${response4.headers[key]}\r
`;
  }
  headers += `content-length: ${bodyLen}\r
`;
  headers += connHeader;
  headers += `\r
`;
  if (body !== null && bodyLen > 0) {
    const headerBuf = Buffer.from(headers);
    const bodyBuf = typeof body === "string" ? Buffer.from(body) : body;
    socket.write(Buffer.concat([headerBuf, bodyBuf]));
  } else {
    socket.write(headers);
  }
}, sendStreamingResponse = async (socket, response4, shouldClose) => {
  const statusLine = STATUS_LINES[response4.status] || `HTTP/1.1 ${response4.status} Unknown\r
`;
  const connHeader = shouldClose ? CONN_CLOSE : CONN_KEEP_ALIVE;
  let headers = statusLine;
  for (const key in response4.headers) {
    headers += `${key}: ${response4.headers[key]}\r
`;
  }
  headers += `transfer-encoding: chunked\r
`;
  headers += connHeader;
  headers += `\r
`;
  socket.write(headers);
  try {
    for await (const chunk of response4.body) {
      if (!socket.writable)
        break;
      const sizeHex = chunk.length.toString(16);
      const chunkBuf = Buffer.allocUnsafe(sizeHex.length + 2 + chunk.length + 2);
      chunkBuf.write(sizeHex, 0);
      chunkBuf.write(`\r
`, sizeHex.length);
      chunkBuf.set(chunk, sizeHex.length + 2);
      chunkBuf.write(`\r
`, sizeHex.length + 2 + chunk.length);
      const canWrite = socket.write(chunkBuf);
      if (!canWrite) {
        await new Promise((resolve) => socket.once("drain", resolve));
      }
    }
    socket.write(`0\r
\r
`);
  } catch {
    socket.destroy();
  }
};
var init_serve = __esm(() => {
  init_context();
  init_native();
  STATUS_LINES = {
    200: `HTTP/1.1 200 OK\r
`,
    201: `HTTP/1.1 201 Created\r
`,
    204: `HTTP/1.1 204 No Content\r
`,
    301: `HTTP/1.1 301 Moved Permanently\r
`,
    302: `HTTP/1.1 302 Found\r
`,
    304: `HTTP/1.1 304 Not Modified\r
`,
    400: `HTTP/1.1 400 Bad Request\r
`,
    401: `HTTP/1.1 401 Unauthorized\r
`,
    403: `HTTP/1.1 403 Forbidden\r
`,
    404: `HTTP/1.1 404 Not Found\r
`,
    500: `HTTP/1.1 500 Internal Server Error\r
`
  };
  EMPTY_BUFFER = Buffer.allocUnsafe(0);
});

// src/index.ts
import {
  badRequest,
  compose,
  forbidden as forbidden2,
  getWasm as getWasm2,
  html,
  initWasm as initWasm3,
  isStreamingBody as isStreamingBody2,
  isWasmReady,
  json as json3,
  notFound as notFound3,
  pipe,
  redirect,
  response as response9,
  serverError as serverError3,
  text,
  unauthorized as unauthorized2
} from "@sylphx/gust-core";

// src/auth.ts
import { createHmac, timingSafeEqual } from "node:crypto";
import { response, unauthorized as unauthorizedResponse } from "@sylphx/gust-core";
var parseBasicAuth = (header) => {
  if (!header.toLowerCase().startsWith("basic "))
    return null;
  const encoded = header.slice(6).trim();
  let decoded;
  try {
    decoded = Buffer.from(encoded, "base64").toString("utf-8");
  } catch {
    return null;
  }
  const colonIndex = decoded.indexOf(":");
  if (colonIndex === -1)
    return null;
  return {
    username: decoded.slice(0, colonIndex),
    password: decoded.slice(colonIndex + 1)
  };
};
var createBasicAuth = (username, password) => {
  return `Basic ${Buffer.from(`${username}:${password}`).toString("base64")}`;
};
var basicAuth = (options) => {
  const { validate, realm = "Secure Area", skip, onUnauthorized } = options;
  const unauthorized = onUnauthorized ?? (() => response("Unauthorized", {
    status: 401,
    headers: {
      "www-authenticate": `Basic realm="${realm}"`,
      "content-type": "text/plain"
    }
  }));
  return (handler) => {
    return async (ctx) => {
      if (skip?.(ctx)) {
        return handler(ctx);
      }
      const authHeader = ctx.headers.authorization;
      if (!authHeader) {
        return unauthorized(ctx);
      }
      const credentials = parseBasicAuth(authHeader);
      if (!credentials) {
        return unauthorized(ctx);
      }
      const isValid = await validate(credentials.username, credentials.password, ctx);
      if (!isValid) {
        return unauthorized(ctx);
      }
      return handler(ctx);
    };
  };
};
var simpleBasicAuth = (username, password, realm = "Secure Area") => {
  const expectedUser = Buffer.from(username);
  const expectedPass = Buffer.from(password);
  return basicAuth({
    realm,
    validate: (u, p) => {
      const userBuf = Buffer.from(u);
      const passBuf = Buffer.from(p);
      const userMatch = userBuf.length === expectedUser.length && timingSafeEqual(userBuf, expectedUser);
      const passMatch = passBuf.length === expectedPass.length && timingSafeEqual(passBuf, expectedPass);
      return userMatch && passMatch;
    }
  });
};
var parseBearerToken = (header, prefix = "Bearer") => {
  const prefixLower = prefix.toLowerCase();
  if (!header.toLowerCase().startsWith(`${prefixLower} `))
    return null;
  return header.slice(prefix.length + 1).trim();
};
var bearerAuth = (options) => {
  const { validate, skip, onUnauthorized, header = "authorization", prefix = "Bearer" } = options;
  const headerLower = header.toLowerCase();
  const unauthorized = onUnauthorized ?? (() => unauthorizedResponse());
  return (handler) => {
    return async (ctx) => {
      if (skip?.(ctx)) {
        return handler(ctx);
      }
      const authHeader = ctx.headers[headerLower];
      if (!authHeader) {
        return unauthorized(ctx);
      }
      const token = parseBearerToken(authHeader, prefix);
      if (!token) {
        return unauthorized(ctx);
      }
      const isValid = await validate(token, ctx);
      if (!isValid) {
        return unauthorized(ctx);
      }
      return handler(ctx);
    };
  };
};
var apiKeyAuth = (options) => {
  const { validate, header = "x-api-key", query = "api_key", skip, onUnauthorized } = options;
  const headerLower = header.toLowerCase();
  const unauthorized = onUnauthorized ?? (() => unauthorizedResponse("Invalid API Key"));
  return (handler) => {
    return async (ctx) => {
      if (skip?.(ctx)) {
        return handler(ctx);
      }
      let apiKey = ctx.headers[headerLower];
      if (!apiKey && ctx.query) {
        const queryMatch = ctx.query.match(new RegExp(`[?&]${query}=([^&]+)`));
        if (queryMatch?.[1]) {
          apiKey = decodeURIComponent(queryMatch[1]);
        }
      }
      if (!apiKey) {
        return unauthorized(ctx);
      }
      const isValid = await validate(apiKey, ctx);
      if (!isValid) {
        return unauthorized(ctx);
      }
      return handler(ctx);
    };
  };
};
var simpleApiKey = (validKeys, options = {}) => {
  const keySet = new Set(validKeys);
  return apiKeyAuth({
    ...options,
    validate: (key) => keySet.has(key)
  });
};
var generateHmac = (data, secret, algorithm = "sha256") => {
  return createHmac(algorithm, secret).update(data).digest("hex");
};
var verifyHmac = (data, signature, secret, algorithm = "sha256") => {
  const expected = generateHmac(data, secret, algorithm);
  const sigBuf = Buffer.from(signature);
  const expBuf = Buffer.from(expected);
  if (sigBuf.length !== expBuf.length)
    return false;
  return timingSafeEqual(sigBuf, expBuf);
};
var hmacAuth = (options) => {
  const { secret, algorithm = "sha256", header = "x-signature", skip } = options;
  const headerLower = header.toLowerCase();
  return (handler) => {
    return async (ctx) => {
      if (skip?.(ctx)) {
        return handler(ctx);
      }
      const signature = ctx.headers[headerLower];
      if (!signature) {
        return unauthorizedResponse("Missing signature");
      }
      const isValid = verifyHmac(ctx.body, signature, secret, algorithm);
      if (!isValid) {
        return unauthorizedResponse("Invalid signature");
      }
      return handler(ctx);
    };
  };
};
// src/body.ts
var parseQuery = (queryString) => {
  const params = {};
  if (!queryString)
    return params;
  const qs = queryString.startsWith("?") ? queryString.slice(1) : queryString;
  for (const pair of qs.split("&")) {
    const [rawKey, rawValue = ""] = pair.split("=");
    if (!rawKey)
      continue;
    const key = decodeURIComponent(rawKey.replace(/\+/g, " "));
    const value = decodeURIComponent(rawValue.replace(/\+/g, " "));
    if (key.endsWith("[]")) {
      const arrayKey = key.slice(0, -2);
      const existing = params[arrayKey];
      if (Array.isArray(existing)) {
        existing.push(value);
      } else if (existing !== undefined) {
        params[arrayKey] = [existing, value];
      } else {
        params[arrayKey] = [value];
      }
    } else if (params[key] !== undefined) {
      const existing = params[key];
      if (Array.isArray(existing)) {
        existing.push(value);
      } else {
        params[key] = [existing, value];
      }
    } else {
      params[key] = value;
    }
  }
  return params;
};
var stringifyQuery = (params) => {
  const parts = [];
  for (const [key, value] of Object.entries(params)) {
    if (value === undefined)
      continue;
    if (Array.isArray(value)) {
      for (const v of value) {
        parts.push(`${encodeURIComponent(key)}[]=${encodeURIComponent(v)}`);
      }
    } else {
      parts.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
    }
  }
  return parts.join("&");
};
var parseFormBody = (body) => {
  const str = typeof body === "string" ? body : body.toString("utf8");
  const result = {};
  for (const pair of str.split("&")) {
    const [rawKey, rawValue = ""] = pair.split("=");
    if (!rawKey)
      continue;
    const key = decodeURIComponent(rawKey.replace(/\+/g, " "));
    const value = decodeURIComponent(rawValue.replace(/\+/g, " "));
    result[key] = value;
  }
  return result;
};
var parseJsonBody = (body) => {
  const str = typeof body === "string" ? body : body.toString("utf8");
  return JSON.parse(str);
};
var parseMultipart = (body, boundary) => {
  const parts = [];
  const boundaryBuf = Buffer.from(`--${boundary}`);
  const endBoundaryBuf = Buffer.from(`--${boundary}--`);
  let pos = 0;
  const firstBoundary = body.indexOf(boundaryBuf, pos);
  if (firstBoundary === -1)
    return parts;
  pos = firstBoundary + boundaryBuf.length;
  while (pos < body.length) {
    if (body[pos] === 13 && body[pos + 1] === 10) {
      pos += 2;
    }
    if (body.indexOf(endBoundaryBuf, pos - boundaryBuf.length - 2) !== -1) {
      break;
    }
    const headersEnd = body.indexOf(Buffer.from(`\r
\r
`), pos);
    if (headersEnd === -1)
      break;
    const headersStr = body.subarray(pos, headersEnd).toString("utf8");
    const headers = {};
    for (const line of headersStr.split(`\r
`)) {
      const colonIdx = line.indexOf(":");
      if (colonIdx > 0) {
        const key = line.substring(0, colonIdx).trim().toLowerCase();
        const value = line.substring(colonIdx + 1).trim();
        headers[key] = value;
      }
    }
    pos = headersEnd + 4;
    const nextBoundary = body.indexOf(boundaryBuf, pos);
    if (nextBoundary === -1)
      break;
    let dataEnd = nextBoundary - 2;
    if (body[dataEnd] !== 13 || body[dataEnd + 1] !== 10) {
      dataEnd = nextBoundary;
    }
    const data = body.subarray(pos, dataEnd);
    const disposition = headers["content-disposition"] || "";
    const nameMatch = disposition.match(/name="([^"]*)"/);
    const filenameMatch = disposition.match(/filename="([^"]*)"/);
    if (nameMatch?.[1]) {
      parts.push({
        name: nameMatch[1],
        filename: filenameMatch?.[1],
        contentType: headers["content-type"],
        data: Buffer.from(data)
      });
    }
    pos = nextBoundary + boundaryBuf.length;
  }
  return parts;
};
var extractBoundary = (contentType) => {
  const match = contentType.match(/boundary=(?:"([^"]+)"|([^;\s]+))/);
  return match ? match[1] ?? match[2] ?? null : null;
};
var getContentType = (contentTypeHeader) => {
  if (!contentTypeHeader)
    return "";
  return contentTypeHeader.split(";")[0]?.trim().toLowerCase() ?? "";
};
var isJsonContent = (contentType) => {
  const ct = getContentType(contentType);
  return ct === "application/json" || ct.endsWith("+json");
};
var isFormContent = (contentType) => {
  return getContentType(contentType) === "application/x-www-form-urlencoded";
};
var isMultipartContent = (contentType) => {
  return getContentType(contentType).startsWith("multipart/");
};
// src/bodyLimit.ts
import { response as response2 } from "@sylphx/gust-core";
var DEFAULT_MAX_SIZE = 1024 * 1024;
var parseSize = (size) => {
  if (typeof size === "number")
    return size;
  const match = size.toLowerCase().match(/^(\d+(?:\.\d+)?)\s*(b|kb|mb|gb)?$/);
  if (!match?.[1])
    return DEFAULT_MAX_SIZE;
  const num = parseFloat(match[1]);
  const unit = match[2] || "b";
  const multipliers = {
    b: 1,
    kb: 1024,
    mb: 1024 * 1024,
    gb: 1024 * 1024 * 1024
  };
  return Math.floor(num * multipliers[unit]);
};
var formatSize = (bytes) => {
  if (bytes < 1024)
    return `${bytes}B`;
  if (bytes < 1024 * 1024)
    return `${(bytes / 1024).toFixed(1)}KB`;
  if (bytes < 1024 * 1024 * 1024)
    return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;
  return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)}GB`;
};
var bodyLimit = (options = {}) => {
  const maxSize = options.maxSize ?? DEFAULT_MAX_SIZE;
  const skip = options.skip;
  const onLimit = options.onLimit ?? ((_, size) => response2(JSON.stringify({
    error: "Payload Too Large",
    message: `Body exceeds ${formatSize(maxSize)} limit`,
    received: formatSize(size)
  }), {
    status: 413,
    headers: { "content-type": "application/json" }
  }));
  return (handler) => {
    return async (ctx) => {
      if (skip?.(ctx)) {
        return handler(ctx);
      }
      const contentLength = ctx.headers["content-length"];
      if (contentLength) {
        const size = parseInt(contentLength, 10);
        if (!Number.isNaN(size) && size > maxSize) {
          return onLimit(ctx, size);
        }
      }
      if (ctx.body && ctx.body.length > maxSize) {
        return onLimit(ctx, ctx.body.length);
      }
      return handler(ctx);
    };
  };
};
var jsonLimit = () => bodyLimit({ maxSize: 100 * 1024 });
var uploadLimit = () => bodyLimit({ maxSize: 10 * 1024 * 1024 });
var largeUploadLimit = () => bodyLimit({ maxSize: 50 * 1024 * 1024 });
// src/cache.ts
import { createHash } from "node:crypto";

class MemoryCache {
  cache = new Map;
  tagIndex = new Map;
  cleanupInterval = null;
  constructor(cleanupMs = 60000) {
    this.cleanupInterval = setInterval(() => {
      const now = Date.now();
      for (const [key, entry] of this.cache) {
        if (entry.timestamp + entry.ttl < now) {
          this.cache.delete(key);
          this.removeFromTagIndex(key, entry.tags);
        }
      }
    }, cleanupMs);
  }
  removeFromTagIndex(key, tags) {
    if (!tags)
      return;
    for (const tag of tags) {
      const keys = this.tagIndex.get(tag);
      if (keys) {
        keys.delete(key);
        if (keys.size === 0) {
          this.tagIndex.delete(tag);
        }
      }
    }
  }
  async get(key) {
    const entry = this.cache.get(key);
    if (!entry)
      return null;
    if (entry.timestamp + entry.ttl < Date.now()) {
      this.cache.delete(key);
      this.removeFromTagIndex(key, entry.tags);
      return null;
    }
    return entry;
  }
  async set(key, entry) {
    const old = this.cache.get(key);
    if (old) {
      this.removeFromTagIndex(key, old.tags);
    }
    this.cache.set(key, entry);
    if (entry.tags) {
      for (const tag of entry.tags) {
        let keys = this.tagIndex.get(tag);
        if (!keys) {
          keys = new Set;
          this.tagIndex.set(tag, keys);
        }
        keys.add(key);
      }
    }
  }
  async delete(key) {
    const entry = this.cache.get(key);
    if (entry) {
      this.removeFromTagIndex(key, entry.tags);
      this.cache.delete(key);
    }
  }
  async deleteByTag(tag) {
    const keys = this.tagIndex.get(tag);
    if (!keys)
      return;
    for (const key of keys) {
      const entry = this.cache.get(key);
      if (entry) {
        this.removeFromTagIndex(key, entry.tags);
        this.cache.delete(key);
      }
    }
    this.tagIndex.delete(tag);
  }
  async clear() {
    this.cache.clear();
    this.tagIndex.clear();
  }
  stats() {
    return {
      size: this.cache.size,
      tags: this.tagIndex.size
    };
  }
  close() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }
}

class LRUCache {
  cache = new Map;
  maxSize;
  constructor(maxSize = 1000) {
    this.maxSize = maxSize;
  }
  async get(key) {
    const entry = this.cache.get(key);
    if (!entry)
      return null;
    if (entry.timestamp + entry.ttl < Date.now()) {
      this.cache.delete(key);
      return null;
    }
    this.cache.delete(key);
    this.cache.set(key, entry);
    return entry;
  }
  async set(key, entry) {
    this.cache.delete(key);
    if (this.cache.size >= this.maxSize) {
      const oldest = this.cache.keys().next().value;
      if (oldest)
        this.cache.delete(oldest);
    }
    this.cache.set(key, entry);
  }
  async delete(key) {
    this.cache.delete(key);
  }
  async clear() {
    this.cache.clear();
  }
  stats() {
    return { size: this.cache.size, maxSize: this.maxSize };
  }
}
var defaultCacheKey = (ctx) => {
  const data = `${ctx.method}:${ctx.path}:${ctx.query || ""}`;
  return createHash("sha256").update(data).digest("hex").slice(0, 16);
};
var varyingCacheKey = (headers) => (ctx) => {
  const headerValues = headers.map((h) => ctx.headers[h.toLowerCase()] || "").join(":");
  const data = `${ctx.method}:${ctx.path}:${ctx.query || ""}:${headerValues}`;
  return createHash("sha256").update(data).digest("hex").slice(0, 16);
};
var DEFAULT_METHODS = ["GET", "HEAD"];
var DEFAULT_STATUS_CODES = [200];
var DEFAULT_TTL = 5 * 60 * 1000;
var defaultStore = null;
var getDefaultStore = () => {
  if (!defaultStore) {
    defaultStore = new MemoryCache;
  }
  return defaultStore;
};
var cache = (options = {}) => {
  const {
    store = getDefaultStore(),
    ttl = DEFAULT_TTL,
    key: keyGen = defaultCacheKey,
    skip,
    skipResponse,
    tags,
    methods = DEFAULT_METHODS,
    statusCodes = DEFAULT_STATUS_CODES,
    cacheControl = true,
    staleWhileRevalidate
  } = options;
  const methodSet = new Set(methods.map((m) => m.toUpperCase()));
  const statusSet = new Set(statusCodes);
  return (handler) => {
    return async (ctx) => {
      if (!methodSet.has(ctx.method.toUpperCase())) {
        return handler(ctx);
      }
      if (skip?.(ctx)) {
        return handler(ctx);
      }
      const cacheKey = keyGen(ctx);
      const cached = await store.get(cacheKey);
      if (cached) {
        const age = Math.floor((Date.now() - cached.timestamp) / 1000);
        const maxAge = Math.floor(cached.ttl / 1000);
        const headers2 = {
          ...cached.response.headers,
          "x-cache": "HIT",
          "x-cache-age": String(age)
        };
        if (cacheControl) {
          headers2["cache-control"] = `public, max-age=${maxAge - age}`;
        }
        return { ...cached.response, headers: headers2 };
      }
      const res = await handler(ctx);
      if (!statusSet.has(res.status)) {
        return res;
      }
      if (skipResponse?.(res)) {
        return res;
      }
      const entry = {
        response: res,
        timestamp: Date.now(),
        key: cacheKey,
        ttl,
        tags: tags?.(ctx)
      };
      store.set(cacheKey, entry);
      const headers = {
        ...res.headers,
        "x-cache": "MISS"
      };
      if (cacheControl) {
        let cc = `public, max-age=${Math.floor(ttl / 1000)}`;
        if (staleWhileRevalidate) {
          cc += `, stale-while-revalidate=${Math.floor(staleWhileRevalidate / 1000)}`;
        }
        headers["cache-control"] = cc;
      }
      return { ...res, headers };
    };
  };
};
var invalidateCache = async (store, keyOrTag, isTag = false) => {
  if (isTag && store.deleteByTag) {
    await store.deleteByTag(keyOrTag);
  } else {
    await store.delete(keyOrTag);
  }
};
var noCache = () => {
  return (handler) => {
    return async (ctx) => {
      const res = await handler(ctx);
      return {
        ...res,
        headers: {
          ...res.headers,
          "cache-control": "no-store, no-cache, must-revalidate, proxy-revalidate",
          pragma: "no-cache",
          expires: "0"
        }
      };
    };
  };
};
var etag = () => {
  return (handler) => {
    return async (ctx) => {
      const res = await handler(ctx);
      if (!res.body || res.headers.etag || typeof res.body === "object" && Symbol.asyncIterator in res.body) {
        return res;
      }
      const hash = createHash("md5").update(typeof res.body === "string" ? res.body : res.body).digest("hex");
      const etagValue = `"${hash}"`;
      const ifNoneMatch = ctx.headers["if-none-match"];
      if (ifNoneMatch === etagValue) {
        return {
          status: 304,
          headers: { etag: etagValue },
          body: null
        };
      }
      return {
        ...res,
        headers: {
          ...res.headers,
          etag: etagValue
        }
      };
    };
  };
};
// src/circuitBreaker.ts
init_native();
import { EventEmitter } from "node:events";
import { response as response3 } from "@sylphx/gust-core";

class CircuitBreaker extends EventEmitter {
  native = null;
  state = "closed";
  failures = [];
  successes = 0;
  lastFailure = null;
  lastSuccess = null;
  totalRequests = 0;
  totalFailures = 0;
  totalSuccesses = 0;
  nextAttempt = 0;
  failureThreshold;
  successThreshold;
  resetTimeout;
  failureWindow;
  timeout;
  name;
  constructor(options = {}) {
    super();
    this.failureThreshold = options.failureThreshold ?? 5;
    this.successThreshold = options.successThreshold ?? 2;
    this.resetTimeout = options.resetTimeout ?? 30000;
    this.failureWindow = options.failureWindow ?? 60000;
    this.timeout = options.timeout ?? 1e4;
    this.name = options.name ?? "default";
    const nativeConfig = {
      failureThreshold: this.failureThreshold,
      successThreshold: this.successThreshold,
      resetTimeoutMs: this.resetTimeout,
      failureWindowMs: this.failureWindow,
      timeoutMs: this.timeout,
      name: this.name
    };
    this.native = createNativeCircuitBreaker(nativeConfig);
  }
  get isNative() {
    return this.native !== null;
  }
  getState() {
    if (this.native) {
      return this.native.state();
    }
    return this.state;
  }
  getStats() {
    if (this.native) {
      const stats = this.native.stats();
      return {
        state: stats.state,
        failures: stats.failures,
        successes: stats.successes,
        lastFailure: this.lastFailure,
        lastSuccess: this.lastSuccess,
        totalRequests: stats.totalRequests,
        totalFailures: stats.totalFailures,
        totalSuccesses: stats.totalSuccesses
      };
    }
    return {
      state: this.state,
      failures: this.failures.length,
      successes: this.successes,
      lastFailure: this.lastFailure,
      lastSuccess: this.lastSuccess,
      totalRequests: this.totalRequests,
      totalFailures: this.totalFailures,
      totalSuccesses: this.totalSuccesses
    };
  }
  canRequest() {
    if (this.native) {
      return this.native.canRequest();
    }
    if (this.state === "closed")
      return true;
    if (this.state === "open") {
      if (Date.now() >= this.nextAttempt) {
        this.toHalfOpen();
        return true;
      }
      return false;
    }
    return true;
  }
  recordSuccess() {
    if (this.native) {
      this.native.recordSuccess();
      this.lastSuccess = Date.now();
      return;
    }
    this.totalRequests++;
    this.totalSuccesses++;
    this.lastSuccess = Date.now();
    if (this.state === "half-open") {
      this.successes++;
      if (this.successes >= this.successThreshold) {
        this.toClosed();
      }
    }
  }
  recordFailure() {
    if (this.native) {
      this.native.recordFailure();
      this.lastFailure = Date.now();
      return;
    }
    this.totalRequests++;
    this.totalFailures++;
    this.lastFailure = Date.now();
    if (this.state === "half-open") {
      this.toOpen();
      return;
    }
    if (this.state === "closed") {
      this.failures.push(Date.now());
      const windowStart = Date.now() - this.failureWindow;
      this.failures = this.failures.filter((t) => t > windowStart);
      if (this.failures.length >= this.failureThreshold) {
        this.toOpen();
      }
    }
  }
  open() {
    this.toOpen();
  }
  close() {
    this.toClosed();
  }
  reset() {
    if (this.native) {
      this.native.reset();
      this.emit("reset", this.name);
      return;
    }
    this.state = "closed";
    this.failures = [];
    this.successes = 0;
    this.nextAttempt = 0;
    this.emit("reset", this.name);
  }
  toOpen() {
    if (this.state !== "open") {
      this.state = "open";
      this.nextAttempt = Date.now() + this.resetTimeout;
      this.successes = 0;
      this.emit("open", this.name);
    }
  }
  toHalfOpen() {
    if (this.state !== "half-open") {
      this.state = "half-open";
      this.successes = 0;
      this.emit("half-open", this.name);
    }
  }
  toClosed() {
    if (this.state !== "closed") {
      this.state = "closed";
      this.failures = [];
      this.successes = 0;
      this.emit("close", this.name);
    }
  }
}
var circuitBreaker = (options = {}) => {
  const {
    timeout = 1e4,
    fallback,
    isFailure = (res) => res.status >= 500,
    onStateChange
  } = options;
  const breaker = new CircuitBreaker(options);
  if (onStateChange) {
    breaker.on("open", (name) => onStateChange("open", name));
    breaker.on("half-open", (name) => onStateChange("half-open", name));
    breaker.on("close", (name) => onStateChange("closed", name));
  }
  const defaultFallback = () => response3(JSON.stringify({
    error: "Service Unavailable",
    message: "Circuit breaker is open"
  }), {
    status: 503,
    headers: {
      "content-type": "application/json",
      "retry-after": String(Math.ceil((options.resetTimeout ?? 30000) / 1000))
    }
  });
  return (handler) => {
    return async (ctx) => {
      if (!breaker.canRequest()) {
        if (fallback) {
          return fallback(ctx, new Error("Circuit breaker is open"));
        }
        return defaultFallback();
      }
      try {
        const result = await Promise.race([
          handler(ctx),
          new Promise((_, reject) => setTimeout(() => reject(new Error("Request timeout")), timeout))
        ]);
        if (isFailure(result)) {
          breaker.recordFailure();
        } else {
          breaker.recordSuccess();
        }
        return result;
      } catch (error) {
        breaker.recordFailure();
        if (fallback) {
          return fallback(ctx, error);
        }
        return response3(JSON.stringify({
          error: "Service Unavailable",
          message: error.message
        }), {
          status: 503,
          headers: { "content-type": "application/json" }
        });
      }
    };
  };
};
var breakers = new Map;
var getCircuitBreaker = (name, options) => {
  let breaker = breakers.get(name);
  if (!breaker) {
    breaker = new CircuitBreaker({ ...options, name });
    breakers.set(name, breaker);
  }
  return breaker;
};
var withCircuitBreaker = (fn, options = {}) => {
  const breaker = new CircuitBreaker(options);
  return async (...args) => {
    if (!breaker.canRequest()) {
      throw new Error("Circuit breaker is open");
    }
    try {
      const result = await fn(...args);
      breaker.recordSuccess();
      return result;
    } catch (error) {
      breaker.recordFailure();
      throw error;
    }
  };
};
var bulkhead = (options = {}) => {
  const { maxConcurrent = 10, maxQueue = 100, queueTimeout = 30000, onReject } = options;
  const nativeConfig = {
    maxConcurrent,
    maxQueue,
    queueTimeoutMs: queueTimeout
  };
  const nativeBulkhead = createNativeBulkhead(nativeConfig);
  let running = 0;
  const queue = [];
  const rejectResponse = onReject ?? (() => response3(JSON.stringify({
    error: "Service Unavailable",
    message: "Too many concurrent requests"
  }), {
    status: 503,
    headers: {
      "content-type": "application/json",
      "retry-after": "5"
    }
  }));
  const acquire = () => {
    if (nativeBulkhead) {
      if (nativeBulkhead.tryAcquire()) {
        return Promise.resolve();
      }
      return Promise.reject(new Error("Queue full"));
    }
    if (running < maxConcurrent) {
      running++;
      return Promise.resolve();
    }
    if (queue.length >= maxQueue) {
      return Promise.reject(new Error("Queue full"));
    }
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        const idx = queue.findIndex((q) => q.resolve === resolve);
        if (idx !== -1)
          queue.splice(idx, 1);
        reject(new Error("Queue timeout"));
      }, queueTimeout);
      queue.push({ resolve, reject, timer });
    });
  };
  const release = () => {
    if (nativeBulkhead)
      return;
    running--;
    const next = queue.shift();
    if (next) {
      clearTimeout(next.timer);
      running++;
      next.resolve();
    }
  };
  return (handler) => {
    return async (ctx) => {
      try {
        await acquire();
      } catch {
        return rejectResponse(ctx);
      }
      try {
        return await handler(ctx);
      } finally {
        release();
      }
    };
  };
};
// src/cluster.ts
init_native();
import cluster from "node:cluster";
import { EventEmitter as EventEmitter2 } from "node:events";
import { cpus } from "node:os";
var getOptimalWorkerCount = () => {
  const nativeRecommended = isNativeAvailable() ? getRecommendedWorkers() : 0;
  if (nativeRecommended > 0)
    return nativeRecommended;
  return Math.min(cpus().length, 8);
};

class ClusterManager extends EventEmitter2 {
  workers = new Map;
  restartCounts = new Map;
  isShuttingDown = false;
  readyWorkers = 0;
  workerCount;
  autoRestart;
  maxRestarts;
  shutdownTimeout;
  constructor(options = {}) {
    super();
    this.workerCount = options.workers ?? getOptimalWorkerCount();
    this.autoRestart = options.autoRestart ?? true;
    this.maxRestarts = options.maxRestarts ?? 5;
    this.shutdownTimeout = options.shutdownTimeout ?? 30000;
    if (options.onWorkerStart)
      this.on("worker:start", options.onWorkerStart);
    if (options.onWorkerExit)
      this.on("worker:exit", options.onWorkerExit);
    if (options.onReady)
      this.on("ready", options.onReady);
    if (options.onRestart)
      this.on("restart", options.onRestart);
    if (options.onScale)
      this.on("scale", options.onScale);
  }
  start() {
    if (!cluster.isPrimary) {
      throw new Error("ClusterManager.start() can only be called from the primary process");
    }
    for (let i = 0;i < this.workerCount; i++) {
      this.forkWorker();
    }
    cluster.on("message", (_worker, message) => {
      if (message === "ready") {
        this.readyWorkers++;
        if (this.readyWorkers === this.workerCount) {
          this.emit("ready");
        }
      }
    });
    cluster.on("exit", (worker, code, signal) => {
      this.workers.delete(worker.id);
      this.emit("worker:exit", worker, code, signal);
      if (!this.isShuttingDown && this.autoRestart) {
        this.maybeRestart(worker.id);
      }
    });
    const shutdown = () => this.shutdown();
    process.on("SIGTERM", shutdown);
    process.on("SIGINT", shutdown);
  }
  forkWorker() {
    const worker = cluster.fork();
    this.workers.set(worker.id, worker);
    this.emit("worker:start", worker);
    return worker;
  }
  maybeRestart(workerId) {
    const now = Date.now();
    const minute = 60000;
    let restarts = this.restartCounts.get(workerId) || [];
    restarts = restarts.filter((t) => t > now - minute);
    if (restarts.length >= this.maxRestarts) {
      console.error(`Worker ${workerId} exceeded max restarts (${this.maxRestarts}/min), not restarting`);
      return;
    }
    restarts.push(now);
    this.restartCounts.set(workerId, restarts);
    console.log(`Restarting worker ${workerId}...`);
    this.forkWorker();
  }
  async shutdown() {
    if (this.isShuttingDown)
      return;
    this.isShuttingDown = true;
    console.log("Shutting down cluster...");
    for (const worker of this.workers.values()) {
      worker.send("shutdown");
    }
    const deadline = Date.now() + this.shutdownTimeout;
    while (this.workers.size > 0 && Date.now() < deadline) {
      await new Promise((r) => setTimeout(r, 100));
    }
    for (const worker of this.workers.values()) {
      worker.kill("SIGKILL");
    }
    this.emit("shutdown");
    process.exit(0);
  }
  info() {
    return {
      workers: this.workers.size,
      pids: Array.from(this.workers.values()).map((w) => w.process.pid).filter((pid) => pid !== undefined)
    };
  }
  broadcast(message) {
    for (const worker of this.workers.values()) {
      worker.send(message);
    }
  }
  sendTo(workerId, message) {
    const worker = this.workers.get(workerId);
    if (!worker)
      return false;
    worker.send(message);
    return true;
  }
  async rollingRestart() {
    if (this.isShuttingDown)
      return;
    console.log("Starting rolling restart...");
    const workerIds = Array.from(this.workers.keys());
    for (const workerId of workerIds) {
      const oldWorker = this.workers.get(workerId);
      if (!oldWorker)
        continue;
      const newWorker = cluster.fork();
      this.workers.set(newWorker.id, newWorker);
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error("New worker failed to become ready"));
        }, 30000);
        const onMessage = (msg) => {
          if (msg === "ready") {
            clearTimeout(timeout);
            newWorker.off("message", onMessage);
            resolve();
          }
        };
        newWorker.on("message", onMessage);
      });
      oldWorker.send("shutdown");
      await new Promise((resolve) => {
        const timeout = setTimeout(() => {
          oldWorker.kill("SIGKILL");
          resolve();
        }, 1e4);
        oldWorker.on("exit", () => {
          clearTimeout(timeout);
          resolve();
        });
      });
      this.workers.delete(workerId);
      console.log(`Worker ${workerId} replaced with ${newWorker.id}`);
    }
    console.log("Rolling restart complete");
    this.emit("restart");
  }
  scaleUp(count = 1) {
    for (let i = 0;i < count; i++) {
      this.forkWorker();
    }
    console.log(`Scaled up by ${count} workers (total: ${this.workers.size})`);
    this.emit("scale", this.workers.size);
  }
  async scaleDown(count = 1) {
    const workerIds = Array.from(this.workers.keys()).slice(0, count);
    for (const workerId of workerIds) {
      const worker = this.workers.get(workerId);
      if (!worker)
        continue;
      worker.send("shutdown");
      await new Promise((resolve) => {
        const timeout = setTimeout(() => {
          worker.kill("SIGKILL");
          resolve();
        }, 1e4);
        worker.on("exit", () => {
          clearTimeout(timeout);
          resolve();
        });
      });
      this.workers.delete(workerId);
    }
    console.log(`Scaled down by ${count} workers (total: ${this.workers.size})`);
    this.emit("scale", this.workers.size);
  }
  async setWorkerCount(count) {
    const current = this.workers.size;
    if (count > current) {
      this.scaleUp(count - current);
    } else if (count < current) {
      await this.scaleDown(current - count);
    }
  }
}
var getClusterInfo = () => ({
  isMaster: cluster.isPrimary,
  workerId: cluster.isPrimary ? 0 : cluster.worker?.id ?? 0,
  workerCount: cluster.isPrimary ? Object.keys(cluster.workers || {}).length : 0,
  pid: process.pid
});
var isCluster = () => !!cluster.worker;
var isPrimary = () => cluster.isPrimary;
var isWorker = () => !!cluster.worker;
var clusterServe = async (options, serverFn) => {
  const {
    workers,
    autoRestart,
    maxRestarts,
    shutdownTimeout,
    onWorkerStart,
    onWorkerExit,
    onReady,
    ...serveOptions
  } = options;
  if (cluster.isPrimary) {
    const manager = new ClusterManager({
      workers,
      autoRestart,
      maxRestarts,
      shutdownTimeout,
      onWorkerStart,
      onWorkerExit,
      onReady
    });
    manager.start();
    return manager;
  } else {
    const { serve: serve2 } = await Promise.resolve().then(() => (init_serve(), exports_serve));
    const server = serverFn ? await serverFn() : await serve2(serveOptions);
    process.send?.("ready");
    process.on("message", async (msg) => {
      if (msg === "shutdown") {
        await server.shutdown();
        process.exit(0);
      }
    });
    return server;
  }
};
var runCluster = (workerFn, options = {}) => {
  if (cluster.isPrimary) {
    const manager = new ClusterManager(options);
    manager.start();
  } else {
    Promise.resolve(workerFn()).catch((err) => {
      console.error("Worker error:", err);
      process.exit(1);
    });
  }
};
var stickySession = (ip, workerCount) => {
  let hash = 0;
  for (let i = 0;i < ip.length; i++) {
    hash = (hash << 5) - hash + ip.charCodeAt(i) | 0;
  }
  return Math.abs(hash) % workerCount;
};
// src/compress.ts
import { brotliCompressSync, constants, deflateSync, gzipSync } from "node:zlib";
var DEFAULT_COMPRESSIBLE_TYPES = [
  "text/html",
  "text/plain",
  "text/css",
  "text/javascript",
  "text/xml",
  "application/json",
  "application/javascript",
  "application/xml",
  "application/xhtml+xml",
  "application/rss+xml",
  "application/atom+xml",
  "image/svg+xml"
];
var isCompressible = (contentType, allowedTypes) => {
  if (!contentType)
    return false;
  const mimeType = contentType.split(";")[0]?.trim().toLowerCase() ?? "";
  return allowedTypes.some((type) => {
    if (type.endsWith("/*")) {
      return mimeType.startsWith(type.slice(0, -1));
    }
    return mimeType === type;
  });
};
var selectEncoding = (acceptEncoding, supportedEncodings) => {
  if (!acceptEncoding)
    return null;
  const encodings = acceptEncoding.split(",").map((e) => {
    const parts = e.trim().split(";q=");
    const name = parts[0]?.trim().toLowerCase() ?? "";
    const qValue = parts[1];
    return {
      name,
      q: qValue ? parseFloat(qValue) : 1
    };
  }).filter((e) => e.q > 0 && e.name).sort((a, b) => b.q - a.q);
  for (const { name } of encodings) {
    if (name === "br" && supportedEncodings.includes("br"))
      return "br";
    if (name === "gzip" && supportedEncodings.includes("gzip"))
      return "gzip";
    if (name === "deflate" && supportedEncodings.includes("deflate"))
      return "deflate";
    if (name === "*") {
      return supportedEncodings[0] || null;
    }
  }
  return null;
};
var compressData = (data, encoding, level) => {
  switch (encoding) {
    case "br":
      return brotliCompressSync(data, {
        params: {
          [constants.BROTLI_PARAM_QUALITY]: Math.min(level, 11)
        }
      });
    case "gzip":
      return gzipSync(data, { level });
    case "deflate":
      return deflateSync(data, { level });
  }
};
var compress = (options = {}) => {
  const {
    threshold = 1024,
    level = 6,
    encodings = ["br", "gzip", "deflate"],
    mimeTypes = DEFAULT_COMPRESSIBLE_TYPES
  } = options;
  return (handler) => async (ctx) => {
    const response4 = await handler(ctx);
    if (response4.body === null) {
      return response4;
    }
    if (typeof response4.body === "object" && Symbol.asyncIterator in response4.body) {
      return response4;
    }
    if (response4.headers["content-encoding"]) {
      return response4;
    }
    const contentType = response4.headers["content-type"];
    if (!isCompressible(contentType, mimeTypes)) {
      return response4;
    }
    const bodyBuffer = Buffer.from(response4.body);
    if (bodyBuffer.length < threshold) {
      return response4;
    }
    const acceptEncoding = ctx.headers["accept-encoding"] || "";
    const encoding = selectEncoding(acceptEncoding, encodings);
    if (!encoding) {
      return response4;
    }
    try {
      const compressed = compressData(bodyBuffer, encoding, level);
      if (compressed.length >= bodyBuffer.length) {
        return response4;
      }
      return {
        ...response4,
        body: compressed,
        headers: {
          ...response4.headers,
          "content-encoding": encoding,
          "content-length": compressed.length.toString(),
          vary: response4.headers.vary ? `${response4.headers.vary}, Accept-Encoding` : "Accept-Encoding"
        }
      };
    } catch {
      return response4;
    }
  };
};
var gzip = (level = 6) => compress({ encodings: ["gzip"], level });
var brotli = (level = 6) => compress({ encodings: ["br"], level });

// src/index.ts
init_context();

// src/cookie.ts
var parseCookies = (cookieHeader) => {
  const cookies = {};
  if (!cookieHeader)
    return cookies;
  const pairs = cookieHeader.split(";");
  for (const pair of pairs) {
    const trimmed = pair.trim();
    const eqIndex = trimmed.indexOf("=");
    if (eqIndex > 0) {
      const name = trimmed.substring(0, eqIndex).trim();
      let value = trimmed.substring(eqIndex + 1).trim();
      if (value.startsWith('"') && value.endsWith('"')) {
        value = value.slice(1, -1);
      }
      try {
        cookies[name] = decodeURIComponent(value);
      } catch {
        cookies[name] = value;
      }
    }
  }
  return cookies;
};
var serializeCookie = (name, value, options = {}) => {
  const encodedValue = encodeURIComponent(value);
  let cookie = `${name}=${encodedValue}`;
  if (options.domain) {
    cookie += `; Domain=${options.domain}`;
  }
  if (options.path) {
    cookie += `; Path=${options.path}`;
  }
  if (options.expires) {
    cookie += `; Expires=${options.expires.toUTCString()}`;
  }
  if (options.maxAge !== undefined) {
    cookie += `; Max-Age=${options.maxAge}`;
  }
  if (options.httpOnly) {
    cookie += "; HttpOnly";
  }
  if (options.secure) {
    cookie += "; Secure";
  }
  if (options.sameSite) {
    cookie += `; SameSite=${options.sameSite}`;
  }
  if (options.partitioned) {
    cookie += "; Partitioned";
  }
  return cookie;
};
var deleteCookie = (name, options = {}) => {
  return serializeCookie(name, "", {
    ...options,
    expires: new Date(0),
    maxAge: 0
  });
};
var getCookies = (headers) => {
  return parseCookies(headers.cookie || "");
};
var getCookie = (headers, name) => {
  const cookies = getCookies(headers);
  return cookies[name];
};
var setCookie = (name, value, options) => {
  return serializeCookie(name, value, options);
};
var setCookies = (cookies) => {
  return cookies.map((cookie) => serializeCookie(cookie.name, cookie.value, cookie));
};
// src/cors.ts
import { response as response4 } from "@sylphx/gust-core";
var DEFAULT_METHODS2 = ["GET", "HEAD", "PUT", "PATCH", "POST", "DELETE"];
var DEFAULT_ALLOWED_HEADERS = ["Content-Type", "Authorization", "X-Requested-With"];
var isOriginAllowed = (origin, allowed) => {
  if (!allowed)
    return true;
  if (allowed === "*")
    return true;
  if (typeof allowed === "string")
    return origin === allowed;
  if (Array.isArray(allowed))
    return allowed.includes(origin);
  if (typeof allowed === "function")
    return allowed(origin);
  return false;
};
var getAllowedOrigin = (origin, allowed) => {
  if (!allowed)
    return "*";
  if (allowed === "*")
    return "*";
  if (isOriginAllowed(origin, allowed))
    return origin;
  return "";
};
var createCorsHeaders = (origin, options) => {
  const headers = {};
  const allowedOrigin = getAllowedOrigin(origin, options.origin);
  if (allowedOrigin) {
    headers["access-control-allow-origin"] = allowedOrigin;
  }
  if (options.credentials) {
    headers["access-control-allow-credentials"] = "true";
  }
  if (options.exposedHeaders && options.exposedHeaders.length > 0) {
    headers["access-control-expose-headers"] = options.exposedHeaders.join(", ");
  }
  if (allowedOrigin && allowedOrigin !== "*") {
    headers.vary = "Origin";
  }
  return headers;
};
var createPreflightHeaders = (origin, options) => {
  const headers = createCorsHeaders(origin, options);
  const methods = options.methods || DEFAULT_METHODS2;
  headers["access-control-allow-methods"] = methods.join(", ");
  const allowedHeaders = options.allowedHeaders || DEFAULT_ALLOWED_HEADERS;
  headers["access-control-allow-headers"] = allowedHeaders.join(", ");
  if (options.maxAge !== undefined) {
    headers["access-control-max-age"] = options.maxAge.toString();
  }
  return headers;
};
var cors = (options = {}) => {
  const handlePreflight = options.preflight !== false;
  return (handler) => async (ctx) => {
    const origin = ctx.headers.origin || "";
    if (handlePreflight && ctx.method === "OPTIONS") {
      const requestMethod = ctx.headers["access-control-request-method"];
      if (requestMethod) {
        const preflightHeaders = createPreflightHeaders(origin, options);
        return response4(null, {
          status: 204,
          headers: preflightHeaders
        });
      }
    }
    const res = await handler(ctx);
    const corsHeaders = createCorsHeaders(origin, options);
    const mergedHeaders = { ...res.headers, ...corsHeaders };
    return {
      ...res,
      headers: mergedHeaders
    };
  };
};
var simpleCors = () => cors({
  origin: "*",
  methods: DEFAULT_METHODS2,
  allowedHeaders: DEFAULT_ALLOWED_HEADERS
});
// src/csrf.ts
import { createHmac as createHmac2, timingSafeEqual as timingSafeEqual2 } from "node:crypto";
import { forbidden } from "@sylphx/gust-core";
init_native();
var generateRandomBase64url = (byteLength) => {
  const bytesNeeded = byteLength;
  const traceIdsNeeded = Math.ceil(bytesNeeded / 16);
  let hexString = "";
  for (let i = 0;i < traceIdsNeeded; i++) {
    const traceId = nativeGenerateTraceId();
    if (!traceId)
      throw new Error("Native trace ID generation unavailable");
    hexString += traceId;
  }
  const bytes = Buffer.from(hexString.slice(0, byteLength * 2), "hex");
  return bytes.toString("base64url");
};
var generateCsrfSecret = (length = 32) => {
  return generateRandomBase64url(length);
};
var generateCsrfToken = (secret, salt) => {
  const tokenSalt = salt || generateRandomBase64url(8);
  const hash = createHmac2("sha256", secret).update(tokenSalt).digest("base64url");
  return `${tokenSalt}.${hash}`;
};
var verifyCsrfToken = (token, secret) => {
  const dotIndex = token.indexOf(".");
  if (dotIndex === -1)
    return false;
  const salt = token.slice(0, dotIndex);
  const hash = token.slice(dotIndex + 1);
  const expected = createHmac2("sha256", secret).update(salt).digest("base64url");
  const hashBuf = Buffer.from(hash);
  const expectedBuf = Buffer.from(expected);
  if (hashBuf.length !== expectedBuf.length)
    return false;
  return timingSafeEqual2(hashBuf, expectedBuf);
};
var csrfTokenMap = new WeakMap;
var csrfSecretMap = new WeakMap;
var getCsrfToken = (ctx) => {
  return csrfTokenMap.get(ctx);
};
var DEFAULT_METHODS3 = ["POST", "PUT", "PATCH", "DELETE"];
var csrf = (options) => {
  const {
    secret: _secret,
    cookie = "_csrf",
    header = "x-csrf-token",
    field = "_csrf",
    tokenLength = 32,
    cookieOptions = {},
    methods = DEFAULT_METHODS3,
    skip,
    onError
  } = options;
  const headerLower = header.toLowerCase();
  const methodSet = new Set(methods.map((m) => m.toUpperCase()));
  const errorResponse = onError ?? (() => forbidden("Invalid CSRF token"));
  const finalCookieOptions = {
    httpOnly: true,
    sameSite: "Strict",
    path: "/",
    ...cookieOptions
  };
  return (handler) => {
    return async (ctx) => {
      if (skip?.(ctx)) {
        return handler(ctx);
      }
      const cookies = parseCookies(ctx.headers.cookie || "");
      let csrfSecret = cookies[cookie];
      let secretIsNew = false;
      if (!csrfSecret) {
        csrfSecret = generateCsrfSecret(tokenLength);
        secretIsNew = true;
      }
      const token = generateCsrfToken(csrfSecret);
      csrfTokenMap.set(ctx, token);
      csrfSecretMap.set(ctx, csrfSecret);
      if (methodSet.has(ctx.method.toUpperCase())) {
        let submittedToken = ctx.headers[headerLower];
        if (!submittedToken && ctx.body) {
          const bodyStr = ctx.body.toString();
          const match = bodyStr.match(new RegExp(`${field}=([^&]+)`));
          if (match?.[1]) {
            submittedToken = decodeURIComponent(match[1]);
          }
        }
        if (!submittedToken || !verifyCsrfToken(submittedToken, csrfSecret)) {
          return errorResponse(ctx);
        }
      }
      const res = await handler(ctx);
      if (secretIsNew) {
        const setCookie2 = serializeCookie(cookie, csrfSecret, finalCookieOptions);
        return {
          ...res,
          headers: {
            ...res.headers,
            "set-cookie": setCookie2
          }
        };
      }
      return res;
    };
  };
};
var csrfDoubleSubmit = (options = {}) => {
  const {
    cookie = "_csrf",
    header = "x-csrf-token",
    tokenLength = 32,
    cookieOptions = {},
    methods = DEFAULT_METHODS3,
    skip,
    onError
  } = options;
  const headerLower = header.toLowerCase();
  const methodSet = new Set(methods.map((m) => m.toUpperCase()));
  const errorResponse = onError ?? (() => forbidden("Invalid CSRF token"));
  const finalCookieOptions = {
    httpOnly: false,
    sameSite: "Strict",
    path: "/",
    ...cookieOptions
  };
  return (handler) => {
    return async (ctx) => {
      if (skip?.(ctx)) {
        return handler(ctx);
      }
      const cookies = parseCookies(ctx.headers.cookie || "");
      let csrfToken = cookies[cookie];
      let tokenIsNew = false;
      if (!csrfToken) {
        csrfToken = generateRandomBase64url(tokenLength);
        tokenIsNew = true;
      }
      csrfTokenMap.set(ctx, csrfToken);
      if (methodSet.has(ctx.method.toUpperCase())) {
        const headerToken = ctx.headers[headerLower];
        if (!headerToken || headerToken !== csrfToken) {
          return errorResponse(ctx);
        }
      }
      const res = await handler(ctx);
      if (tokenIsNew) {
        const setCookie2 = serializeCookie(cookie, csrfToken, finalCookieOptions);
        return {
          ...res,
          headers: {
            ...res.headers,
            "set-cookie": setCookie2
          }
        };
      }
      return res;
    };
  };
};
var csrfField = (ctx, fieldName = "_csrf") => {
  const token = getCsrfToken(ctx);
  if (!token)
    return "";
  return `<input type="hidden" name="${fieldName}" value="${token}">`;
};
var csrfMeta = (ctx, name = "csrf-token") => {
  const token = getCsrfToken(ctx);
  if (!token)
    return "";
  return `<meta name="${name}" content="${token}">`;
};
// src/health.ts
import { json, response as response5 } from "@sylphx/gust-core";
var startTime = Date.now();
var runHealthChecks = async (checks) => {
  const results = {};
  let hasCriticalFailure = false;
  let hasDegradation = false;
  await Promise.all(checks.map(async (check) => {
    const start = performance.now();
    const timeout = check.timeout ?? 5000;
    try {
      const checkPromise = Promise.resolve(check.check());
      const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), timeout));
      const passed = await Promise.race([checkPromise, timeoutPromise]);
      const duration = performance.now() - start;
      results[check.name] = {
        status: passed ? "pass" : "fail",
        duration: Math.round(duration * 100) / 100
      };
      if (!passed) {
        if (check.critical !== false) {
          hasCriticalFailure = true;
        } else {
          hasDegradation = true;
        }
      }
    } catch (error) {
      const duration = performance.now() - start;
      results[check.name] = {
        status: "fail",
        duration: Math.round(duration * 100) / 100,
        message: error.message
      };
      if (check.critical !== false) {
        hasCriticalFailure = true;
      } else {
        hasDegradation = true;
      }
    }
  }));
  return {
    status: hasCriticalFailure ? "unhealthy" : hasDegradation ? "degraded" : "healthy",
    checks: results,
    timestamp: new Date().toISOString(),
    uptime: Math.floor((Date.now() - startTime) / 1000)
  };
};
var healthCheck = () => {
  return async () => {
    return json({
      status: "healthy",
      timestamp: new Date().toISOString(),
      uptime: Math.floor((Date.now() - startTime) / 1000)
    });
  };
};
var health = (options = {}) => {
  const { checks = [], detailed = true, onHealthy, onUnhealthy } = options;
  return async () => {
    const result = await runHealthChecks(checks);
    if (!detailed) {
      const statusCode = result.status === "healthy" ? 200 : 503;
      return response5(JSON.stringify({
        status: result.status,
        timestamp: result.timestamp
      }), {
        status: statusCode,
        headers: { "content-type": "application/json" }
      });
    }
    if (result.status === "healthy") {
      if (onHealthy)
        return onHealthy(result);
      return json(result);
    }
    if (onUnhealthy)
      return onUnhealthy(result);
    return json(result, { status: 503 });
  };
};
var liveness = () => {
  return async () => {
    return response5("OK", { status: 200, headers: { "content-type": "text/plain" } });
  };
};
var readiness = (checks = []) => {
  return async () => {
    if (checks.length === 0) {
      return response5("Ready", { status: 200, headers: { "content-type": "text/plain" } });
    }
    const result = await runHealthChecks(checks);
    const statusCode = result.status === "healthy" ? 200 : 503;
    return response5(result.status === "healthy" ? "Ready" : "Not Ready", {
      status: statusCode,
      headers: { "content-type": "text/plain" }
    });
  };
};
var startup = (isReady) => {
  return async () => {
    const ready = await isReady();
    return response5(ready ? "Started" : "Starting", {
      status: ready ? 200 : 503,
      headers: { "content-type": "text/plain" }
    });
  };
};
var memoryCheck = (maxHeapPercent = 90) => ({
  name: "memory",
  check: () => {
    const used = process.memoryUsage();
    const heapPercent = used.heapUsed / used.heapTotal * 100;
    return heapPercent < maxHeapPercent;
  }
});
var eventLoopCheck = (maxLagMs = 100) => ({
  name: "eventLoop",
  check: () => new Promise((resolve) => {
    const start = Date.now();
    setImmediate(() => {
      const lag = Date.now() - start;
      resolve(lag < maxLagMs);
    });
  })
});
var httpCheck = (name, url, expectedStatus = 200) => ({
  name,
  check: async () => {
    try {
      const res = await fetch(url);
      return res.status === expectedStatus;
    } catch {
      return false;
    }
  },
  timeout: 5000
});
var customCheck = (name, check, options = {}) => ({
  name,
  check,
  ...options
});
var getMetrics = () => {
  const memory = process.memoryUsage();
  const cpu = process.cpuUsage();
  return {
    uptime: Math.floor((Date.now() - startTime) / 1000),
    memory: {
      heapUsed: memory.heapUsed,
      heapTotal: memory.heapTotal,
      external: memory.external,
      rss: memory.rss
    },
    cpu: {
      user: cpu.user,
      system: cpu.system
    }
  };
};
var metrics = () => {
  return async () => {
    return json(getMetrics());
  };
};
var prometheusMetrics = (prefix = "app") => {
  return async () => {
    const m = getMetrics();
    const lines = [
      `# HELP ${prefix}_uptime_seconds Server uptime in seconds`,
      `# TYPE ${prefix}_uptime_seconds gauge`,
      `${prefix}_uptime_seconds ${m.uptime}`,
      "",
      `# HELP ${prefix}_memory_heap_used_bytes Heap memory used`,
      `# TYPE ${prefix}_memory_heap_used_bytes gauge`,
      `${prefix}_memory_heap_used_bytes ${m.memory.heapUsed}`,
      "",
      `# HELP ${prefix}_memory_heap_total_bytes Total heap memory`,
      `# TYPE ${prefix}_memory_heap_total_bytes gauge`,
      `${prefix}_memory_heap_total_bytes ${m.memory.heapTotal}`,
      "",
      `# HELP ${prefix}_memory_rss_bytes Resident set size`,
      `# TYPE ${prefix}_memory_rss_bytes gauge`,
      `${prefix}_memory_rss_bytes ${m.memory.rss}`,
      "",
      `# HELP ${prefix}_cpu_user_microseconds CPU user time`,
      `# TYPE ${prefix}_cpu_user_microseconds counter`,
      `${prefix}_cpu_user_microseconds ${m.cpu.user}`,
      "",
      `# HELP ${prefix}_cpu_system_microseconds CPU system time`,
      `# TYPE ${prefix}_cpu_system_microseconds counter`,
      `${prefix}_cpu_system_microseconds ${m.cpu.system}`
    ];
    return response5(lines.join(`
`), {
      status: 200,
      headers: { "content-type": "text/plain; version=0.0.4" }
    });
  };
};
// src/http2.ts
import {
  constants as constants2,
  createServer as createH2Server,
  createSecureServer
} from "node:http2";
import { serverError as serverError2 } from "@sylphx/gust-core";
var {
  HTTP2_HEADER_METHOD,
  HTTP2_HEADER_PATH,
  HTTP2_HEADER_SCHEME,
  HTTP2_HEADER_AUTHORITY,
  HTTP2_HEADER_STATUS,
  HTTP2_HEADER_CONTENT_TYPE,
  HTTP2_HEADER_CONTENT_LENGTH
} = constants2;
var createHttp2Context = async (stream, headers) => {
  const method = headers[HTTP2_HEADER_METHOD] || "GET";
  const fullPath = headers[HTTP2_HEADER_PATH] || "/";
  const authority = headers[HTTP2_HEADER_AUTHORITY] || "";
  const scheme = headers[HTTP2_HEADER_SCHEME] || "https";
  const queryIdx = fullPath.indexOf("?");
  const path = queryIdx >= 0 ? fullPath.slice(0, queryIdx) : fullPath;
  const query = queryIdx >= 0 ? fullPath.slice(queryIdx) : "";
  const headerMap = {};
  for (const [key, value] of Object.entries(headers)) {
    if (!key.startsWith(":") && value !== undefined) {
      headerMap[key] = Array.isArray(value) ? value.join(", ") : value;
    }
  }
  const chunks = [];
  for await (const chunk of stream) {
    chunks.push(chunk);
  }
  const body = Buffer.concat(chunks);
  return {
    method,
    path,
    query,
    headers: headerMap,
    body,
    stream,
    authority,
    scheme
  };
};
var sendResponse2 = async (stream, response6) => {
  if (stream.destroyed || stream.closed)
    return;
  const headers = {
    [HTTP2_HEADER_STATUS]: response6.status
  };
  for (const [key, value] of Object.entries(response6.headers)) {
    headers[key.toLowerCase()] = value;
  }
  const isStreaming = response6.body !== null && typeof response6.body === "object" && Symbol.asyncIterator in response6.body;
  if (isStreaming) {
    stream.respond(headers);
    try {
      for await (const chunk of response6.body) {
        if (stream.destroyed || stream.closed)
          break;
        stream.write(chunk);
      }
    } catch {} finally {
      stream.end();
    }
  } else {
    if (response6.body !== null) {
      const body = response6.body;
      const bodyLen = typeof body === "string" ? Buffer.byteLength(body) : body.length;
      headers[HTTP2_HEADER_CONTENT_LENGTH] = bodyLen;
    }
    stream.respond(headers);
    if (response6.body !== null) {
      stream.end(response6.body);
    } else {
      stream.end();
    }
  }
};
var serveHttp2 = async (options) => {
  const {
    port = options.cert ? 443 : 8443,
    hostname = "0.0.0.0",
    fetch: handler,
    cert,
    key,
    allowHttp1 = true,
    onError,
    maxConcurrentStreams = 100,
    initialWindowSize = 65535,
    maxHeaderListSize = 16384
  } = options;
  const serverOptions = {
    allowHTTP1: allowHttp1,
    settings: {
      maxConcurrentStreams,
      initialWindowSize,
      maxHeaderListSize
    }
  };
  let server;
  if (cert && key) {
    server = createSecureServer({
      ...serverOptions,
      cert: typeof cert === "string" ? cert : cert,
      key: typeof key === "string" ? key : key
    });
  } else {
    server = createH2Server(serverOptions);
  }
  server.on("stream", async (stream, headers) => {
    try {
      const ctx = await createHttp2Context(stream, headers);
      const response6 = await handler(ctx);
      sendResponse2(stream, response6);
    } catch (error) {
      onError?.(error);
      sendResponse2(stream, serverError2());
    }
  });
  server.on("error", (err) => {
    onError?.(err);
  });
  return new Promise((resolve, reject) => {
    server.on("error", reject);
    server.listen(port, hostname, () => {
      options.onListen?.({ port, hostname });
      resolve({
        port,
        hostname,
        stop: () => new Promise((res) => server.close(() => res())),
        push: (stream, path, headers = {}) => {
          if (!stream.pushAllowed)
            return null;
          let pushStream = null;
          stream.pushStream({
            [HTTP2_HEADER_PATH]: path,
            ...headers
          }, (err, ps) => {
            if (err)
              return;
            pushStream = ps;
          });
          return pushStream;
        }
      });
    });
  });
};
var pushResource = (stream, path, content, options = {}) => {
  if (!stream.pushAllowed)
    return false;
  const { contentType = "application/octet-stream", cacheControl, headers = {} } = options;
  try {
    stream.pushStream({
      [HTTP2_HEADER_PATH]: path
    }, (err, pushStream) => {
      if (err || !pushStream)
        return;
      const responseHeaders = {
        [HTTP2_HEADER_STATUS]: 200,
        [HTTP2_HEADER_CONTENT_TYPE]: contentType,
        [HTTP2_HEADER_CONTENT_LENGTH]: typeof content === "string" ? Buffer.byteLength(content) : content.length,
        ...headers
      };
      if (cacheControl) {
        responseHeaders["cache-control"] = cacheControl;
      }
      pushStream.respond(responseHeaders);
      pushStream.end(content);
    });
    return true;
  } catch {
    return false;
  }
};
var pushResources = (stream, resources) => {
  let pushed = 0;
  for (const resource of resources) {
    if (pushResource(stream, resource.path, resource.content, resource.options)) {
      pushed++;
    }
  }
  return pushed;
};
var getAlpnProtocol = (socket) => {
  return socket.alpnProtocol || "http/1.1";
};
var isHttp2 = (socket) => {
  return socket.alpnProtocol === "h2";
};
var preloadHint = (resources) => {
  return resources.map((r) => {
    let link = `<${r.path}>; rel=preload; as=${r.as}`;
    if (r.crossorigin) {
      link += "; crossorigin";
    }
    return link;
  }).join(", ");
};
var preload = {
  script: (path) => ({ path, as: "script" }),
  style: (path) => ({ path, as: "style" }),
  image: (path) => ({ path, as: "image" }),
  font: (path, crossorigin = true) => ({ path, as: "font", crossorigin }),
  fetch: (path) => ({ path, as: "fetch" })
};
// src/jwt.ts
import { createHmac as createHmac3, timingSafeEqual as timingSafeEqual3 } from "node:crypto";
import { unauthorized } from "@sylphx/gust-core";
var base64UrlEncode = (data) => {
  const base64 = Buffer.from(data).toString("base64");
  return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
};
var base64UrlDecode = (str) => {
  let base64 = str.replace(/-/g, "+").replace(/_/g, "/");
  while (base64.length % 4)
    base64 += "=";
  return Buffer.from(base64, "base64");
};
var algorithms = {
  HS256: "sha256",
  HS384: "sha384",
  HS512: "sha512"
};
var sign = (data, secret, alg) => {
  const algorithm = algorithms[alg];
  if (!algorithm)
    throw new Error(`Unsupported algorithm: ${alg}`);
  return createHmac3(algorithm, secret).update(data).digest("base64url");
};
var verifySignature = (data, signature, secret, alg) => {
  const expected = sign(data, secret, alg);
  const sigBuf = Buffer.from(signature);
  const expBuf = Buffer.from(expected);
  if (sigBuf.length !== expBuf.length)
    return false;
  return timingSafeEqual3(sigBuf, expBuf);
};
var createJwt = (payload, options) => {
  const { secret, algorithm = "HS256", expiresIn = 3600, issuer, audience } = options;
  const now = Math.floor(Date.now() / 1000);
  const header = {
    alg: algorithm,
    typ: "JWT"
  };
  const claims = {
    ...payload,
    iat: payload.iat ?? now,
    exp: payload.exp ?? now + expiresIn
  };
  if (issuer)
    claims.iss = issuer;
  if (audience)
    claims.aud = audience;
  const headerB64 = base64UrlEncode(JSON.stringify(header));
  const payloadB64 = base64UrlEncode(JSON.stringify(claims));
  const signature = sign(`${headerB64}.${payloadB64}`, secret, algorithm);
  return `${headerB64}.${payloadB64}.${signature}`;
};
var verifyJwt = (token, options) => {
  const {
    secret,
    algorithms: allowedAlgs = ["HS256", "HS384", "HS512"],
    issuer,
    audience,
    clockTolerance = 0,
    ignoreExpiration = false
  } = options;
  const parts = token.split(".");
  if (parts.length !== 3) {
    return { valid: false, error: "Invalid token format" };
  }
  const headerB64 = parts[0];
  const payloadB64 = parts[1];
  const signature = parts[2];
  if (!headerB64 || !payloadB64 || !signature) {
    return { valid: false, error: "Invalid token format" };
  }
  let header;
  try {
    header = JSON.parse(base64UrlDecode(headerB64).toString("utf-8"));
  } catch {
    return { valid: false, error: "Invalid header" };
  }
  if (!allowedAlgs.includes(header.alg)) {
    return { valid: false, error: `Algorithm ${header.alg} not allowed` };
  }
  if (!verifySignature(`${headerB64}.${payloadB64}`, signature, secret, header.alg)) {
    return { valid: false, error: "Invalid signature" };
  }
  let payload;
  try {
    payload = JSON.parse(base64UrlDecode(payloadB64).toString("utf-8"));
  } catch {
    return { valid: false, error: "Invalid payload" };
  }
  const now = Math.floor(Date.now() / 1000);
  if (!ignoreExpiration && payload.exp !== undefined) {
    if (now > payload.exp + clockTolerance) {
      return { valid: false, error: "Token expired" };
    }
  }
  if (payload.nbf !== undefined) {
    if (now < payload.nbf - clockTolerance) {
      return { valid: false, error: "Token not yet valid" };
    }
  }
  if (issuer && payload.iss !== issuer) {
    return { valid: false, error: "Invalid issuer" };
  }
  if (audience) {
    const tokenAud = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
    const expectedAud = Array.isArray(audience) ? audience : [audience];
    const hasAud = expectedAud.some((a) => tokenAud.includes(a));
    if (!hasAud) {
      return { valid: false, error: "Invalid audience" };
    }
  }
  return { valid: true, payload, header };
};
var decodeJwt = (token) => {
  try {
    const parts = token.split(".");
    if (parts.length !== 3 || !parts[0] || !parts[1])
      return null;
    const header = JSON.parse(base64UrlDecode(parts[0]).toString("utf-8"));
    const payload = JSON.parse(base64UrlDecode(parts[1]).toString("utf-8"));
    return { header, payload };
  } catch {
    return null;
  }
};
var isJwtExpired = (token) => {
  const decoded = decodeJwt(token);
  if (!decoded)
    return true;
  if (!decoded.payload.exp)
    return false;
  return Date.now() / 1000 > decoded.payload.exp;
};
var jwtPayloadMap = new WeakMap;
var getJwtPayload = (ctx) => {
  return jwtPayloadMap.get(ctx);
};
var jwtAuth = (options) => {
  const {
    secret,
    algorithms: algorithms2 = ["HS256"],
    issuer,
    audience,
    clockTolerance = 0,
    skip,
    onError,
    getToken
  } = options;
  const defaultGetToken = (ctx) => {
    const auth = ctx.headers.authorization;
    if (!auth?.toLowerCase().startsWith("bearer "))
      return null;
    return auth.slice(7).trim();
  };
  const tokenGetter = getToken ?? defaultGetToken;
  const errorResponse = onError ?? ((_, error) => unauthorized(error));
  return (handler) => {
    return async (ctx) => {
      if (skip?.(ctx)) {
        return handler(ctx);
      }
      const token = tokenGetter(ctx);
      if (!token) {
        return errorResponse(ctx, "Missing token");
      }
      const result = verifyJwt(token, {
        secret,
        algorithms: algorithms2,
        issuer,
        audience,
        clockTolerance
      });
      if (!result.valid) {
        return errorResponse(ctx, result.error);
      }
      jwtPayloadMap.set(ctx, result.payload);
      return handler(ctx);
    };
  };
};
var optionalJwt = (options) => {
  const { secret, algorithms: algorithms2 = ["HS256"], issuer, audience, clockTolerance = 0, getToken } = options;
  const defaultGetToken = (ctx) => {
    const auth = ctx.headers.authorization;
    if (!auth?.toLowerCase().startsWith("bearer "))
      return null;
    return auth.slice(7).trim();
  };
  const tokenGetter = getToken ?? defaultGetToken;
  return (handler) => {
    return async (ctx) => {
      const token = tokenGetter(ctx);
      if (token) {
        const result = verifyJwt(token, {
          secret,
          algorithms: algorithms2,
          issuer,
          audience,
          clockTolerance
        });
        if (result.valid) {
          jwtPayloadMap.set(ctx, result.payload);
        }
      }
      return handler(ctx);
    };
  };
};
// src/otel.ts
init_native();

// src/proxy.ts
var proxyInfoMap = new WeakMap;
var getProxyInfo = (ctx) => {
  return proxyInfoMap.get(ctx);
};
var getClientIp = (ctx) => {
  const proxyInfo = proxyInfoMap.get(ctx);
  if (proxyInfo)
    return proxyInfo.ip;
  return ctx.socket.remoteAddress || "unknown";
};
var isTrusted = (ip, trust) => {
  if (trust === true)
    return true;
  if (trust === false)
    return false;
  if (typeof trust === "number") {
    return true;
  }
  if (Array.isArray(trust)) {
    return trust.some((trusted) => {
      if (trusted.includes("/")) {
        const parts = trusted.split("/");
        const subnet = parts[0];
        const bits = parts[1];
        if (!subnet || !bits)
          return false;
        const subnetParts = subnet.split(".").map(Number);
        const ipParts = ip.split(".").map(Number);
        const mask = parseInt(bits, 10);
        if (subnetParts.length !== 4 || ipParts.length !== 4)
          return false;
        const s0 = subnetParts[0] ?? 0;
        const s1 = subnetParts[1] ?? 0;
        const s2 = subnetParts[2] ?? 0;
        const s3 = subnetParts[3] ?? 0;
        const i0 = ipParts[0] ?? 0;
        const i1 = ipParts[1] ?? 0;
        const i2 = ipParts[2] ?? 0;
        const i3 = ipParts[3] ?? 0;
        const subnetNum = s0 << 24 | s1 << 16 | s2 << 8 | s3;
        const ipNum = i0 << 24 | i1 << 16 | i2 << 8 | i3;
        const maskNum = ~((1 << 32 - mask) - 1);
        return (subnetNum & maskNum) === (ipNum & maskNum);
      }
      return trusted === ip;
    });
  }
  return false;
};
var parseForwardedFor = (header) => {
  if (!header)
    return [];
  return header.split(",").map((ip) => ip.trim()).filter(Boolean);
};
var proxy = (options = {}) => {
  const {
    trust = false,
    ipHeader = "x-forwarded-for",
    hostHeader = "x-forwarded-host",
    protoHeader = "x-forwarded-proto",
    portHeader = "x-forwarded-port"
  } = options;
  const ipHeaderLower = ipHeader.toLowerCase();
  const hostHeaderLower = hostHeader.toLowerCase();
  const protoHeaderLower = protoHeader.toLowerCase();
  const portHeaderLower = portHeader.toLowerCase();
  return (handler) => {
    return async (ctx) => {
      const socketIp = ctx.socket.remoteAddress || "unknown";
      if (!trust || !isTrusted(socketIp, trust)) {
        const info2 = {
          ip: socketIp,
          host: ctx.headers.host || "localhost",
          protocol: "http",
          port: 80,
          url: `http://${ctx.headers.host || "localhost"}${ctx.path}`,
          ips: [socketIp]
        };
        proxyInfoMap.set(ctx, info2);
        return handler(ctx);
      }
      const forwardedIps = parseForwardedFor(ctx.headers[ipHeaderLower]);
      const allIps = [...forwardedIps, socketIp];
      let clientIp;
      if (typeof trust === "number") {
        const index = Math.max(0, allIps.length - trust - 1);
        clientIp = allIps[index] || socketIp;
      } else {
        clientIp = forwardedIps[0] || socketIp;
      }
      const host = ctx.headers[hostHeaderLower] || ctx.headers.host || "localhost";
      const protocol = ctx.headers[protoHeaderLower] || "http";
      const port = parseInt(ctx.headers[portHeaderLower] || (protocol === "https" ? "443" : "80"), 10);
      const info = {
        ip: clientIp,
        host,
        protocol,
        port,
        url: `${protocol}://${host}${ctx.path}`,
        ips: allIps
      };
      proxyInfoMap.set(ctx, info);
      return handler(ctx);
    };
  };
};
var trustLocalProxy = () => proxy({
  trust: ["127.0.0.1", "::1", "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16"]
});
var trustFirstProxy = () => proxy({ trust: 1 });

// src/tracing.ts
init_native();
var defaultGenerator = () => {
  const native = nativeGenerateTraceId();
  if (native)
    return native;
  throw new Error("Native trace ID generation unavailable");
};
var generateUUID = () => {
  const hex = nativeGenerateTraceId();
  if (!hex)
    throw new Error("Native trace ID generation unavailable");
  const chars = hex.split("");
  chars[12] = "4";
  chars[16] = "89ab"[parseInt(chars[16] ?? "0", 16) & 3] ?? "8";
  return [
    chars.slice(0, 8).join(""),
    chars.slice(8, 12).join(""),
    chars.slice(12, 16).join(""),
    chars.slice(16, 20).join(""),
    chars.slice(20, 32).join("")
  ].join("-");
};
var generateShortId = () => {
  const spanId = nativeGenerateSpanId();
  if (!spanId)
    throw new Error("Native span ID generation unavailable");
  return spanId.slice(0, 8);
};
var generateNanoId = (size = 21) => {
  const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  let hex = "";
  while (hex.length < size * 2) {
    const traceId = nativeGenerateTraceId();
    if (!traceId)
      throw new Error("Native trace ID generation unavailable");
    hex += traceId;
  }
  let id = "";
  for (let i = 0;i < size; i++) {
    const byte = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
    id += alphabet[byte % alphabet.length];
  }
  return id;
};
var requestIdMap = new WeakMap;
var getRequestId = (ctx) => {
  return requestIdMap.get(ctx);
};
var tracing = (options = {}) => {
  const {
    header = "x-request-id",
    generator = defaultGenerator,
    trustIncoming = true,
    setResponse = true
  } = options;
  const headerLower = header.toLowerCase();
  return (handler) => {
    return async (ctx) => {
      let requestId = trustIncoming ? ctx.headers[headerLower] : undefined;
      if (!requestId) {
        requestId = generator();
      }
      requestIdMap.set(ctx, requestId);
      const res = await handler(ctx);
      if (setResponse) {
        return {
          ...res,
          headers: {
            ...res.headers,
            [header]: requestId
          }
        };
      }
      return res;
    };
  };
};
var logging = (options = {}) => {
  const { log = console.log, timing = true, skip } = options;
  return (handler) => {
    return async (ctx) => {
      if (skip?.(ctx)) {
        return handler(ctx);
      }
      const start = timing ? performance.now() : 0;
      const requestId = getRequestId(ctx);
      try {
        const res = await handler(ctx);
        const duration = timing ? performance.now() - start : undefined;
        log(`${ctx.method} ${ctx.path}`, {
          status: res.status,
          duration: duration ? `${duration.toFixed(2)}ms` : undefined,
          requestId
        });
        return res;
      } catch (error) {
        const duration = timing ? performance.now() - start : undefined;
        log(`${ctx.method} ${ctx.path} ERROR`, {
          error: error instanceof Error ? error.message : String(error),
          duration: duration ? `${duration.toFixed(2)}ms` : undefined,
          requestId
        });
        throw error;
      }
    };
  };
};

// src/otel.ts
var generateTraceId = () => {
  const native = nativeGenerateTraceId();
  if (native)
    return native;
  const bytes = new Uint8Array(16);
  crypto.getRandomValues(bytes);
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
};
var generateSpanId = () => {
  const native = nativeGenerateSpanId();
  if (native)
    return native;
  const bytes = new Uint8Array(8);
  crypto.getRandomValues(bytes);
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
};
var parseTraceparent = (header) => {
  const native = nativeParseTraceparent(header);
  if (native)
    return native;
  const parts = header.split("-");
  if (parts.length !== 4)
    return null;
  const version = parts[0];
  const traceId = parts[1];
  const spanId = parts[2];
  const flags = parts[3];
  if (!version || !traceId || !spanId || !flags)
    return null;
  if (version !== "00")
    return null;
  if (traceId.length !== 32 || !/^[0-9a-f]+$/.test(traceId))
    return null;
  if (spanId.length !== 16 || !/^[0-9a-f]+$/.test(spanId))
    return null;
  if (flags.length !== 2 || !/^[0-9a-f]+$/.test(flags))
    return null;
  if (traceId === "00000000000000000000000000000000")
    return null;
  return {
    traceId,
    spanId,
    traceFlags: parseInt(flags, 16)
  };
};
var formatTraceparent = (ctx) => {
  const native = nativeFormatTraceparent(ctx.traceId, ctx.spanId, ctx.traceFlags);
  if (native)
    return native;
  return `00-${ctx.traceId}-${ctx.spanId}-${ctx.traceFlags.toString(16).padStart(2, "0")}`;
};
var parseTracestate = (header) => {
  const state = {};
  for (const pair of header.split(",")) {
    const [key, value] = pair.trim().split("=");
    if (key && value) {
      state[key] = value;
    }
  }
  return state;
};
var formatTracestate = (state) => {
  return Object.entries(state).map(([k, v]) => `${k}=${v}`).join(",");
};
var createTracer = (exporter) => {
  const pendingSpans = [];
  let flushTimer = null;
  const scheduleFlush = () => {
    if (flushTimer)
      return;
    flushTimer = setTimeout(async () => {
      flushTimer = null;
      if (pendingSpans.length > 0 && exporter) {
        const spans = pendingSpans.splice(0);
        await exporter.export(spans);
      }
    }, 1000);
  };
  return {
    startSpan: (name, attributes = {}) => {
      return {
        name,
        context: {
          traceId: generateTraceId(),
          spanId: generateSpanId(),
          traceFlags: 1
        },
        startTime: performance.now(),
        attributes,
        status: "unset",
        events: []
      };
    },
    endSpan: (span, status = "ok") => {
      span.endTime = performance.now();
      span.status = status;
      pendingSpans.push(span);
      scheduleFlush();
    },
    addEvent: (span, name, attributes) => {
      span.events.push({
        name,
        time: performance.now(),
        attributes
      });
    },
    setAttributes: (span, attributes) => {
      Object.assign(span.attributes, attributes);
    },
    export: async (spans) => {
      if (exporter) {
        await exporter.export(spans);
      }
    }
  };
};
var consoleExporter = {
  export: async (spans) => {
    for (const span of spans) {
      const duration = span.endTime ? (span.endTime - span.startTime).toFixed(2) : "?";
      console.log(`[TRACE] ${span.name}`, `trace=${span.context.traceId.slice(0, 8)}`, `span=${span.context.spanId.slice(0, 8)}`, `duration=${duration}ms`, `status=${span.status}`);
      if (Object.keys(span.attributes).length > 0) {
        console.log("  attributes:", span.attributes);
      }
      for (const event of span.events) {
        console.log(`  event: ${event.name}`, event.attributes || "");
      }
    }
  }
};
var createOtlpExporter = (endpoint, headers) => {
  return {
    export: async (spans) => {
      const resourceSpans = [
        {
          resource: {
            attributes: [{ key: "service.name", value: { stringValue: "serve" } }]
          },
          scopeSpans: [
            {
              scope: { name: "@sylphx/gust" },
              spans: spans.map((span) => ({
                traceId: span.context.traceId,
                spanId: span.context.spanId,
                parentSpanId: span.parentSpanId,
                name: span.name,
                kind: 2,
                startTimeUnixNano: Math.floor(span.startTime * 1e6),
                endTimeUnixNano: span.endTime ? Math.floor(span.endTime * 1e6) : undefined,
                attributes: Object.entries(span.attributes).map(([key, value]) => ({
                  key,
                  value: typeof value === "string" ? { stringValue: value } : typeof value === "number" ? { intValue: value } : { boolValue: value }
                })),
                status: {
                  code: span.status === "error" ? 2 : span.status === "ok" ? 1 : 0
                },
                events: span.events.map((e) => ({
                  name: e.name,
                  timeUnixNano: Math.floor(e.time * 1e6),
                  attributes: e.attributes ? Object.entries(e.attributes).map(([key, value]) => ({
                    key,
                    value: { stringValue: String(value) }
                  })) : []
                }))
              }))
            }
          ]
        }
      ];
      try {
        await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...headers
          },
          body: JSON.stringify({ resourceSpans })
        });
      } catch (err) {
        console.error("Failed to export spans:", err);
      }
    }
  };
};
var spanMap = new WeakMap;
var getSpan = (ctx) => {
  return spanMap.get(ctx);
};
var otel = (options) => {
  const {
    tracer,
    serviceName = "serve",
    skip,
    sampleRate = 1,
    captureHeaders = [],
    captureResponseHeaders = []
  } = options;
  const captureHeadersLower = captureHeaders.map((h) => h.toLowerCase());
  const captureResponseHeadersLower = captureResponseHeaders.map((h) => h.toLowerCase());
  return (handler) => {
    return async (ctx) => {
      if (skip?.(ctx)) {
        return handler(ctx);
      }
      if (sampleRate < 1 && Math.random() > sampleRate) {
        return handler(ctx);
      }
      const traceparent = ctx.headers.traceparent;
      const parentContext = traceparent ? parseTraceparent(traceparent) : null;
      const span = tracer.startSpan(`${ctx.method} ${ctx.path}`, {
        "http.method": ctx.method,
        "http.url": ctx.path + (ctx.query || ""),
        "http.target": ctx.path,
        "http.host": ctx.headers.host || "",
        "http.scheme": "http",
        "http.user_agent": ctx.headers["user-agent"] || "",
        "net.peer.ip": getClientIp(ctx),
        "service.name": serviceName
      });
      if (parentContext) {
        span.context.traceId = parentContext.traceId;
        span.parentSpanId = parentContext.spanId;
      }
      for (const header of captureHeadersLower) {
        if (ctx.headers[header]) {
          span.attributes[`http.request.header.${header}`] = ctx.headers[header];
        }
      }
      const requestId = getRequestId(ctx);
      if (requestId) {
        span.attributes["http.request_id"] = requestId;
      }
      spanMap.set(ctx, span);
      try {
        const res = await handler(ctx);
        span.attributes["http.status_code"] = res.status;
        const isStreaming = res.body !== null && typeof res.body === "object" && Symbol.asyncIterator in res.body;
        span.attributes["http.response_content_length"] = isStreaming ? -1 : res.body ? typeof res.body === "string" ? res.body.length : res.body.length : 0;
        for (const header of captureResponseHeadersLower) {
          if (res.headers[header]) {
            span.attributes[`http.response.header.${header}`] = res.headers[header];
          }
        }
        const status = res.status >= 400 ? "error" : "ok";
        tracer.endSpan(span, status);
        return {
          ...res,
          headers: {
            ...res.headers,
            traceparent: formatTraceparent(span.context)
          }
        };
      } catch (error) {
        tracer.addEvent(span, "exception", {
          "exception.type": error.name,
          "exception.message": error.message
        });
        tracer.endSpan(span, "error");
        throw error;
      }
    };
  };
};
var startChildSpan = (ctx, tracer, name, attributes) => {
  const parentSpan = getSpan(ctx);
  const span = tracer.startSpan(name, attributes);
  if (parentSpan) {
    span.context.traceId = parentSpan.context.traceId;
    span.parentSpanId = parentSpan.context.spanId;
  }
  return span;
};
var attributeKey = (attrs) => {
  const keys = Object.keys(attrs).sort();
  if (keys.length === 0)
    return "";
  return keys.map((k) => `${k}=${attrs[k]}`).join("&");
};

class MetricsCollector {
  native = null;
  counters = new Map;
  histograms = new Map;
  gauges = new Map;
  constructor() {
    this.native = createNativeMetricsCollector();
  }
  get isNative() {
    return this.native !== null;
  }
  createCounter(name) {
    if (this.native) {
      const nativeCollector = this.native;
      return {
        add: (value, _attributes = {}) => {
          nativeCollector.counterAdd(name, value);
        }
      };
    }
    if (!this.counters.has(name)) {
      this.counters.set(name, []);
    }
    return {
      add: (value, attributes = {}) => {
        this.counters.get(name)?.push({ value, attributes });
      }
    };
  }
  createHistogram(name) {
    if (this.native) {
      const nativeCollector = this.native;
      return {
        record: (value, _attributes = {}) => {
          nativeCollector.histogramRecord(name, value);
        }
      };
    }
    if (!this.histograms.has(name)) {
      this.histograms.set(name, new Map);
    }
    return {
      record: (value, attributes = {}) => {
        const bucketMap = this.histograms.get(name);
        if (!bucketMap)
          return;
        const key = attributeKey(attributes);
        let entry = bucketMap.get(key);
        if (!entry) {
          entry = { values: [], attributes };
          bucketMap.set(key, entry);
        }
        entry.values.push(value);
      }
    };
  }
  createGauge(name) {
    if (this.native) {
      const nativeCollector = this.native;
      return {
        set: (value, _attributes = {}) => {
          nativeCollector.gaugeSet(name, value);
        }
      };
    }
    return {
      set: (value, attributes = {}) => {
        this.gauges.set(`${name}:${attributeKey(attributes)}`, { value, attributes });
      }
    };
  }
  toPrometheus() {
    if (this.native) {
      return this.native.toPrometheus();
    }
    const lines = [];
    for (const [name, entries] of this.counters) {
      const total = entries.reduce((sum, e) => sum + e.value, 0);
      lines.push(`# TYPE ${name} counter`);
      lines.push(`${name} ${total}`);
    }
    for (const [name, bucketMap] of this.histograms) {
      lines.push(`# TYPE ${name} histogram`);
      for (const bucket of bucketMap.values()) {
        const count = bucket.values.length;
        const sum = bucket.values.reduce((a, b) => a + b, 0);
        const labels = Object.entries(bucket.attributes).map(([k, v]) => `${k}="${v}"`).join(",");
        lines.push(`${name}_count{${labels}} ${count}`);
        lines.push(`${name}_sum{${labels}} ${sum}`);
      }
    }
    for (const [key, { value }] of this.gauges) {
      const [name] = key.split(":");
      lines.push(`# TYPE ${name} gauge`);
      lines.push(`${name} ${value}`);
    }
    return lines.join(`
`);
  }
}
// src/range.ts
import { createReadStream } from "node:fs";
import { stat } from "node:fs/promises";
import { extname, join as join2 } from "node:path";
import { notFound, response as response6 } from "@sylphx/gust-core";
var parseRange = (rangeHeader, fileSize) => {
  const match = rangeHeader.match(/^(\w+)=(.+)$/);
  if (!match)
    return null;
  const unit = match[1];
  const rangeSpec = match[2];
  if (unit !== "bytes" || !rangeSpec)
    return null;
  const ranges = [];
  for (const part of rangeSpec.split(",")) {
    const trimmed = part.trim();
    const rangeParts = trimmed.split("-");
    if (rangeParts.length !== 2)
      continue;
    const startStr = rangeParts[0] ?? "";
    const endStr = rangeParts[1] ?? "";
    let start;
    let end;
    if (startStr === "") {
      const suffix = parseInt(endStr, 10);
      if (Number.isNaN(suffix) || suffix <= 0)
        continue;
      start = Math.max(0, fileSize - suffix);
      end = fileSize - 1;
    } else if (endStr === "") {
      start = parseInt(startStr, 10);
      if (Number.isNaN(start) || start < 0)
        continue;
      end = fileSize - 1;
    } else {
      start = parseInt(startStr, 10);
      end = parseInt(endStr, 10);
      if (Number.isNaN(start) || Number.isNaN(end))
        continue;
    }
    if (start > end || start >= fileSize)
      continue;
    end = Math.min(end, fileSize - 1);
    ranges.push({ start, end });
  }
  if (ranges.length === 0)
    return null;
  return { unit, ranges };
};
var isRangeSatisfiable = (ranges, fileSize) => {
  return ranges.every((r) => r.start < fileSize && r.end < fileSize);
};
var contentRange = (start, end, total) => {
  return `bytes ${start}-${end}/${total}`;
};
var getMimeType = (ext) => {
  const types = {
    ".mp4": "video/mp4",
    ".webm": "video/webm",
    ".ogg": "video/ogg",
    ".ogv": "video/ogg",
    ".avi": "video/x-msvideo",
    ".mov": "video/quicktime",
    ".mkv": "video/x-matroska",
    ".m4v": "video/x-m4v",
    ".mp3": "audio/mpeg",
    ".wav": "audio/wav",
    ".flac": "audio/flac",
    ".aac": "audio/aac",
    ".m4a": "audio/mp4",
    ".oga": "audio/ogg",
    ".weba": "audio/webm",
    ".pdf": "application/pdf",
    ".zip": "application/zip",
    ".gz": "application/gzip",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".png": "image/png",
    ".gif": "image/gif",
    ".webp": "image/webp",
    ".svg": "image/svg+xml"
  };
  return types[ext.toLowerCase()] || "application/octet-stream";
};
var serveRangeFile = async (ctx, filePath, options = {}) => {
  const { maxAge = 86400 } = options;
  let stats;
  try {
    stats = await stat(filePath);
  } catch {
    return notFound();
  }
  if (!stats.isFile()) {
    return notFound();
  }
  const fileSize = stats.size;
  const ext = extname(filePath);
  const mimeType = getMimeType(ext);
  const lastModified = stats.mtime.toUTCString();
  const etag2 = `"${stats.mtime.getTime().toString(16)}-${fileSize.toString(16)}"`;
  const ifNoneMatch = ctx.headers["if-none-match"];
  if (ifNoneMatch === etag2) {
    return response6("", {
      status: 304,
      headers: { etag: etag2, "last-modified": lastModified }
    });
  }
  const ifModifiedSince = ctx.headers["if-modified-since"];
  if (ifModifiedSince && new Date(ifModifiedSince) >= stats.mtime) {
    return response6("", {
      status: 304,
      headers: { etag: etag2, "last-modified": lastModified }
    });
  }
  const rangeHeader = ctx.headers.range;
  if (!rangeHeader) {
    return streamFile(ctx.socket, filePath, {
      status: 200,
      headers: {
        "content-type": mimeType,
        "content-length": String(fileSize),
        "accept-ranges": "bytes",
        "cache-control": `public, max-age=${maxAge}`,
        "last-modified": lastModified,
        etag: etag2
      }
    });
  }
  const parsed = parseRange(rangeHeader, fileSize);
  if (!parsed || parsed.ranges.length === 0) {
    return response6("Range Not Satisfiable", {
      status: 416,
      headers: { "content-range": `bytes */${fileSize}` }
    });
  }
  const range = parsed.ranges[0];
  if (!range) {
    return response6("Range Not Satisfiable", {
      status: 416,
      headers: { "content-range": `bytes */${fileSize}` }
    });
  }
  const contentLength = range.end - range.start + 1;
  return streamFile(ctx.socket, filePath, {
    status: 206,
    headers: {
      "content-type": mimeType,
      "content-length": String(contentLength),
      "content-range": contentRange(range.start, range.end, fileSize),
      "accept-ranges": "bytes",
      "cache-control": `public, max-age=${maxAge}`,
      "last-modified": lastModified,
      etag: etag2
    },
    start: range.start,
    end: range.end
  });
};
var streamFile = (socket, filePath, options) => {
  return new Promise((resolve, reject) => {
    const { status, headers, start, end } = options;
    const statusText = status === 200 ? "OK" : "Partial Content";
    let head = `HTTP/1.1 ${status} ${statusText}\r
`;
    for (const [key, value] of Object.entries(headers)) {
      head += `${key}: ${value}\r
`;
    }
    head += `connection: keep-alive\r
`;
    head += `\r
`;
    socket.write(head);
    const streamOptions = {};
    if (start !== undefined)
      streamOptions.start = start;
    if (end !== undefined)
      streamOptions.end = end;
    const readStream = createReadStream(filePath, streamOptions);
    readStream.on("error", (err) => {
      socket.end();
      reject(err);
    });
    readStream.on("end", () => {
      resolve(null);
    });
    readStream.pipe(socket, { end: false });
  });
};
var rangeServer = (options) => {
  const {
    root,
    prefix = "/",
    maxAge = 86400,
    extensions = [".mp4", ".webm", ".mp3", ".wav", ".pdf"]
  } = options;
  return async (ctx) => {
    if (ctx.method !== "GET" && ctx.method !== "HEAD") {
      return null;
    }
    let path = ctx.path;
    if (prefix !== "/" && path.startsWith(prefix)) {
      path = path.slice(prefix.length) || "/";
    }
    if (path.includes("..")) {
      return response6("Bad Request", { status: 400 });
    }
    const ext = extname(path).toLowerCase();
    if (extensions.length > 0 && !extensions.includes(ext)) {
      return null;
    }
    const filePath = join2(root, path);
    return serveRangeFile(ctx, filePath, { maxAge });
  };
};
var acceptsRange = (ctx) => {
  return ctx.headers.range !== undefined;
};
var getRange = (ctx, fileSize) => {
  const rangeHeader = ctx.headers.range;
  if (!rangeHeader)
    return null;
  const parsed = parseRange(rangeHeader, fileSize);
  if (!parsed || parsed.ranges.length === 0)
    return null;
  return parsed.ranges[0] ?? null;
};
// src/rateLimit.ts
import { json as json2 } from "@sylphx/gust-core";

class RateLimitStore {
  store = new Map;
  cleanupInterval = null;
  constructor(windowMs) {
    this.cleanupInterval = setInterval(() => {
      const now = Date.now();
      for (const [key, record] of this.store) {
        if (record.resetTime < now) {
          this.store.delete(key);
        }
      }
    }, Math.min(windowMs, 60000));
  }
  get(key) {
    return this.store.get(key);
  }
  set(key, record) {
    this.store.set(key, record);
  }
  delete(key) {
    this.store.delete(key);
  }
  destroy() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
    this.store.clear();
  }
}
var getClientIp2 = (ctx) => {
  const forwarded = ctx.headers["x-forwarded-for"];
  if (forwarded) {
    return forwarded.split(",")[0]?.trim() ?? "unknown";
  }
  const realIp = ctx.headers["x-real-ip"];
  if (realIp) {
    return realIp;
  }
  return ctx.socket.remoteAddress || "unknown";
};
var fixedWindowCheck = (store, key, max, windowMs) => {
  const now = Date.now();
  let record = store.get(key);
  if (!record || record.resetTime < now) {
    record = {
      count: 1,
      resetTime: now + windowMs
    };
    store.set(key, record);
    return { allowed: true, remaining: max - 1, resetTime: record.resetTime };
  }
  if (record.count >= max) {
    return { allowed: false, remaining: 0, resetTime: record.resetTime };
  }
  record.count++;
  return { allowed: true, remaining: max - record.count, resetTime: record.resetTime };
};
var slidingWindowCheck = (store, key, max, windowMs) => {
  const now = Date.now();
  const windowStart = now - windowMs;
  let record = store.get(key);
  if (!record) {
    record = {
      count: 1,
      resetTime: now + windowMs,
      requests: [now]
    };
    store.set(key, record);
    return { allowed: true, remaining: max - 1, resetTime: record.resetTime };
  }
  record.requests = (record.requests || []).filter((t) => t > windowStart);
  record.count = record.requests.length;
  if (record.count >= max) {
    const oldestRequest = record.requests[0] ?? now;
    const resetTime = oldestRequest + windowMs;
    return { allowed: false, remaining: 0, resetTime };
  }
  record.requests.push(now);
  record.count++;
  record.resetTime = (record.requests[0] ?? now) + windowMs;
  return { allowed: true, remaining: max - record.count, resetTime: record.resetTime };
};
var rateLimit = (options) => {
  const {
    max,
    windowMs,
    keyGenerator = getClientIp2,
    skip,
    onLimitReached,
    headers = true,
    slidingWindow = false
  } = options;
  const store = new RateLimitStore(windowMs);
  return (handler) => async (ctx) => {
    if (skip?.(ctx)) {
      return handler(ctx);
    }
    const key = keyGenerator(ctx);
    const check = slidingWindow ? slidingWindowCheck(store, key, max, windowMs) : fixedWindowCheck(store, key, max, windowMs);
    if (!check.allowed) {
      const limitedResponse = onLimitReached ? onLimitReached(ctx) : json2({ error: "Too Many Requests" }, { status: 429 });
      if (headers) {
        return {
          ...limitedResponse,
          headers: {
            ...limitedResponse.headers,
            "x-ratelimit-limit": max.toString(),
            "x-ratelimit-remaining": "0",
            "x-ratelimit-reset": Math.ceil(check.resetTime / 1000).toString(),
            "retry-after": Math.ceil((check.resetTime - Date.now()) / 1000).toString()
          }
        };
      }
      return limitedResponse;
    }
    const res = await handler(ctx);
    if (headers) {
      return {
        ...res,
        headers: {
          ...res.headers,
          "x-ratelimit-limit": max.toString(),
          "x-ratelimit-remaining": check.remaining.toString(),
          "x-ratelimit-reset": Math.ceil(check.resetTime / 1000).toString()
        }
      };
    }
    return res;
  };
};
var rateLimitWithStore = (options) => {
  const {
    max,
    windowMs,
    keyGenerator = getClientIp2,
    skip,
    onLimitReached,
    headers = true,
    store
  } = options;
  return (handler) => async (ctx) => {
    if (skip?.(ctx)) {
      return handler(ctx);
    }
    const key = keyGenerator(ctx);
    const { count, resetTime } = await store.increment(key, windowMs);
    const remaining = Math.max(0, max - count);
    if (count > max) {
      const limitedResponse = onLimitReached ? onLimitReached(ctx) : json2({ error: "Too Many Requests" }, { status: 429 });
      if (headers) {
        return {
          ...limitedResponse,
          headers: {
            ...limitedResponse.headers,
            "x-ratelimit-limit": max.toString(),
            "x-ratelimit-remaining": "0",
            "x-ratelimit-reset": Math.ceil(resetTime / 1000).toString(),
            "retry-after": Math.ceil((resetTime - Date.now()) / 1000).toString()
          }
        };
      }
      return limitedResponse;
    }
    const res = await handler(ctx);
    if (headers) {
      return {
        ...res,
        headers: {
          ...res.headers,
          "x-ratelimit-limit": max.toString(),
          "x-ratelimit-remaining": remaining.toString(),
          "x-ratelimit-reset": Math.ceil(resetTime / 1000).toString()
        }
      };
    }
    return res;
  };
};
// src/router.ts
var get = (path, handler) => ({
  method: "GET",
  path,
  handler
});
var post = (path, handler) => ({
  method: "POST",
  path,
  handler
});
var put = (path, handler) => ({
  method: "PUT",
  path,
  handler
});
var patch = (path, handler) => ({
  method: "PATCH",
  path,
  handler
});
var del = (path, handler) => ({
  method: "DELETE",
  path,
  handler
});
var head = (path, handler) => ({
  method: "HEAD",
  path,
  handler
});
var options = (path, handler) => ({
  method: "OPTIONS",
  path,
  handler
});
var all = (path, handler) => ({
  method: "*",
  path,
  handler
});
var routes = (prefix, routeList) => routeList.map((route) => ({
  ...route,
  path: prefix + route.path
}));
var createRouter = () => ({
  get: (path, handler) => ({
    method: "GET",
    path,
    handler
  }),
  post: (path, handler) => ({
    method: "POST",
    path,
    handler
  }),
  put: (path, handler) => ({
    method: "PUT",
    path,
    handler
  }),
  patch: (path, handler) => ({
    method: "PATCH",
    path,
    handler
  }),
  del: (path, handler) => ({
    method: "DELETE",
    path,
    handler
  }),
  head: (path, handler) => ({
    method: "HEAD",
    path,
    handler
  }),
  options: (path, handler) => ({
    method: "OPTIONS",
    path,
    handler
  }),
  all: (path, handler) => ({
    method: "*",
    path,
    handler
  }),
  routes: (prefix, routeList) => routeList.map((route) => ({
    ...route,
    path: prefix + route.path
  }))
});
// src/security.ts
var DEFAULT_CSP = "default-src 'self'";
var security = (options2 = {}) => {
  const headers = {};
  if (options2.contentSecurityPolicy !== false) {
    headers["content-security-policy"] = options2.contentSecurityPolicy || DEFAULT_CSP;
  }
  if (options2.crossOriginEmbedderPolicy !== false && options2.crossOriginEmbedderPolicy) {
    headers["cross-origin-embedder-policy"] = options2.crossOriginEmbedderPolicy;
  }
  if (options2.crossOriginOpenerPolicy !== false) {
    headers["cross-origin-opener-policy"] = options2.crossOriginOpenerPolicy || "same-origin";
  }
  if (options2.crossOriginResourcePolicy !== false) {
    headers["cross-origin-resource-policy"] = options2.crossOriginResourcePolicy || "same-origin";
  }
  if (options2.referrerPolicy !== false) {
    headers["referrer-policy"] = options2.referrerPolicy || "strict-origin-when-cross-origin";
  }
  if (options2.hsts !== false) {
    const hsts = options2.hsts || { maxAge: 15552000 };
    let hstsValue = `max-age=${hsts.maxAge}`;
    if (hsts.includeSubDomains)
      hstsValue += "; includeSubDomains";
    if (hsts.preload)
      hstsValue += "; preload";
    headers["strict-transport-security"] = hstsValue;
  }
  if (options2.noSniff !== false) {
    headers["x-content-type-options"] = "nosniff";
  }
  if (options2.dnsPrefetchControl !== undefined) {
    headers["x-dns-prefetch-control"] = options2.dnsPrefetchControl ? "on" : "off";
  }
  if (options2.ieNoOpen !== false) {
    headers["x-download-options"] = "noopen";
  }
  if (options2.frameguard !== false) {
    headers["x-frame-options"] = options2.frameguard || "SAMEORIGIN";
  }
  if (options2.permittedCrossDomainPolicies !== false) {
    headers["x-permitted-cross-domain-policies"] = options2.permittedCrossDomainPolicies || "none";
  }
  if (options2.xssFilter !== false) {
    headers["x-xss-protection"] = "0";
  }
  return (handler) => async (ctx) => {
    const res = await handler(ctx);
    return {
      ...res,
      headers: {
        ...headers,
        ...res.headers
      }
    };
  };
};
var strictSecurity = () => security({
  contentSecurityPolicy: "default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self' data:; font-src 'self'; object-src 'none'; frame-ancestors 'none'",
  crossOriginEmbedderPolicy: "require-corp",
  crossOriginOpenerPolicy: "same-origin",
  crossOriginResourcePolicy: "same-origin",
  referrerPolicy: "no-referrer",
  hsts: { maxAge: 31536000, includeSubDomains: true, preload: true },
  frameguard: "DENY"
});
var apiSecurity = () => security({
  contentSecurityPolicy: false,
  crossOriginEmbedderPolicy: false,
  crossOriginOpenerPolicy: false,
  crossOriginResourcePolicy: "same-site",
  referrerPolicy: "no-referrer",
  hsts: { maxAge: 31536000 },
  frameguard: "DENY"
});

// src/index.ts
init_serve();

// src/session.ts
init_native();
var generateSessionId = () => {
  const traceId = nativeGenerateTraceId();
  if (!traceId)
    throw new Error("Native trace ID generation unavailable");
  const bytes = Buffer.from(traceId, "hex");
  return bytes.toString("base64url");
};
var signSessionId = (id, secret) => {
  const { createHmac: createHmac4 } = __require("node:crypto");
  const signature = createHmac4("sha256", secret).update(id).digest("base64url");
  return `${id}.${signature}`;
};
var verifySessionId = (signed, secret) => {
  const dotIndex = signed.lastIndexOf(".");
  if (dotIndex === -1)
    return null;
  const id = signed.slice(0, dotIndex);
  const signature = signed.slice(dotIndex + 1);
  const { createHmac: createHmac4, timingSafeEqual: timingSafeEqual4 } = __require("node:crypto");
  const expected = createHmac4("sha256", secret).update(id).digest("base64url");
  const sigBuf = Buffer.from(signature);
  const expBuf = Buffer.from(expected);
  if (sigBuf.length !== expBuf.length)
    return null;
  if (!timingSafeEqual4(sigBuf, expBuf))
    return null;
  return id;
};

class MemoryStore {
  sessions = new Map;
  cleanupInterval = null;
  constructor() {
    this.cleanupInterval = setInterval(() => {
      const now = Date.now();
      for (const [id, session] of this.sessions) {
        if (session.expires < now) {
          this.sessions.delete(id);
        }
      }
    }, 60000);
  }
  async get(id) {
    const session = this.sessions.get(id);
    if (!session)
      return null;
    if (session.expires < Date.now()) {
      this.sessions.delete(id);
      return null;
    }
    return session.data;
  }
  async set(id, data, maxAge) {
    this.sessions.set(id, {
      data,
      expires: Date.now() + maxAge
    });
  }
  async destroy(id) {
    this.sessions.delete(id);
  }
  async touch(id, maxAge) {
    const session = this.sessions.get(id);
    if (session) {
      session.expires = Date.now() + maxAge;
    }
  }
  all() {
    return this.sessions;
  }
  clear() {
    this.sessions.clear();
  }
  close() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }
}
var sessionMap = new WeakMap;
var getSession = (ctx) => {
  return sessionMap.get(ctx);
};
var defaultStore2 = null;
var getDefaultStore2 = () => {
  if (!defaultStore2) {
    defaultStore2 = new MemoryStore;
  }
  return defaultStore2;
};
var session = (options2) => {
  const {
    name = "sid",
    secret,
    store = getDefaultStore2(),
    maxAge = 24 * 60 * 60 * 1000,
    cookie = {},
    genid = generateSessionId,
    rolling = false,
    saveUninitialized = false,
    resave = false
  } = options2;
  const cookieOptions = {
    httpOnly: true,
    sameSite: "Lax",
    path: "/",
    ...cookie,
    maxAge: Math.floor(maxAge / 1000)
  };
  return (handler) => {
    return async (ctx) => {
      const cookies = parseCookies(ctx.headers.cookie || "");
      const signedId = cookies[name];
      let sessionId = signedId ? verifySessionId(signedId, secret) : null;
      let isNew = false;
      let sessionData = {};
      if (sessionId) {
        const existing = await store.get(sessionId);
        if (existing) {
          sessionData = existing;
        } else {
          sessionId = null;
        }
      }
      if (!sessionId) {
        sessionId = genid();
        isNew = true;
      }
      const currentSessionId = sessionId;
      let modified = false;
      let destroyed = false;
      let touched = false;
      let regenerated = false;
      let newSessionId = sessionId;
      const sessionObj = {
        id: sessionId,
        data: new Proxy(sessionData, {
          set: (target, prop, value) => {
            target[prop] = value;
            modified = true;
            return true;
          },
          deleteProperty: (target, prop) => {
            delete target[prop];
            modified = true;
            return true;
          }
        }),
        isNew,
        get isModified() {
          return modified;
        },
        regenerate: async () => {
          await store.destroy(currentSessionId);
          newSessionId = genid();
          regenerated = true;
          modified = true;
        },
        destroy: async () => {
          await store.destroy(currentSessionId);
          destroyed = true;
        },
        touch: () => {
          touched = true;
        },
        save: async () => {
          if (!destroyed) {
            await store.set(newSessionId, sessionData, maxAge);
          }
        }
      };
      sessionMap.set(ctx, sessionObj);
      const res = await handler(ctx);
      let setCookieHeader;
      if (destroyed) {
        setCookieHeader = serializeCookie(name, "", { ...cookieOptions, maxAge: 0 });
      } else if (modified || regenerated || isNew && saveUninitialized || resave) {
        await store.set(newSessionId, sessionData, maxAge);
        setCookieHeader = serializeCookie(name, signSessionId(newSessionId, secret), cookieOptions);
      } else if (touched || rolling) {
        await store.touch(newSessionId, maxAge);
        if (rolling) {
          setCookieHeader = serializeCookie(name, signSessionId(newSessionId, secret), cookieOptions);
        }
      }
      if (setCookieHeader) {
        return {
          ...res,
          headers: {
            ...res.headers,
            "set-cookie": setCookieHeader
          }
        };
      }
      return res;
    };
  };
};
var flash = (ctx, key, value) => {
  const sess = getSession(ctx);
  if (!sess)
    return;
  const flashKey = `_flash_${key}`;
  if (value !== undefined) {
    const existing = sess.data[flashKey];
    sess.data[flashKey] = existing ? [...existing, value] : [value];
    return;
  } else {
    const messages = sess.data[flashKey];
    if (messages) {
      delete sess.data[flashKey];
    }
    return messages;
  }
};
// src/sse.ts
import { EventEmitter as EventEmitter3 } from "node:events";
var formatSSEEvent = (event) => {
  let result = "";
  if (event.id !== undefined) {
    result += `id: ${event.id}
`;
  }
  if (event.event !== undefined) {
    result += `event: ${event.event}
`;
  }
  if (event.retry !== undefined) {
    result += `retry: ${event.retry}
`;
  }
  const data = typeof event.data === "string" ? event.data : JSON.stringify(event.data);
  for (const line of data.split(`
`)) {
    result += `data: ${line}
`;
  }
  result += `
`;
  return result;
};
var sseEvent = (data, id) => {
  return formatSSEEvent({ data, id });
};
var createAsyncQueue = () => {
  const queue = [];
  let resolve = null;
  let finished = false;
  let lastError = null;
  const push = (value) => {
    if (finished)
      return;
    if (resolve) {
      resolve({ value, done: false });
      resolve = null;
    } else {
      queue.push(value);
    }
  };
  const done = () => {
    finished = true;
    if (resolve) {
      resolve({ value: undefined, done: true });
      resolve = null;
    }
  };
  const error = (err) => {
    lastError = err;
    finished = true;
    if (resolve) {
      resolve({ value: undefined, done: true });
      resolve = null;
    }
  };
  const iterator = {
    [Symbol.asyncIterator]() {
      return this;
    },
    async next() {
      if (lastError)
        throw lastError;
      if (queue.length > 0) {
        return { value: queue.shift(), done: false };
      }
      if (finished) {
        return { value: undefined, done: true };
      }
      return new Promise((res) => {
        resolve = res;
      });
    },
    async return() {
      finished = true;
      return { value: undefined, done: true };
    },
    async throw(err) {
      finished = true;
      throw err;
    }
  };
  return { push, done, error, iterator };
};
var isGenerator = (source) => {
  return source.length === 0;
};
var sse = (source, options2) => {
  const headers = {
    "content-type": "text/event-stream",
    "cache-control": "no-cache",
    connection: "keep-alive",
    "x-accel-buffering": "no",
    ...options2?.headers
  };
  if (isGenerator(source)) {
    const generator = source();
    async function* encode() {
      const encoder = new TextEncoder;
      for await (const event of generator) {
        yield encoder.encode(formatSSEEvent(event));
      }
    }
    return {
      status: options2?.status ?? 200,
      headers,
      body: encode()
    };
  } else {
    const { push, done, error, iterator } = createAsyncQueue();
    let cleanup;
    (async () => {
      try {
        cleanup = await source(push);
      } catch (err) {
        error(err instanceof Error ? err : new Error(String(err)));
      }
    })();
    async function* encode() {
      const encoder = new TextEncoder;
      try {
        for await (const event of iterator) {
          yield encoder.encode(formatSSEEvent(event));
        }
      } finally {
        done();
        cleanup?.();
      }
    }
    return {
      status: options2?.status ?? 200,
      headers,
      body: encode()
    };
  }
};
var formatSSE = (msg) => {
  let message = "";
  if (msg.id)
    message += `id: ${msg.id}
`;
  if (msg.event)
    message += `event: ${msg.event}
`;
  if (msg.retry !== undefined)
    message += `retry: ${msg.retry}
`;
  const data = typeof msg.data === "string" ? msg.data : JSON.stringify(msg.data);
  for (const line of data.split(`
`)) {
    message += `data: ${line}
`;
  }
  message += `
`;
  return message;
};
var sseRaw = (source, init) => ({
  status: init?.status ?? 200,
  headers: {
    "content-type": "text/event-stream",
    "cache-control": "no-cache",
    connection: "keep-alive",
    "x-accel-buffering": "no",
    ...init?.headers
  },
  body: typeof source === "function" ? source() : source
});
var sseStream = (source, init) => {
  const iterable = typeof source === "function" ? source() : source;
  async function* generate() {
    const encoder = new TextEncoder;
    for await (const event of iterable) {
      yield encoder.encode(formatSSEEvent(event));
    }
  }
  return sseRaw(generate(), init);
};
async function* textStream(source) {
  const encoder = new TextEncoder;
  const iterable = typeof source === "function" ? source() : source;
  for await (const text of iterable) {
    yield encoder.encode(text);
  }
}
var nativeSSE = (server, handler, options2) => {
  const writerId = server.createSseWriter();
  const writer = {
    id: writerId,
    send: (data) => server.sendSse(writerId, data),
    sendEvent: (data, id, event) => server.sendSseEvent(writerId, data, id, event),
    close: () => server.closeSse(writerId)
  };
  (async () => {
    try {
      await handler(writer);
    } catch (err) {
      console.error("SSE handler error:", err);
    } finally {
      writer.close();
    }
  })();
  return {
    status: options2?.status ?? 200,
    headers: {
      "content-type": "text/event-stream",
      "cache-control": "no-cache",
      connection: "keep-alive",
      "x-accel-buffering": "no",
      ...options2?.headers
    },
    body: "",
    sseWriterId: writerId
  };
};
var isNativeSSEAvailable = () => true;

class SSEClient extends EventEmitter3 {
  socket;
  closed = false;
  lastEventId = null;
  constructor(socket, lastEventId) {
    super();
    this.socket = socket;
    this.lastEventId = lastEventId || null;
    this.setupSocket();
  }
  setupSocket() {
    this.socket.on("close", () => {
      this.closed = true;
      this.emit("close");
    });
    this.socket.on("error", (err) => {
      this.emit("error", err);
    });
  }
  send(msg) {
    if (this.closed)
      return false;
    let message = "";
    if (msg.id) {
      message += `id: ${msg.id}
`;
      this.lastEventId = msg.id;
    }
    if (msg.event)
      message += `event: ${msg.event}
`;
    if (msg.retry !== undefined)
      message += `retry: ${msg.retry}
`;
    const data = typeof msg.data === "string" ? msg.data : JSON.stringify(msg.data);
    for (const line of data.split(`
`)) {
      message += `data: ${line}
`;
    }
    message += `
`;
    return this.socket.write(message);
  }
  comment(text) {
    if (this.closed)
      return false;
    return this.socket.write(`: ${text}

`);
  }
  ping() {
    return this.comment("ping");
  }
  close() {
    if (this.closed)
      return;
    this.closed = true;
    this.socket.end();
  }
  get isOpen() {
    return !this.closed;
  }
  get eventId() {
    return this.lastEventId;
  }
}
var sseHeaders = () => {
  return [
    "HTTP/1.1 200 OK",
    "Content-Type: text/event-stream",
    "Cache-Control: no-cache",
    "Connection: keep-alive",
    "X-Accel-Buffering: no",
    "",
    ""
  ].join(`\r
`);
};
var createSSE = (socket, headers) => {
  socket.write(sseHeaders());
  const lastEventId = headers["last-event-id"];
  return new SSEClient(socket, lastEventId);
};
// src/static.ts
import { readFile, stat as stat2 } from "node:fs/promises";
import { extname as extname2, join as join3, normalize } from "node:path";
import { notFound as notFound2, response as response7 } from "@sylphx/gust-core";
var MIME_TYPES = {
  ".html": "text/html; charset=utf-8",
  ".htm": "text/html; charset=utf-8",
  ".css": "text/css; charset=utf-8",
  ".js": "text/javascript; charset=utf-8",
  ".mjs": "text/javascript; charset=utf-8",
  ".json": "application/json; charset=utf-8",
  ".xml": "application/xml; charset=utf-8",
  ".txt": "text/plain; charset=utf-8",
  ".md": "text/markdown; charset=utf-8",
  ".csv": "text/csv; charset=utf-8",
  ".png": "image/png",
  ".jpg": "image/jpeg",
  ".jpeg": "image/jpeg",
  ".gif": "image/gif",
  ".svg": "image/svg+xml",
  ".ico": "image/x-icon",
  ".webp": "image/webp",
  ".avif": "image/avif",
  ".woff": "font/woff",
  ".woff2": "font/woff2",
  ".ttf": "font/ttf",
  ".otf": "font/otf",
  ".eot": "application/vnd.ms-fontobject",
  ".mp3": "audio/mpeg",
  ".mp4": "video/mp4",
  ".webm": "video/webm",
  ".ogg": "audio/ogg",
  ".wav": "audio/wav",
  ".pdf": "application/pdf",
  ".zip": "application/zip",
  ".gz": "application/gzip",
  ".tar": "application/x-tar",
  ".wasm": "application/wasm",
  ".map": "application/json"
};
var getMimeType2 = (path) => {
  const ext = extname2(path).toLowerCase();
  return MIME_TYPES[ext] || "application/octet-stream";
};
var generateEtag = (size, mtime) => {
  return `"${size.toString(16)}-${mtime.toString(16)}"`;
};
var isSafePath = (requestPath, root) => {
  const normalizedPath = normalize(requestPath).replace(/^(\.\.[/\\])+/, "");
  const fullPath = join3(root, normalizedPath);
  if (!fullPath.startsWith(root)) {
    return null;
  }
  return fullPath;
};
var serveStatic = (options2) => {
  const {
    root,
    index = ["index.html"],
    maxAge = 0,
    immutable = false,
    dotfiles = "ignore",
    etag: etag2 = true,
    lastModified = true
  } = options2;
  const indexFiles = Array.isArray(index) ? index : [index];
  return async (ctx) => {
    if (ctx.method !== "GET" && ctx.method !== "HEAD") {
      return notFound2();
    }
    const requestPath = ctx.path;
    const pathParts = requestPath.split("/");
    const hasDotfile = pathParts.some((part) => part.startsWith(".") && part !== "." && part !== "..");
    if (hasDotfile) {
      if (dotfiles === "deny") {
        return response7(null, { status: 403, headers: {} });
      }
      if (dotfiles === "ignore") {
        return notFound2();
      }
    }
    const safePath = isSafePath(requestPath, root);
    if (!safePath) {
      return response7(null, { status: 403, headers: {} });
    }
    let filePath = safePath;
    let stats;
    try {
      stats = await stat2(filePath);
      if (stats.isDirectory()) {
        let found = false;
        for (const indexFile of indexFiles) {
          const indexPath = join3(filePath, indexFile);
          try {
            stats = await stat2(indexPath);
            if (stats.isFile()) {
              filePath = indexPath;
              found = true;
              break;
            }
          } catch {}
        }
        if (!found) {
          return notFound2();
        }
      }
    } catch {
      return notFound2();
    }
    if (!stats.isFile()) {
      return notFound2();
    }
    const headers = {
      "content-type": getMimeType2(filePath)
    };
    if (maxAge > 0 || immutable) {
      const parts = [];
      if (maxAge > 0) {
        parts.push(`max-age=${maxAge}`);
      }
      if (immutable) {
        parts.push("immutable");
      }
      headers["cache-control"] = parts.join(", ");
    }
    if (etag2) {
      headers.etag = generateEtag(stats.size, stats.mtimeMs);
    }
    if (lastModified) {
      headers["last-modified"] = stats.mtime.toUTCString();
    }
    const ifNoneMatch = ctx.headers["if-none-match"];
    const ifModifiedSince = ctx.headers["if-modified-since"];
    if (etag2 && ifNoneMatch) {
      const currentEtag = headers.etag;
      if (ifNoneMatch === currentEtag || ifNoneMatch === `W/${currentEtag}`) {
        return response7(null, { status: 304, headers });
      }
    }
    if (lastModified && ifModifiedSince) {
      const modifiedDate = new Date(ifModifiedSince);
      if (stats.mtime <= modifiedDate) {
        return response7(null, { status: 304, headers });
      }
    }
    if (ctx.method === "HEAD") {
      headers["content-length"] = stats.size.toString();
      return response7(null, { status: 200, headers });
    }
    const content = await readFile(filePath);
    return response7(content.toString(), { status: 200, headers });
  };
};
// src/stream.ts
import { EventEmitter as EventEmitter4 } from "node:events";

class StreamWriter extends EventEmitter4 {
  socket;
  closed = false;
  headersSent = false;
  constructor(socket) {
    super();
    this.socket = socket;
    this.setupSocket();
  }
  setupSocket() {
    this.socket.on("close", () => {
      this.closed = true;
      this.emit("close");
    });
    this.socket.on("error", (err) => {
      this.emit("error", err);
    });
  }
  writeHead(status, headers = {}) {
    if (this.headersSent)
      return false;
    if (this.closed)
      return false;
    const statusText = getStatusText(status);
    let head2 = `HTTP/1.1 ${status} ${statusText}\r
`;
    for (const [key, value] of Object.entries(headers)) {
      if (key.toLowerCase() !== "content-length") {
        head2 += `${key}: ${value}\r
`;
      }
    }
    head2 += `transfer-encoding: chunked\r
`;
    head2 += `connection: keep-alive\r
`;
    head2 += `\r
`;
    this.headersSent = true;
    return this.socket.write(head2);
  }
  write(data) {
    if (this.closed)
      return false;
    if (!this.headersSent) {
      this.writeHead(200, { "content-type": "text/plain" });
    }
    const chunk = typeof data === "string" ? Buffer.from(data) : data;
    if (chunk.length === 0)
      return true;
    const sizeHex = chunk.length.toString(16);
    this.socket.write(`${sizeHex}\r
`);
    this.socket.write(chunk);
    return this.socket.write(`\r
`);
  }
  writeJson(data) {
    return this.write(JSON.stringify(data));
  }
  end(data) {
    if (this.closed)
      return;
    if (data) {
      this.write(data);
    }
    this.socket.write(`0\r
\r
`);
    this.closed = true;
    this.emit("finish");
  }
  get isOpen() {
    return !this.closed && this.socket.writable;
  }
  get headersWritten() {
    return this.headersSent;
  }
}
var createStream = (socket, status = 200, headers = {}) => {
  const writer = new StreamWriter(socket);
  writer.writeHead(status, headers);
  return writer;
};
var createJsonStream = (socket) => {
  const writer = new StreamWriter(socket);
  writer.writeHead(200, {
    "content-type": "application/x-ndjson",
    "cache-control": "no-cache"
  });
  return writer;
};
var streamFrom = async (writer, source, transform) => {
  try {
    for await (const item of source) {
      if (!writer.isOpen)
        break;
      const data = transform ? transform(item) : typeof item === "string" ? item : `${JSON.stringify(item)}
`;
      writer.write(data);
    }
  } finally {
    writer.end();
  }
};
var streamGenerator = async (writer, generator, transform) => {
  return streamFrom(writer, generator(), transform);
};
var pipeStream = (writer, readable) => {
  return new Promise((resolve, reject) => {
    readable.on("data", (chunk) => {
      if (!writer.isOpen) {
        if ("destroy" in readable && typeof readable.destroy === "function") {
          readable.destroy();
        }
        return;
      }
      writer.write(chunk);
    });
    readable.on("end", () => {
      writer.end();
      resolve();
    });
    readable.on("error", (err) => {
      writer.end();
      reject(err);
    });
    writer.on("close", () => {
      if ("destroy" in readable && typeof readable.destroy === "function") {
        readable.destroy();
      }
      resolve();
    });
  });
};
var getStatusText = (status) => {
  const texts = {
    200: "OK",
    201: "Created",
    204: "No Content",
    206: "Partial Content",
    301: "Moved Permanently",
    302: "Found",
    304: "Not Modified",
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    500: "Internal Server Error"
  };
  return texts[status] || "Unknown";
};
var stream = (source, init) => ({
  status: init?.status ?? 200,
  headers: init?.headers ?? {},
  body: typeof source === "function" ? source() : source
});
var streamText = (source, init) => {
  const iterable = typeof source === "function" ? source() : source;
  async function* generate() {
    const encoder = new TextEncoder;
    for await (const text of iterable) {
      yield encoder.encode(text);
    }
  }
  return {
    status: init?.status ?? 200,
    headers: {
      "content-type": "text/plain; charset=utf-8",
      ...init?.headers
    },
    body: generate()
  };
};
var ndjsonStream = (source, init) => {
  const iterable = typeof source === "function" ? source() : source;
  async function* generate() {
    const encoder = new TextEncoder;
    for await (const item of iterable) {
      yield encoder.encode(`${JSON.stringify(item)}
`);
    }
  }
  return {
    status: init?.status ?? 200,
    headers: {
      "content-type": "application/x-ndjson",
      ...init?.headers
    },
    body: generate()
  };
};
async function* nodeStreamToAsyncIterable(readable) {
  for await (const chunk of readable) {
    if (chunk instanceof Buffer) {
      yield new Uint8Array(chunk);
    } else if (chunk instanceof Uint8Array) {
      yield chunk;
    } else if (typeof chunk === "string") {
      yield new TextEncoder().encode(chunk);
    }
  }
}
var streamFile2 = (readable, init) => ({
  status: init?.status ?? 200,
  headers: {
    "content-type": "application/octet-stream",
    ...init?.headers
  },
  body: nodeStreamToAsyncIterable(readable)
});
// src/validate.ts
import { response as response8 } from "@sylphx/gust-core";
var formats = {
  email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
  url: /^https?:\/\/.+/,
  uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,
  date: /^\d{4}-\d{2}-\d{2}$/,
  datetime: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?(Z|[+-]\d{2}:\d{2})?$/
};
var validateSchema = (value, schema, path = "") => {
  const errors = [];
  if (value === null) {
    if (schema.nullable)
      return [];
    errors.push({ path, message: "Value cannot be null", value });
    return errors;
  }
  if (value === undefined) {
    if (!schema.required)
      return [];
    errors.push({ path, message: "Value is required", value });
    return errors;
  }
  switch (schema.type) {
    case "string":
      if (typeof value !== "string") {
        errors.push({ path, message: `Expected string, got ${typeof value}`, value });
        return errors;
      }
      if (schema.minLength !== undefined && value.length < schema.minLength) {
        errors.push({ path, message: `Minimum length is ${schema.minLength}`, value });
      }
      if (schema.maxLength !== undefined && value.length > schema.maxLength) {
        errors.push({ path, message: `Maximum length is ${schema.maxLength}`, value });
      }
      if (schema.pattern) {
        const regex = typeof schema.pattern === "string" ? new RegExp(schema.pattern) : schema.pattern;
        if (!regex.test(value)) {
          errors.push({ path, message: `Does not match pattern ${regex}`, value });
        }
      }
      if (schema.format) {
        const formatRegex = formats[schema.format];
        if (formatRegex && !formatRegex.test(value)) {
          errors.push({ path, message: `Invalid ${schema.format} format`, value });
        }
      }
      if (schema.enum && !schema.enum.includes(value)) {
        errors.push({ path, message: `Must be one of: ${schema.enum.join(", ")}`, value });
      }
      break;
    case "number":
      if (typeof value !== "number" || Number.isNaN(value)) {
        errors.push({ path, message: `Expected number, got ${typeof value}`, value });
        return errors;
      }
      if (schema.integer && !Number.isInteger(value)) {
        errors.push({ path, message: "Must be an integer", value });
      }
      if (schema.min !== undefined && value < schema.min) {
        errors.push({ path, message: `Minimum value is ${schema.min}`, value });
      }
      if (schema.max !== undefined && value > schema.max) {
        errors.push({ path, message: `Maximum value is ${schema.max}`, value });
      }
      break;
    case "boolean":
      if (typeof value !== "boolean") {
        errors.push({ path, message: `Expected boolean, got ${typeof value}`, value });
      }
      break;
    case "object":
      if (typeof value !== "object" || Array.isArray(value)) {
        errors.push({
          path,
          message: `Expected object, got ${Array.isArray(value) ? "array" : typeof value}`,
          value
        });
        return errors;
      }
      if (schema.properties) {
        for (const [key, propSchema] of Object.entries(schema.properties)) {
          const propPath = path ? `${path}.${key}` : key;
          const propValue = value[key];
          errors.push(...validateSchema(propValue, propSchema, propPath));
        }
        if (schema.additionalProperties === false) {
          const allowedKeys = new Set(Object.keys(schema.properties));
          for (const key of Object.keys(value)) {
            if (!allowedKeys.has(key)) {
              const propPath = path ? `${path}.${key}` : key;
              errors.push({
                path: propPath,
                message: "Additional property not allowed",
                value: key
              });
            }
          }
        }
      }
      break;
    case "array":
      if (!Array.isArray(value)) {
        errors.push({ path, message: `Expected array, got ${typeof value}`, value });
        return errors;
      }
      if (schema.minItems !== undefined && value.length < schema.minItems) {
        errors.push({ path, message: `Minimum items is ${schema.minItems}`, value });
      }
      if (schema.maxItems !== undefined && value.length > schema.maxItems) {
        errors.push({ path, message: `Maximum items is ${schema.maxItems}`, value });
      }
      if (schema.uniqueItems) {
        const seen = new Set;
        for (const item of value) {
          const key = JSON.stringify(item);
          if (seen.has(key)) {
            errors.push({ path, message: "Array items must be unique", value });
            break;
          }
          seen.add(key);
        }
      }
      if (schema.items) {
        for (let i = 0;i < value.length; i++) {
          errors.push(...validateSchema(value[i], schema.items, `${path}[${i}]`));
        }
      }
      break;
    case "any":
      break;
  }
  if (schema.custom && errors.length === 0) {
    const result = schema.custom(value);
    if (result !== true) {
      errors.push({
        path,
        message: typeof result === "string" ? result : "Custom validation failed",
        value
      });
    }
  }
  return errors;
};
var createValidator = (schema) => ({
  validate: (data) => {
    const errors = validateSchema(data, schema);
    if (errors.length === 0) {
      return { valid: true, data };
    }
    return { valid: false, errors };
  }
});
var string = (options2 = {}) => ({
  type: "string",
  required: true,
  ...options2
});
var number = (options2 = {}) => ({
  type: "number",
  required: true,
  ...options2
});
var boolean = (options2 = {}) => ({
  type: "boolean",
  required: true,
  ...options2
});
var object = (properties, options2 = {}) => ({
  type: "object",
  required: true,
  properties,
  ...options2
});
var array = (items, options2 = {}) => ({
  type: "array",
  required: true,
  items,
  ...options2
});
var email = (options2 = {}) => string({ format: "email", ...options2 });
var url = (options2 = {}) => string({ format: "url", ...options2 });
var uuid = (options2 = {}) => string({ format: "uuid", ...options2 });
var optional = (schema) => ({
  ...schema,
  required: false
});
var nullable = (schema) => ({
  ...schema,
  nullable: true
});
var validatedDataMap = new WeakMap;
var getValidated = (ctx) => {
  const data = validatedDataMap.get(ctx);
  return data?.body;
};
var getValidatedQuery = (ctx) => {
  const data = validatedDataMap.get(ctx);
  return data?.query;
};
var validate = (options2) => {
  const { body: bodySchema, query: querySchema, params: paramsSchema, onError } = options2;
  const errorResponse = onError ?? ((errors) => response8(JSON.stringify({
    error: "Validation Error",
    details: errors
  }), {
    status: 400,
    headers: { "content-type": "application/json" }
  }));
  return (handler) => {
    return async (ctx) => {
      const allErrors = [];
      const validated = {};
      if (bodySchema && ctx.body?.length > 0) {
        const contentType = ctx.headers["content-type"] || "";
        let bodyData;
        try {
          if (contentType.includes("application/json")) {
            bodyData = parseJsonBody(ctx.body);
          } else if (contentType.includes("application/x-www-form-urlencoded")) {
            bodyData = parseFormBody(ctx.body);
          } else {
            bodyData = ctx.body.toString();
          }
        } catch {
          allErrors.push({ path: "body", message: "Invalid body format" });
        }
        if (bodyData !== undefined) {
          const errors = validateSchema(bodyData, bodySchema, "body");
          if (errors.length > 0) {
            allErrors.push(...errors);
          } else {
            validated.body = bodyData;
          }
        }
      }
      if (querySchema && ctx.query) {
        const queryData = parseQuery(ctx.query.slice(1));
        const errors = validateSchema(queryData, querySchema, "query");
        if (errors.length > 0) {
          allErrors.push(...errors);
        } else {
          validated.query = queryData;
        }
      }
      if (paramsSchema && ctx.params) {
        const errors = validateSchema(ctx.params, paramsSchema, "params");
        if (errors.length > 0) {
          allErrors.push(...errors);
        } else {
          validated.params = ctx.params;
        }
      }
      if (allErrors.length > 0) {
        return errorResponse(allErrors);
      }
      validatedDataMap.set(ctx, validated);
      return handler(ctx);
    };
  };
};
var validateBody = (schema) => validate({ body: schema });
var validateQuery = (schema) => validate({ query: schema });

// src/index.ts
init_wasm_loader();

// src/websocket.ts
init_native();
import { EventEmitter as EventEmitter5 } from "node:events";
var OPCODE = {
  CONTINUATION: 0,
  TEXT: 1,
  BINARY: 2,
  CLOSE: 8,
  PING: 9,
  PONG: 10
};

class WebSocket extends EventEmitter5 {
  socket;
  closed = false;
  fragments = [];
  fragmentOpcode = 0;
  constructor(socket) {
    super();
    this.socket = socket;
    this.setupSocket();
  }
  setupSocket() {
    let buffer = Buffer.alloc(0);
    this.socket.on("data", (chunk) => {
      buffer = Buffer.concat([buffer, chunk]);
      buffer = this.processFrames(buffer);
    });
    this.socket.on("close", () => {
      if (!this.closed) {
        this.closed = true;
        this.emit("close", 1006, "Connection closed abnormally");
      }
    });
    this.socket.on("error", (err) => {
      this.emit("error", err);
    });
  }
  processFrames(buffer) {
    while (buffer.length >= 2) {
      const firstByte = buffer[0] ?? 0;
      const secondByte = buffer[1] ?? 0;
      const fin = (firstByte & 128) !== 0;
      const opcode = firstByte & 15;
      const masked = (secondByte & 128) !== 0;
      let payloadLen = secondByte & 127;
      let offset = 2;
      if (payloadLen === 126) {
        if (buffer.length < 4)
          return buffer;
        payloadLen = buffer.readUInt16BE(2);
        offset = 4;
      } else if (payloadLen === 127) {
        if (buffer.length < 10)
          return buffer;
        payloadLen = Number(buffer.readBigUInt64BE(2));
        offset = 10;
      }
      let maskKey = null;
      if (masked) {
        if (buffer.length < offset + 4)
          return buffer;
        maskKey = buffer.subarray(offset, offset + 4);
        offset += 4;
      }
      if (buffer.length < offset + payloadLen)
        return buffer;
      let payload = buffer.subarray(offset, offset + payloadLen);
      if (maskKey) {
        payload = Buffer.from(payload);
        for (let i = 0;i < payload.length; i++) {
          const payloadByte = payload[i] ?? 0;
          const maskByte = maskKey[i % 4] ?? 0;
          payload[i] = payloadByte ^ maskByte;
        }
      }
      this.handleFrame(fin, opcode, payload);
      buffer = buffer.subarray(offset + payloadLen);
    }
    return buffer;
  }
  handleFrame(fin, opcode, payload) {
    switch (opcode) {
      case OPCODE.CONTINUATION:
        this.fragments.push(payload);
        if (fin) {
          const fullPayload = Buffer.concat(this.fragments);
          this.fragments = [];
          if (this.fragmentOpcode === OPCODE.TEXT) {
            this.emit("message", { type: "text", data: fullPayload.toString("utf8") });
          } else {
            this.emit("message", { type: "binary", data: fullPayload });
          }
        }
        break;
      case OPCODE.TEXT:
        if (fin) {
          this.emit("message", { type: "text", data: payload.toString("utf8") });
        } else {
          this.fragmentOpcode = OPCODE.TEXT;
          this.fragments.push(payload);
        }
        break;
      case OPCODE.BINARY:
        if (fin) {
          this.emit("message", { type: "binary", data: payload });
        } else {
          this.fragmentOpcode = OPCODE.BINARY;
          this.fragments.push(payload);
        }
        break;
      case OPCODE.CLOSE: {
        const code = payload.length >= 2 ? payload.readUInt16BE(0) : 1000;
        const reason = payload.length > 2 ? payload.subarray(2).toString("utf8") : "";
        this.closed = true;
        this.sendFrame(OPCODE.CLOSE, payload);
        this.socket.end();
        this.emit("close", code, reason);
        break;
      }
      case OPCODE.PING:
        this.emit("ping", payload);
        this.sendFrame(OPCODE.PONG, payload);
        break;
      case OPCODE.PONG:
        this.emit("pong", payload);
        break;
    }
  }
  sendFrame(opcode, payload) {
    if (this.closed)
      return;
    let nativeFrame = null;
    switch (opcode) {
      case OPCODE.TEXT:
        nativeFrame = nativeEncodeWebSocketText(payload.toString("utf8"), true);
        break;
      case OPCODE.BINARY:
        nativeFrame = nativeEncodeWebSocketBinary(payload, true);
        break;
      case OPCODE.PING:
        nativeFrame = nativeEncodeWebSocketPing(payload);
        break;
      case OPCODE.PONG:
        nativeFrame = nativeEncodeWebSocketPong(payload);
        break;
      case OPCODE.CLOSE:
        if (payload.length >= 2) {
          const code = payload.readUInt16BE(0);
          const reason = payload.length > 2 ? payload.subarray(2).toString("utf8") : undefined;
          nativeFrame = nativeEncodeWebSocketClose(code, reason);
        } else {
          nativeFrame = nativeEncodeWebSocketClose();
        }
        break;
    }
    if (!nativeFrame) {
      throw new Error("WebSocket frame encoding unavailable (native/WASM not loaded)");
    }
    this.socket.write(nativeFrame);
  }
  send(data) {
    if (typeof data === "string") {
      this.sendFrame(OPCODE.TEXT, Buffer.from(data, "utf8"));
    } else {
      this.sendFrame(OPCODE.BINARY, data);
    }
  }
  ping(data) {
    this.sendFrame(OPCODE.PING, data || Buffer.alloc(0));
  }
  close(code = 1000, reason = "") {
    if (this.closed)
      return;
    this.closed = true;
    const reasonBuf = Buffer.from(reason, "utf8");
    const payload = Buffer.alloc(2 + reasonBuf.length);
    payload.writeUInt16BE(code, 0);
    reasonBuf.copy(payload, 2);
    this.sendFrame(OPCODE.CLOSE, payload);
    this.socket.end();
  }
  get isOpen() {
    return !this.closed;
  }
}
var generateAcceptKey = (key) => {
  const native = nativeGenerateWebSocketAccept(key);
  if (!native) {
    throw new Error("WebSocket accept key generation unavailable (native/WASM not loaded)");
  }
  return native;
};
var isWebSocketUpgrade = (headers) => {
  const upgrade = headers.upgrade?.toLowerCase();
  const connection = headers.connection?.toLowerCase();
  return upgrade === "websocket" && (connection?.includes("upgrade") ?? false);
};
var createHandshakeResponse = (key) => {
  const acceptKey = generateAcceptKey(key);
  return [
    "HTTP/1.1 101 Switching Protocols",
    "Upgrade: websocket",
    "Connection: Upgrade",
    `Sec-WebSocket-Accept: ${acceptKey}`,
    "",
    ""
  ].join(`\r
`);
};
var upgradeToWebSocket = (socket, headers) => {
  const key = headers["sec-websocket-key"];
  if (!key) {
    return null;
  }
  socket.write(createHandshakeResponse(key));
  return new WebSocket(socket);
};
var websocket = (handler) => {
  return {
    isWebSocket: true,
    handler
  };
};
var createMessageIterable = (ws) => {
  return {
    [Symbol.asyncIterator]() {
      const queue = [];
      const waiters = [];
      let closed = false;
      let closeError = null;
      ws.on("message", (msg) => {
        const waiter = waiters.shift();
        if (waiter) {
          waiter.resolve({ value: msg, done: false });
        } else {
          queue.push(msg);
        }
      });
      ws.on("close", () => {
        closed = true;
        for (const waiter of waiters) {
          waiter.resolve({ value: undefined, done: true });
        }
        waiters.length = 0;
      });
      ws.on("error", (err) => {
        closed = true;
        closeError = err;
        for (const waiter of waiters) {
          waiter.reject(err);
        }
        waiters.length = 0;
      });
      return {
        next() {
          const queued = queue.shift();
          if (queued !== undefined) {
            return Promise.resolve({ value: queued, done: false });
          }
          if (closed) {
            if (closeError) {
              return Promise.reject(closeError);
            }
            return Promise.resolve({ value: undefined, done: true });
          }
          return new Promise((resolve, reject) => {
            waiters.push({ resolve, reject });
          });
        }
      };
    }
  };
};
var createWebSocketSession = (ws) => {
  let closeResolve = null;
  const closedPromise = new Promise((resolve) => {
    closeResolve = resolve;
  });
  ws.on("close", (code, reason) => {
    closeResolve?.({ code, reason });
  });
  return {
    messages: createMessageIterable(ws),
    send: (data) => ws.send(data),
    ping: (data) => ws.ping(data),
    close: (code, reason) => ws.close(code, reason),
    closed: closedPromise,
    get isOpen() {
      return ws.isOpen;
    }
  };
};
var websocketSession = (handler) => {
  return {
    isWebSocket: true,
    handler: (ws, headers) => {
      const session2 = createWebSocketSession(ws);
      handler(session2, headers).catch((err) => {
        console.error("WebSocket session error:", err);
        ws.close(1011, "Internal Error");
      });
    }
  };
};
export {
  withParams,
  withCircuitBreaker,
  withApp,
  websocketSession,
  websocket,
  verifyJwt,
  verifyHmac,
  verifyCsrfToken,
  varyingCacheKey,
  validateSchema,
  validateQuery,
  validateBody,
  validate,
  uuid,
  url,
  uploadLimit,
  upgradeToWebSocket,
  unauthorized2 as unauthorized,
  trustLocalProxy,
  trustFirstProxy,
  tracing,
  textStream,
  text,
  stringifyQuery,
  string,
  strictSecurity,
  streamText,
  streamGenerator,
  streamFrom,
  streamFile2 as streamFile,
  stream,
  stickySession,
  startup,
  startChildSpan,
  sseStream,
  sseRaw,
  sseHeaders,
  sseEvent,
  sse,
  simpleCors,
  simpleBasicAuth,
  simpleApiKey,
  setCookies,
  setCookie,
  session,
  serverError3 as serverError,
  serveStatic,
  serveRangeFile,
  serveHttp2,
  serve,
  serializeCookie,
  security,
  runHealthChecks,
  runCluster,
  routes,
  response9 as response,
  redirect,
  readiness,
  rateLimitWithStore,
  rateLimit,
  rangeServer,
  put,
  pushResources,
  pushResource,
  proxy,
  prometheusMetrics,
  preloadHint,
  preload,
  post,
  pipeStream,
  pipe,
  patch,
  parseTracestate,
  parseTraceparent,
  parseSize,
  parseRange,
  parseQuery,
  parseMultipart,
  parseJsonBody,
  parseHeaders,
  parseFormBody,
  parseCookies,
  parseBearerToken,
  parseBasicAuth,
  otel,
  options,
  optionalJwt,
  optional,
  object,
  number,
  nullable,
  notFound3 as notFound,
  nodeStreamToAsyncIterable,
  noCache,
  ndjsonStream,
  nativeSSE,
  metrics,
  memoryCheck,
  logging,
  liveness,
  largeUploadLimit,
  jwtAuth,
  jsonLimit,
  json3 as json,
  isWorker,
  isWebSocketUpgrade,
  isWasmReady,
  isStreamingBody2 as isStreamingBody,
  isWasmAvailable as isServeWasmAvailable,
  isRangeSatisfiable,
  isPrimary,
  isNativeSSEAvailable,
  isMultipartContent,
  isJwtExpired,
  isJsonContent,
  isHttp2,
  isFormContent,
  isCluster,
  invalidateCache,
  initWasm3 as initWasm,
  initWasm as initServeWasm,
  httpCheck,
  html,
  hmacAuth,
  healthCheck,
  health,
  head,
  gzip,
  getWasm2 as getWasm,
  getValidatedQuery,
  getValidated,
  getSpan,
  getSession,
  getRequestId,
  getRange,
  getProxyInfo,
  getMetrics,
  getJwtPayload,
  getCsrfToken,
  getCookies,
  getCookie,
  getContentType,
  getClusterInfo,
  getClientIp,
  getCircuitBreaker,
  getAlpnProtocol,
  get,
  generateUUID,
  generateTraceId,
  generateSpanId,
  generateShortId,
  generateSessionId,
  generateNanoId,
  generateHmac,
  generateCsrfToken,
  generateAcceptKey,
  formatTracestate,
  formatTraceparent,
  formatSize,
  formatSSEEvent,
  formatSSE,
  forbidden2 as forbidden,
  flash,
  extractBoundary,
  eventLoopCheck,
  etag,
  email,
  deleteCookie,
  del,
  defaultCacheKey,
  decodeJwt,
  customCheck,
  csrfMeta,
  csrfField,
  csrfDoubleSubmit,
  csrf,
  createWebSocketSession,
  createValidator,
  createTracer,
  createStream,
  createSSE,
  createRouter,
  createRawContext,
  createOtlpExporter,
  createJwt,
  createJsonStream,
  createHandshakeResponse,
  createContext,
  createBasicAuth,
  cors,
  contentRange,
  consoleExporter,
  compress,
  compose,
  clusterServe,
  circuitBreaker,
  cache,
  bulkhead,
  brotli,
  boolean,
  bodyLimit,
  bearerAuth,
  basicAuth,
  badRequest,
  array,
  apiSecurity,
  apiKeyAuth,
  all,
  acceptsRange,
  WebSocket,
  StreamWriter,
  SSEClient,
  MetricsCollector,
  MemoryStore,
  MemoryCache,
  LRUCache,
  ClusterManager,
  CircuitBreaker
};
