import { z as z2 } from "zod";
/**
* Model Context Protocol Types
* Based on MCP specification 2025-03-26
*/
declare const LATEST_PROTOCOL_VERSION: "2025-03-26";
declare const SUPPORTED_PROTOCOL_VERSIONS: readonly ["2025-03-26", "2024-11-05"];
interface TextContent {
	readonly type: "text";
	readonly text: string;
	readonly annotations?: ContentAnnotations;
}
interface ImageContent {
	readonly type: "image";
	readonly data: string;
	readonly mimeType: string;
	readonly annotations?: ContentAnnotations;
}
interface AudioContent {
	readonly type: "audio";
	readonly data: string;
	readonly mimeType: string;
	readonly annotations?: ContentAnnotations;
}
interface ResourceContent {
	readonly type: "resource";
	readonly resource: EmbeddedResource;
	readonly annotations?: ContentAnnotations;
}
type Content = TextContent | ImageContent | AudioContent | ResourceContent;
interface ContentAnnotations {
	readonly audience?: Array<"user" | "assistant">;
	readonly priority?: number;
}
interface Resource {
	readonly uri: string;
	readonly name: string;
	readonly description?: string;
	readonly mimeType?: string;
	readonly size?: number;
}
interface ResourceTemplate {
	readonly uriTemplate: string;
	readonly name: string;
	readonly description?: string;
	readonly mimeType?: string;
}
interface EmbeddedResource {
	readonly type: "resource";
	readonly uri: string;
	readonly mimeType?: string;
	readonly text?: string;
	readonly blob?: string;
}
interface Tool {
	readonly name: string;
	readonly title?: string;
	readonly description?: string;
	readonly inputSchema: JsonSchema;
	readonly outputSchema?: JsonSchema;
	readonly annotations?: ToolAnnotations;
}
interface ToolAnnotations {
	readonly title?: string;
	readonly readOnlyHint?: boolean;
	readonly destructiveHint?: boolean;
	readonly idempotentHint?: boolean;
	readonly openWorldHint?: boolean;
}
interface JsonSchema {
	readonly type?: string;
	readonly properties?: Record<string, JsonSchema>;
	readonly required?: readonly string[];
	readonly items?: JsonSchema;
	readonly enum?: readonly unknown[];
	readonly description?: string;
	readonly default?: unknown;
	readonly [key: string]: unknown;
}
interface Prompt {
	readonly name: string;
	readonly title?: string;
	readonly description?: string;
	readonly arguments?: readonly PromptArgument[];
}
interface PromptArgument {
	readonly name: string;
	readonly description?: string;
	readonly required?: boolean;
}
interface PromptMessage {
	readonly role: "user" | "assistant";
	readonly content: Content;
}
interface ServerCapabilities {
	readonly experimental?: Record<string, unknown>;
	readonly logging?: Record<string, never>;
	readonly completions?: Record<string, never>;
	readonly prompts?: {
		readonly listChanged?: boolean;
	};
	readonly resources?: {
		readonly subscribe?: boolean;
		readonly listChanged?: boolean;
	};
	readonly tools?: {
		readonly listChanged?: boolean;
	};
}
interface ClientCapabilities {
	readonly experimental?: Record<string, unknown>;
	readonly roots?: {
		readonly listChanged?: boolean;
	};
	readonly sampling?: Record<string, never>;
	readonly elicitation?: Record<string, never>;
}
interface Implementation {
	readonly name: string;
	readonly version: string;
}
interface Root {
	readonly uri: string;
	readonly name?: string;
}
type ProgressToken2 = string | number;
interface Progress {
	readonly progress: number;
	readonly total?: number;
	readonly message?: string;
}
type LogLevel2 = "debug" | "info" | "notice" | "warning" | "error" | "critical" | "alert" | "emergency";
interface LogEntry {
	readonly level: LogLevel2;
	readonly logger?: string;
	readonly data?: unknown;
}
declare const Method: {
	readonly Initialize: "initialize";
	readonly Initialized: "notifications/initialized";
	readonly Ping: "ping";
	readonly ResourcesList: "resources/list";
	readonly ResourcesTemplatesList: "resources/templates/list";
	readonly ResourcesRead: "resources/read";
	readonly ResourcesSubscribe: "resources/subscribe";
	readonly ResourcesUnsubscribe: "resources/unsubscribe";
	readonly ResourcesUpdated: "notifications/resources/updated";
	readonly ResourcesListChanged: "notifications/resources/list_changed";
	readonly PromptsList: "prompts/list";
	readonly PromptsGet: "prompts/get";
	readonly PromptsListChanged: "notifications/prompts/list_changed";
	readonly ToolsList: "tools/list";
	readonly ToolsCall: "tools/call";
	readonly ToolsListChanged: "notifications/tools/list_changed";
	readonly LoggingSetLevel: "logging/setLevel";
	readonly LogMessage: "notifications/message";
	readonly CompletionComplete: "completion/complete";
	readonly SamplingCreateMessage: "sampling/createMessage";
	readonly ElicitationCreate: "elicitation/create";
	readonly ProgressNotification: "notifications/progress";
	readonly CancelledNotification: "notifications/cancelled";
	readonly RootsList: "roots/list";
	readonly RootsListChanged: "notifications/roots/list_changed";
};
type Method = (typeof Method)[keyof typeof Method];
interface InitializeParams {
	readonly protocolVersion: string;
	readonly capabilities: ClientCapabilities;
	readonly clientInfo: Implementation;
}
interface InitializeResult {
	readonly protocolVersion: string;
	readonly capabilities: ServerCapabilities;
	readonly serverInfo: Implementation;
	readonly instructions?: string;
}
interface ListParams {
	readonly cursor?: string;
}
interface ResourcesListResult {
	readonly resources: readonly Resource[];
	readonly nextCursor?: string;
}
interface ResourceTemplatesListResult {
	readonly resourceTemplates: readonly ResourceTemplate[];
	readonly nextCursor?: string;
}
interface ResourcesReadParams {
	readonly uri: string;
}
interface ResourcesReadResult {
	readonly contents: readonly EmbeddedResource[];
}
interface PromptsListResult {
	readonly prompts: readonly Prompt[];
	readonly nextCursor?: string;
}
interface PromptsGetParams {
	readonly name: string;
	readonly arguments?: Record<string, string>;
}
interface PromptsGetResult {
	readonly description?: string;
	readonly messages: readonly PromptMessage[];
}
interface ToolsListResult {
	readonly tools: readonly Tool[];
	readonly nextCursor?: string;
}
interface ToolsCallParams {
	readonly name: string;
	readonly arguments?: Record<string, unknown>;
	readonly _meta?: {
		readonly progressToken?: ProgressToken2;
	};
}
interface ToolsCallResult {
	readonly content: readonly Content[];
	readonly isError?: boolean;
	readonly structuredContent?: unknown;
}
interface ProgressParams {
	readonly progressToken: ProgressToken2;
	readonly progress: number;
	readonly total?: number;
	readonly message?: string;
}
interface LoggingSetLevelParams {
	readonly level: LogLevel2;
}
interface RootsListResult {
	readonly roots: readonly Root[];
}
interface SamplingMessage {
	readonly role: "user" | "assistant";
	readonly content: TextContent | ImageContent | AudioContent;
}
interface ModelPreferences {
	readonly hints?: readonly ModelHint[];
	readonly costPriority?: number;
	readonly speedPriority?: number;
	readonly intelligencePriority?: number;
}
interface ModelHint {
	readonly name?: string;
}
interface SamplingCreateParams2 {
	readonly messages: readonly SamplingMessage[];
	readonly modelPreferences?: ModelPreferences;
	readonly systemPrompt?: string;
	readonly includeContext?: "none" | "thisServer" | "allServers";
	readonly temperature?: number;
	readonly maxTokens: number;
	readonly stopSequences?: readonly string[];
	readonly metadata?: Record<string, unknown>;
}
interface SamplingCreateResult2 {
	readonly role: "user" | "assistant";
	readonly content: TextContent | ImageContent | AudioContent;
	readonly model: string;
	readonly stopReason?: "endTurn" | "stopSequence" | "maxTokens" | string;
}
interface CompletionReference {
	readonly type: "ref/prompt" | "ref/resource";
	readonly name?: string;
	readonly uri?: string;
}
interface CompletionArgument {
	readonly name: string;
	readonly value: string;
}
interface CompletionCompleteParams {
	readonly ref: CompletionReference;
	readonly argument: CompletionArgument;
}
interface CompletionCompleteResult {
	readonly completion: {
		readonly values: readonly string[];
		readonly total?: number;
		readonly hasMore?: boolean;
	};
}
interface ResourcesSubscribeParams {
	readonly uri: string;
}
interface ResourcesUnsubscribeParams {
	readonly uri: string;
}
interface CancelledNotificationParams {
	readonly requestId: string | number;
	readonly reason?: string;
}
import { z } from "zod";
/** Extract the inferred type from a Zod schema */
type Infer<T extends z.ZodType> = z.infer<T>;
interface PromptContext {
	readonly signal?: AbortSignal;
}
interface PromptHandlerArgs<TArgs = void> {
	readonly args: TArgs;
	readonly ctx: PromptContext;
}
type PromptHandler<TArgs = void> = TArgs extends void ? (args: {
	ctx: PromptContext;
}) => PromptsGetResult | Promise<PromptsGetResult> : (args: PromptHandlerArgs<TArgs>) => PromptsGetResult | Promise<PromptsGetResult>;
interface PromptDefinition<_TArgs = void> {
	readonly description?: string;
	readonly arguments: readonly PromptArgument[];
	readonly handler: (args: {
		args: unknown;
		ctx: PromptContext;
	}) => Promise<PromptsGetResult>;
}
interface PromptBuilderWithoutArgs {
	description(desc: string): PromptBuilderWithoutArgs;
	args<T extends z2.ZodObject<z2.ZodRawShape>>(schema: T): PromptBuilderWithArgs<Infer<T>>;
	handler(fn: (args: {
		ctx: PromptContext;
	}) => PromptsGetResult | Promise<PromptsGetResult>): PromptDefinition<void>;
}
interface PromptBuilderWithArgs<TArgs> {
	description(desc: string): PromptBuilderWithArgs<TArgs>;
	handler(fn: (args: PromptHandlerArgs<TArgs>) => PromptsGetResult | Promise<PromptsGetResult>): PromptDefinition<TArgs>;
}
/**
* Create a new prompt using builder pattern.
*
* @example
* ```ts
* // With arguments
* const review = prompt()
*   .description('Code review')
*   .args(z.object({ language: z.string() }))
*   .handler(({ args }) => messages(user(`Review ${args.language}`)))
*
* // Without arguments
* const hello = prompt()
*   .description('Say hello')
*   .handler(() => messages(user('Hello!')))
* ```
*/
declare const prompt: () => PromptBuilderWithoutArgs;
declare const user: (text: string) => PromptMessage;
declare const assistant: (text: string) => PromptMessage;
declare const message: (role: "user" | "assistant", content: Content) => PromptMessage;
declare const messages: (...msgs: PromptMessage[]) => PromptsGetResult;
declare const promptResult: (description: string, ...msgs: PromptMessage[]) => PromptsGetResult;
declare const interpolate: (template: string, args: Record<string, string>) => string;
interface ResourceContext {
	readonly signal?: AbortSignal;
}
interface ResourceHandlerArgs {
	readonly uri: string;
	readonly ctx: ResourceContext;
}
interface TemplateHandlerArgs<TParams = Record<string, string>> {
	readonly uri: string;
	readonly params: TParams;
	readonly ctx: ResourceContext;
}
type ResourceHandler = (args: ResourceHandlerArgs) => ResourcesReadResult | Promise<ResourcesReadResult>;
type TemplateHandler<TParams = Record<string, string>> = (args: TemplateHandlerArgs<TParams>) => ResourcesReadResult | Promise<ResourcesReadResult>;
interface ResourceDefinition {
	readonly uri: string;
	readonly description?: string;
	readonly mimeType?: string;
	readonly handler: (uri: string, ctx: ResourceContext) => Promise<ResourcesReadResult>;
}
interface ResourceTemplateDefinition {
	readonly uriTemplate: string;
	readonly description?: string;
	readonly mimeType?: string;
	readonly handler: (uri: string, ctx: ResourceContext) => Promise<ResourcesReadResult>;
}
interface ResourceBuilderStart {
	uri(uri: string): ResourceBuilder;
}
interface ResourceBuilder {
	description(desc: string): ResourceBuilder;
	mimeType(mime: string): ResourceBuilder;
	handler(fn: ResourceHandler): ResourceDefinition;
}
interface TemplateBuilderStart {
	uriTemplate(template: string): TemplateBuilder;
}
interface TemplateBuilder {
	description(desc: string): TemplateBuilder;
	mimeType(mime: string): TemplateBuilder;
	handler<TParams = Record<string, string>>(fn: TemplateHandler<TParams>): ResourceTemplateDefinition;
}
/**
* Create a static resource.
*
* @example
* ```ts
* const config = resource()
*   .uri('config://app')
*   .description('App configuration')
*   .mimeType('application/json')
*   .handler(({ uri }) => resourceText(uri, '{"version": "1.0"}'))
* ```
*/
declare const resource: () => ResourceBuilderStart;
/**
* Create a resource template for dynamic URIs.
*
* @example
* ```ts
* const file = resourceTemplate()
*   .uriTemplate('file:///{path}')
*   .description('Read any file')
*   .handler(({ uri, params }) => resourceText(uri, `File: ${params.path}`))
* ```
*/
declare const resourceTemplate: () => TemplateBuilderStart;
declare const resourceText: (uri: string, text: string, mimeType?: string) => ResourcesReadResult;
declare const resourceBlob: (uri: string, blob: string, mimeType: string) => ResourcesReadResult;
declare const resourceContents: (...items: EmbeddedResource[]) => ResourcesReadResult;
import { z as z3 } from "zod";
interface ProgressNotification2 {
	readonly type: "progress";
	readonly progressToken: exports_mcp.ProgressToken;
	readonly progress: number;
	readonly total?: number;
	readonly message?: string;
}
interface LogNotification {
	readonly type: "log";
	readonly level: exports_mcp.LogLevel;
	readonly logger?: string;
	readonly data?: unknown;
}
interface ResourcesListChangedNotification {
	readonly type: "resources/list_changed";
}
interface ToolsListChangedNotification {
	readonly type: "tools/list_changed";
}
interface PromptsListChangedNotification {
	readonly type: "prompts/list_changed";
}
interface ResourceUpdatedNotification {
	readonly type: "resource/updated";
	readonly uri: string;
}
interface CancelledNotification2 {
	readonly type: "cancelled";
	readonly requestId: string | number;
	readonly reason?: string;
}
type Notification = ProgressNotification2 | LogNotification | ResourcesListChangedNotification | ToolsListChangedNotification | PromptsListChangedNotification | ResourceUpdatedNotification | CancelledNotification2;
/**
* Notification emitter interface.
* Transports implement this to send notifications to clients.
*/
interface NotificationEmitter {
	readonly emit: (notification: Notification) => void;
}
/**
* Raw notification sender - sends JSON-RPC notification messages.
* This is what transports provide.
*/
type NotificationSender = (method: string, params?: unknown) => void;
/**
* Context provided to tool handlers.
*/
interface ToolContext {
	readonly signal?: AbortSignal;
	/** Progress token from the request (if client requested progress updates) */
	readonly progressToken?: ProgressToken2;
	/** Send a log message to the client */
	readonly log: (level: LogLevel2, data: unknown, logger?: string) => void;
	/**
	* Send progress notification to the client.
	* Only sends if client provided a progressToken in the request.
	*/
	readonly progress: (current: number, options?: {
		total?: number;
		message?: string;
	}) => void;
	/** Raw notification emitter for advanced use */
	readonly notify?: NotificationEmitter;
}
/** Handler can return single content, array, or full result */
type ToolResult = Content | Content[] | ToolsCallResult;
interface ToolHandlerArgs<TInput = void> {
	readonly input: TInput;
	readonly ctx: ToolContext;
}
type ToolHandler<TInput = void> = TInput extends void ? (args: {
	ctx: ToolContext;
}) => ToolResult | Promise<ToolResult> : (args: ToolHandlerArgs<TInput>) => ToolResult | Promise<ToolResult>;
interface ToolDefinition<_TInput = void> {
	readonly name?: string;
	readonly description?: string;
	readonly inputSchema: JsonSchema;
	readonly annotations?: ToolAnnotations;
	readonly handler: (args: {
		input: unknown;
		ctx: ToolContext;
	}) => Promise<ToolsCallResult>;
}
interface ToolBuilderWithoutInput {
	description(desc: string): ToolBuilderWithoutInput;
	annotations(annotations: ToolAnnotations): ToolBuilderWithoutInput;
	input<T>(schema: z3.ZodType<T>): ToolBuilderWithInput<T>;
	handler(fn: (args: {
		ctx: ToolContext;
	}) => ToolResult | Promise<ToolResult>): ToolDefinition<void>;
}
interface ToolBuilderWithInput<TInput> {
	description(desc: string): ToolBuilderWithInput<TInput>;
	annotations(annotations: ToolAnnotations): ToolBuilderWithInput<TInput>;
	handler(fn: (args: ToolHandlerArgs<TInput>) => ToolResult | Promise<ToolResult>): ToolDefinition<TInput>;
}
/**
* Create a new tool using builder pattern.
*
* @example
* ```ts
* // With input
* const greet = tool()
*   .description('Greet someone')
*   .input(z.object({ name: z.string() }))
*   .handler(({ input }) => text(`Hello ${input.name}`))
*
* // Without input
* const ping = tool()
*   .description('Ping the server')
*   .handler(() => text('pong'))
*
* // Multiple content
* const multi = tool()
*   .handler(() => [text("Hello"), image(data, "image/png")])
* ```
*/
declare const tool: () => ToolBuilderWithoutInput;
/** Create text content */
declare const text: (content: string, annotations?: ContentAnnotations) => TextContent;
/** Create image content (base64 encoded) */
declare const image: (data: string, mimeType: string, annotations?: ContentAnnotations) => ImageContent;
/** Create audio content (base64 encoded) */
declare const audio: (data: string, mimeType: string, annotations?: ContentAnnotations) => AudioContent;
/** Create embedded resource content */
declare const embedded: (resource: EmbeddedResource, annotations?: ContentAnnotations) => ResourceContent;
/** Return error result */
declare const toolError: (message: string) => ToolsCallResult;
/** Return JSON as formatted text */
declare const json: <T>(data: T) => TextContent;
/**
* Pagination Utilities
*
* Cursor-based pagination for MCP list operations.
*/
interface PaginationOptions {
	/** Default page size if not specified */
	readonly defaultPageSize?: number;
	/** Maximum page size allowed */
	readonly maxPageSize?: number;
}
interface PageResult<T> {
	readonly items: readonly T[];
	readonly nextCursor?: string;
}
/**
* Paginate an array of items.
*
* @example
* ```ts
* const result = paginate(allItems, cursor, { defaultPageSize: 10 })
* // { items: [...], nextCursor: "..." }
* ```
*/
declare const paginate: <T>(items: readonly T[], cursor?: string, options?: PaginationOptions) => PageResult<T>;
/**
* Create a progress notification.
*/
declare const progress: (progressToken: exports_mcp.ProgressToken, current: number, options?: {
	total?: number;
	message?: string;
}) => Notification;
/**
* Create a log notification.
*/
declare const log: (level: exports_mcp.LogLevel, data: unknown, logger?: string) => Notification;
/**
* Emit a resources list changed notification.
*/
declare const resourcesListChanged: () => Notification;
/**
* Emit a tools list changed notification.
*/
declare const toolsListChanged: () => Notification;
/**
* Emit a prompts list changed notification.
*/
declare const promptsListChanged: () => Notification;
/**
* Emit a resource updated notification.
*/
declare const resourceUpdated: (uri: string) => Notification;
/**
* Emit a cancelled notification.
*/
declare const cancelled: (requestId: string | number, reason?: string) => Notification;
interface HandleOptions {
	/** Send a notification to the client during request processing */
	readonly notify?: (method: string, params?: unknown) => void;
}
interface ServerHandler {
	readonly name: string;
	readonly version: string;
	readonly handle: (message: string, options?: HandleOptions) => Promise<string | null>;
}
interface Transport {
	readonly start: () => Promise<void>;
	readonly stop: () => Promise<void>;
}
type TransportFactory = (server: ServerHandler, notify: NotificationEmitter) => Transport;
interface ServerConfig {
	/** Server name (default: "mcp-server") */
	readonly name?: string;
	/** Server version (default: "1.0.0") */
	readonly version?: string;
	/** Instructions for the LLM */
	readonly instructions?: string;
	/** Tool definitions (key = tool name) */
	readonly tools?: Record<string, ToolDefinition>;
	/** Resource definitions (key = resource name) */
	readonly resources?: Record<string, ResourceDefinition>;
	/** Resource template definitions (key = template name) */
	readonly resourceTemplates?: Record<string, ResourceTemplateDefinition>;
	/** Prompt definitions (key = prompt name) */
	readonly prompts?: Record<string, PromptDefinition>;
	/** Pagination options */
	readonly pagination?: PaginationOptions;
	/** Transport factory */
	readonly transport: TransportFactory;
}
interface Server {
	readonly name: string;
	readonly version: string;
	readonly start: () => Promise<void>;
	readonly stop: () => Promise<void>;
}
/**
* Create an MCP server.
*
* @example
* ```ts
* const server = createServer({
*   tools: { greet, ping },
*   transport: stdio()
* })
*
* await server.start()
* ```
*/
declare const createServer: (config: ServerConfig) => Server;
interface HttpOptions {
	/** Port to listen on (default: 3000) */
	readonly port?: number;
	/** Hostname to bind to (default: localhost) */
	readonly hostname?: string;
	/** Path prefix for MCP endpoints (default: /mcp) */
	readonly basePath?: string;
	/** CORS origin (set to "*" for all, or specific origin) */
	readonly cors?: string;
	/** Error handler */
	readonly onError?: (error: Error) => void;
}
/**
* Create a Streamable HTTP transport using @sylphx/gust.
* Works in both Node.js and Bun environments.
*
* Implements MCP Streamable HTTP (2025-03-26):
* - POST /mcp - JSON-RPC with optional SSE streaming
* - GET /mcp/health - Health check
*
* When client includes `Accept: text/event-stream`, server may respond
* with SSE to stream notifications during request processing.
*
* @example
* ```ts
* createServer({
*   tools: { ping },
*   transport: http({ port: 3000 })
* })
* ```
*/
declare const http: (options?: HttpOptions) => TransportFactory;
interface StdioOptions {
	/** Custom stdin (for testing) */
	readonly stdin?: ReadableStream<Uint8Array>;
	/** Custom stdout (for testing) */
	readonly stdout?: {
		write: (data: Uint8Array) => void;
		flush: () => void;
	};
	/** Error handler */
	readonly onError?: (error: Error) => void;
}
/**
* Create a stdio transport.
*
* @example
* ```ts
* createServer({
*   tools: { ping },
*   transport: stdio()
* })
* ```
*/
declare const stdio: (options?: StdioOptions) => TransportFactory;
/**
* JSON-RPC 2.0 Protocol Types
* Pure type definitions - no runtime dependencies
*/
declare const JSONRPC_VERSION: "2.0";
type RequestId = string | number;
interface JsonRpcRequest<
	M extends string = string,
	P = unknown
> {
	readonly jsonrpc: typeof JSONRPC_VERSION;
	readonly id: RequestId;
	readonly method: M;
	readonly params?: P;
}
interface JsonRpcNotification<
	M extends string = string,
	P = unknown
> {
	readonly jsonrpc: typeof JSONRPC_VERSION;
	readonly method: M;
	readonly params?: P;
}
interface JsonRpcSuccess<R = unknown> {
	readonly jsonrpc: typeof JSONRPC_VERSION;
	readonly id: RequestId;
	readonly result: R;
}
interface JsonRpcError<D = unknown> {
	readonly jsonrpc: typeof JSONRPC_VERSION;
	readonly id: RequestId | null;
	readonly error: {
		readonly code: number;
		readonly message: string;
		readonly data?: D;
	};
}
type JsonRpcResponse<
	R = unknown,
	D = unknown
> = JsonRpcSuccess<R> | JsonRpcError<D>;
type JsonRpcMessage = JsonRpcRequest | JsonRpcNotification | JsonRpcResponse;
declare const ErrorCode: {
	readonly ParseError: -32700;
	readonly InvalidRequest: -32600;
	readonly MethodNotFound: -32601;
	readonly InvalidParams: -32602;
	readonly InternalError: -32603;
};
type ErrorCode = (typeof ErrorCode)[keyof typeof ErrorCode];
declare const isRequest: (msg: JsonRpcMessage) => msg is JsonRpcRequest;
declare const isNotification: (msg: JsonRpcMessage) => msg is JsonRpcNotification;
declare const isResponse: (msg: JsonRpcMessage) => msg is JsonRpcResponse;
declare const isSuccess: <R>(msg: JsonRpcResponse<R>) => msg is JsonRpcSuccess<R>;
declare const isError2: <D>(msg: JsonRpcResponse<unknown, D>) => msg is JsonRpcError<D>;
declare const request: <
	M extends string,
	P
>(id: RequestId, method: M, params?: P) => JsonRpcRequest<M, P>;
declare const notification: <
	M extends string,
	P
>(method: M, params?: P) => JsonRpcNotification<M, P>;
declare const success: <R>(id: RequestId, result: R) => JsonRpcSuccess<R>;
declare const error: <D>(id: RequestId | null, code: number, message: string, data?: D) => JsonRpcError<D>;
type ParseResult<T> = {
	readonly ok: true;
	readonly value: T;
} | {
	readonly ok: false;
	readonly error: string;
};
declare const parseMessage: (input: string) => ParseResult<JsonRpcMessage>;
declare const stringify: (msg: JsonRpcMessage) => string;
/**
* Elicitation Types
*
* Server-initiated requests for user input through the client.
*/
/**
* Schema for elicitation - only flat primitive types allowed.
*/
interface ElicitationSchema {
	readonly type: "object";
	readonly properties: Record<string, ElicitationProperty>;
	readonly required?: readonly string[];
}
interface ElicitationProperty {
	readonly type: "string" | "number" | "integer" | "boolean";
	readonly description?: string;
	readonly default?: string | number | boolean;
	readonly enum?: readonly (string | number)[];
	readonly enumNames?: readonly string[];
	readonly format?: "email" | "uri" | "date" | "date-time";
	readonly minLength?: number;
	readonly maxLength?: number;
	readonly minimum?: number;
	readonly maximum?: number;
}
interface ElicitationCreateParams {
	/** Message to display to the user */
	readonly message: string;
	/** JSON Schema defining expected response structure */
	readonly requestedSchema: ElicitationSchema;
}
type ElicitationAction = "accept" | "decline" | "cancel";
interface ElicitationCreateResult {
	/** User's action */
	readonly action: ElicitationAction;
	/** User's response data (only when action is "accept") */
	readonly content?: Record<string, unknown>;
}
type ElicitationRequestSender = (method: string, params: ElicitationCreateParams) => Promise<ElicitationCreateResult>;
interface ElicitationClient {
	/** Request user input through the client */
	readonly elicit: (message: string, schema: ElicitationSchema) => Promise<ElicitationCreateResult>;
}
interface ElicitationContext {
	/** Request user input (if client supports elicitation) */
	readonly elicit?: ElicitationClient["elicit"];
}
/**
* Create an elicitation client for requesting user input.
*
* @example
* ```ts
* const result = await ctx.elicit?.(
*   "Please provide your API key",
*   {
*     type: "object",
*     properties: {
*       apiKey: { type: "string", description: "Your API key" },
*     },
*     required: ["apiKey"],
*   }
* )
*
* if (result?.action === "accept") {
*   const apiKey = result.content?.apiKey as string
* }
* ```
*/
declare const createElicitationClient: (sender: ElicitationRequestSender) => ElicitationClient;
/**
* Interface for making sampling requests to the client.
* The client must have sampling capability enabled.
*/
interface SamplingClient {
	/**
	* Request the client to sample from an LLM.
	*
	* @example
	* ```ts
	* const result = await sampling.createMessage({
	*   messages: [{ role: "user", content: { type: "text", text: "Hello" } }],
	*   maxTokens: 100,
	* })
	* console.log(result.content)
	* ```
	*/
	readonly createMessage: (params: exports_mcp.SamplingCreateParams) => Promise<exports_mcp.SamplingCreateResult>;
}
/**
* Raw request sender for sampling.
* Transports implement this to send JSON-RPC requests to the client.
*/
type SamplingRequestSender = (method: string, params: unknown) => Promise<unknown>;
/**
* Context extension for handlers that can make sampling requests.
*/
interface SamplingContext {
	readonly sampling?: SamplingClient;
}
/**
* Create a sampling client from a request sender.
*
* @example
* ```ts
* const sampling = createSamplingClient(async (method, params) => {
*   return await transport.request(method, params)
* })
*
* const result = await sampling.createMessage({
*   messages: [{ role: "user", content: { type: "text", text: "Hello" } }],
*   maxTokens: 100,
* })
* ```
*/
declare const createSamplingClient: (send: SamplingRequestSender) => SamplingClient;
export { user, toolsListChanged, toolError, tool, text, success, stringify, stdio, resourcesListChanged, resourceUpdated, resourceText, resourceTemplate, resourceContents, resourceBlob, resource, request, promptsListChanged, promptResult, prompt, progress, parseMessage, paginate, notification, messages, message, log, json, isSuccess, isResponse, isRequest, isNotification, isError2 as isError, interpolate, image, http, error, embedded, createServer, createSamplingClient, createElicitationClient, cancelled, audio, assistant, TransportFactory, Transport, ToolsListResult, ToolsCallResult, ToolsCallParams, ToolResult, ToolHandlerArgs, ToolHandler, ToolDefinition, ToolContext, ToolAnnotations, Tool, TextContent, TemplateHandlerArgs, TemplateHandler, StdioOptions, ServerConfig, ServerCapabilities, Server, SamplingRequestSender, SamplingMessage, SamplingCreateResult2 as SamplingCreateResult, SamplingCreateParams2 as SamplingCreateParams, SamplingContext, SamplingClient, SUPPORTED_PROTOCOL_VERSIONS, RootsListResult, Root, ResourcesUnsubscribeParams, ResourcesSubscribeParams, ResourcesReadResult, ResourcesReadParams, ResourcesListResult, ResourceTemplatesListResult, ResourceTemplateDefinition, ResourceTemplate, ResourceHandlerArgs, ResourceHandler, ResourceDefinition, ResourceContext, ResourceContent, Resource, RequestId, PromptsListResult, PromptsGetResult, PromptsGetParams, PromptMessage, PromptHandlerArgs, PromptHandler, PromptDefinition, PromptContext, PromptArgument, Prompt, ProgressToken2 as ProgressToken, ProgressParams, ProgressNotification2 as ProgressNotification, Progress, ParseResult, PaginationOptions, PageResult, NotificationSender, NotificationEmitter, Notification, ModelPreferences, ModelHint, Method, LoggingSetLevelParams, LogNotification, LogLevel2 as LogLevel, LogEntry, ListParams, LATEST_PROTOCOL_VERSION, JsonSchema, JsonRpcSuccess, JsonRpcResponse, JsonRpcRequest, JsonRpcNotification, JsonRpcMessage, JsonRpcError, JSONRPC_VERSION, InitializeResult, InitializeParams, Infer, Implementation, ImageContent, HttpOptions, ErrorCode, EmbeddedResource, ElicitationSchema, ElicitationRequestSender, ElicitationProperty, ElicitationCreateResult, ElicitationCreateParams, ElicitationContext, ElicitationClient, ElicitationAction, ContentAnnotations, Content, CompletionReference, CompletionCompleteResult, CompletionCompleteParams, CompletionArgument, ClientCapabilities, CancelledNotificationParams, AudioContent };
