// src/schema/zod.ts
import { z } from "zod";
var zodToJsonSchema = (schema) => {
  const jsonSchema = z.toJSONSchema(schema, {
    unrepresentable: "any",
    target: "draft-7"
  });
  const { $schema: _, ...rest } = jsonSchema;
  return rest;
};
var validate = (schema, input) => {
  const result = schema.safeParse(input);
  if (result.success) {
    return { success: true, data: result.data };
  }
  const issues = result.error.issues;
  const errorMsg = issues.map((e) => `${e.path.map(String).join(".")}: ${e.message}`).join("; ");
  return { success: false, error: errorMsg || "Validation failed" };
};
var extractObjectFields = (schema) => {
  if (!("shape" in schema) || typeof schema.shape !== "object") {
    return [];
  }
  const shape = schema.shape;
  const fields = [];
  for (const [key, value] of Object.entries(shape)) {
    const isOptional = value.isOptional?.() ?? false;
    const hasDefault = "~standard" in value && typeof value["~standard"] === "object" && value["~standard"] !== null && "default" in value["~standard"];
    fields.push({
      name: key,
      description: value.description,
      required: !isOptional && !hasDefault
    });
  }
  return fields;
};

// src/builders/prompt.ts
var createBuilder = (state = {}) => ({
  description(desc) {
    return createBuilder({ ...state, description: desc });
  },
  args(schema) {
    const newState = { ...state, argsSchema: schema };
    return {
      description(desc) {
        return createBuilder({
          ...newState,
          description: desc
        });
      },
      handler(fn) {
        return createDefinitionWithArgs(newState, schema, fn);
      }
    };
  },
  handler(fn) {
    return createDefinitionNoArgs(state, fn);
  }
});
var createDefinitionNoArgs = (state, fn) => ({
  description: state.description,
  arguments: [],
  handler: async ({ ctx }) => fn({ ctx })
});
var createDefinitionWithArgs = (state, schema, fn) => ({
  description: state.description,
  arguments: extractPromptArgs(schema),
  handler: async ({ args, ctx }) => {
    const result = validate(schema, args);
    if (!result.success) {
      return { messages: [user(`Validation error: ${result.error}`)] };
    }
    return fn({ args: result.data, ctx });
  }
});
var extractPromptArgs = (schema) => {
  const fields = extractObjectFields(schema);
  return fields.map((field) => ({
    name: field.name,
    description: field.description,
    required: field.required
  }));
};
var prompt = () => createBuilder();
var toProtocolPrompt = (name, def) => ({
  name,
  description: def.description,
  arguments: def.arguments
});
var user = (text) => ({
  role: "user",
  content: { type: "text", text }
});
var assistant = (text) => ({
  role: "assistant",
  content: { type: "text", text }
});
var message = (role, content) => ({
  role,
  content
});
var messages = (...msgs) => ({
  messages: msgs
});
var promptResult = (description, ...msgs) => ({
  description,
  messages: msgs
});
var interpolate = (template, args) => template.replace(/\{\{(\w+)\}\}/g, (_, key) => args[key] ?? `{{${key}}}`);
// src/builders/resource.ts
var createResourceBuilderStart = () => ({
  uri(uri) {
    return createResourceBuilder({ uri });
  }
});
var createResourceBuilder = (state) => ({
  description(desc) {
    return createResourceBuilder({ ...state, description: desc });
  },
  mimeType(mime) {
    return createResourceBuilder({ ...state, mimeType: mime });
  },
  handler(fn) {
    if (!state.uri)
      throw new Error("Resource URI is required");
    return {
      uri: state.uri,
      description: state.description,
      mimeType: state.mimeType,
      handler: async (uri, ctx) => fn({ uri, ctx })
    };
  }
});
var createTemplateBuilderStart = () => ({
  uriTemplate(template) {
    return createTemplateBuilder({ uriTemplate: template });
  }
});
var createTemplateBuilder = (state) => ({
  description(desc) {
    return createTemplateBuilder({ ...state, description: desc });
  },
  mimeType(mime) {
    return createTemplateBuilder({ ...state, mimeType: mime });
  },
  handler(fn) {
    if (!state.uriTemplate)
      throw new Error("URI template is required");
    const template = state.uriTemplate;
    return {
      uriTemplate: template,
      description: state.description,
      mimeType: state.mimeType,
      handler: async (uri, ctx) => {
        const params = extractParams(template, uri);
        return fn({ uri, params, ctx });
      }
    };
  }
});
var resource = () => createResourceBuilderStart();
var resourceTemplate = () => createTemplateBuilderStart();
var toProtocolResource = (name, def) => ({
  uri: def.uri,
  name,
  description: def.description,
  mimeType: def.mimeType
});
var toProtocolTemplate = (name, def) => ({
  uriTemplate: def.uriTemplate,
  name,
  description: def.description,
  mimeType: def.mimeType
});
var matchesTemplate = (template, uri) => {
  const pattern = template.replace(/\{[^}]+\}/g, "[^/]+");
  const regex = new RegExp(`^${pattern}$`);
  return regex.test(uri);
};
var extractParams = (template, uri) => {
  const paramNames = [];
  const pattern = template.replace(/\{([^}]+)\}/g, (_, name) => {
    paramNames.push(name);
    return "([^/]+)";
  });
  const regex = new RegExp(`^${pattern}$`);
  const match = uri.match(regex);
  if (!match)
    return null;
  const params = {};
  for (let i = 0;i < paramNames.length; i++) {
    const value = match[i + 1];
    const name = paramNames[i];
    if (value && name)
      params[name] = value;
  }
  return params;
};
var resourceText = (uri, text, mimeType) => ({
  contents: [{ type: "resource", uri, text, mimeType }]
});
var resourceBlob = (uri, blob, mimeType) => ({
  contents: [{ type: "resource", uri, blob, mimeType }]
});
var resourceContents = (...items) => ({
  contents: items
});
// src/builders/tool.ts
var normalizeResult = (result) => {
  if ("content" in result && Array.isArray(result.content)) {
    return result;
  }
  if (Array.isArray(result)) {
    return { content: result };
  }
  return { content: [result] };
};
var createBuilder2 = (state = {}) => ({
  description(desc) {
    return createBuilder2({ ...state, description: desc });
  },
  annotations(annotations) {
    return createBuilder2({ ...state, annotations });
  },
  input(schema) {
    const newState = { ...state, inputSchema: schema };
    return {
      description(desc) {
        return createBuilder2({
          ...newState,
          description: desc
        });
      },
      annotations(annotations) {
        return createBuilder2({ ...newState, annotations });
      },
      handler(fn) {
        return createDefinitionWithInput(newState, schema, fn);
      }
    };
  },
  handler(fn) {
    return createDefinitionNoInput(state, fn);
  }
});
var createDefinitionNoInput = (state, fn) => ({
  description: state.description,
  inputSchema: { type: "object", properties: {} },
  annotations: state.annotations,
  handler: async ({ ctx }) => normalizeResult(await fn({ ctx }))
});
var createDefinitionWithInput = (state, schema, fn) => ({
  description: state.description,
  inputSchema: zodToJsonSchema(schema),
  annotations: state.annotations,
  handler: async ({ input, ctx }) => {
    const result = validate(schema, input);
    if (!result.success) {
      return { content: [text(`Validation error: ${result.error}`)], isError: true };
    }
    return normalizeResult(await fn({ input: result.data, ctx }));
  }
});
var tool = () => createBuilder2();
var toProtocolTool = (name, def) => ({
  name,
  description: def.description,
  inputSchema: def.inputSchema,
  annotations: def.annotations
});
var text = (content, annotations) => ({
  type: "text",
  text: content,
  ...annotations && { annotations }
});
var image = (data, mimeType, annotations) => ({
  type: "image",
  data,
  mimeType,
  ...annotations && { annotations }
});
var audio = (data, mimeType, annotations) => ({
  type: "audio",
  data,
  mimeType,
  ...annotations && { annotations }
});
var embedded = (resource2, annotations) => ({
  type: "resource",
  resource: resource2,
  ...annotations && { annotations }
});
var toolError = (message2) => ({
  content: [text(message2)],
  isError: true
});
var json = (data) => text(JSON.stringify(data, null, 2));
// src/protocol/mcp.ts
var LATEST_PROTOCOL_VERSION = "2025-03-26";
var SUPPORTED_PROTOCOL_VERSIONS = [
  LATEST_PROTOCOL_VERSION,
  "2024-11-05"
];
var Method = {
  Initialize: "initialize",
  Initialized: "notifications/initialized",
  Ping: "ping",
  ResourcesList: "resources/list",
  ResourcesTemplatesList: "resources/templates/list",
  ResourcesRead: "resources/read",
  ResourcesSubscribe: "resources/subscribe",
  ResourcesUnsubscribe: "resources/unsubscribe",
  ResourcesUpdated: "notifications/resources/updated",
  ResourcesListChanged: "notifications/resources/list_changed",
  PromptsList: "prompts/list",
  PromptsGet: "prompts/get",
  PromptsListChanged: "notifications/prompts/list_changed",
  ToolsList: "tools/list",
  ToolsCall: "tools/call",
  ToolsListChanged: "notifications/tools/list_changed",
  LoggingSetLevel: "logging/setLevel",
  LogMessage: "notifications/message",
  CompletionComplete: "completion/complete",
  SamplingCreateMessage: "sampling/createMessage",
  ElicitationCreate: "elicitation/create",
  ProgressNotification: "notifications/progress",
  CancelledNotification: "notifications/cancelled",
  RootsList: "roots/list",
  RootsListChanged: "notifications/roots/list_changed"
};

// src/notifications/emitter.ts
var noopEmitter = {
  emit: () => {}
};
// src/notifications/helpers.ts
var progress = (progressToken, current, options) => ({
  type: "progress",
  progressToken,
  progress: current,
  total: options?.total,
  message: options?.message
});
var log = (level, data, logger) => ({
  type: "log",
  level,
  logger,
  data
});
var resourcesListChanged = () => ({
  type: "resources/list_changed"
});
var toolsListChanged = () => ({
  type: "tools/list_changed"
});
var promptsListChanged = () => ({
  type: "prompts/list_changed"
});
var resourceUpdated = (uri) => ({
  type: "resource/updated",
  uri
});
var cancelled = (requestId, reason) => ({
  type: "cancelled",
  requestId,
  reason
});
// src/protocol/jsonrpc.ts
var JSONRPC_VERSION = "2.0";
var ErrorCode = {
  ParseError: -32700,
  InvalidRequest: -32600,
  MethodNotFound: -32601,
  InvalidParams: -32602,
  InternalError: -32603
};
var isRequest = (msg) => ("id" in msg) && ("method" in msg);
var isNotification = (msg) => !("id" in msg) && ("method" in msg);
var isResponse = (msg) => ("id" in msg) && (("result" in msg) || ("error" in msg));
var isSuccess = (msg) => ("result" in msg);
var isError = (msg) => ("error" in msg);
var request = (id, method, params) => ({
  jsonrpc: JSONRPC_VERSION,
  id,
  method,
  ...params !== undefined && { params }
});
var notification = (method, params) => ({
  jsonrpc: JSONRPC_VERSION,
  method,
  ...params !== undefined && { params }
});
var success = (id, result) => ({
  jsonrpc: JSONRPC_VERSION,
  id,
  result
});
var error = (id, code, message2, data) => ({
  jsonrpc: JSONRPC_VERSION,
  id,
  error: {
    code,
    message: message2,
    ...data !== undefined && { data }
  }
});
var parseMessage = (input) => {
  try {
    const data = JSON.parse(input);
    if (typeof data !== "object" || data === null) {
      return { ok: false, error: "Message must be an object" };
    }
    if (data.jsonrpc !== JSONRPC_VERSION) {
      return { ok: false, error: `Invalid jsonrpc version: ${data.jsonrpc}` };
    }
    return { ok: true, value: data };
  } catch (e) {
    return { ok: false, error: `JSON parse error: ${e}` };
  }
};
var stringify = (msg) => JSON.stringify(msg);

// src/pagination/index.ts
var encodeCursor = (data) => {
  return Buffer.from(JSON.stringify(data)).toString("base64url");
};
var decodeCursor = (cursor) => {
  try {
    const json2 = Buffer.from(cursor, "base64url").toString("utf-8");
    const data = JSON.parse(json2);
    if (typeof data.offset !== "number" || typeof data.pageSize !== "number") {
      return null;
    }
    return data;
  } catch {
    return null;
  }
};
var paginate = (items, cursor, options) => {
  const defaultPageSize = options?.defaultPageSize ?? 50;
  const maxPageSize = options?.maxPageSize ?? 100;
  let offset = 0;
  let pageSize = defaultPageSize;
  if (cursor) {
    const data = decodeCursor(cursor);
    if (data) {
      offset = data.offset;
      pageSize = Math.min(data.pageSize, maxPageSize);
    }
  }
  const page = items.slice(offset, offset + pageSize);
  const hasMore = offset + pageSize < items.length;
  return {
    items: page,
    nextCursor: hasMore ? encodeCursor({ offset: offset + pageSize, pageSize }) : undefined
  };
};

// src/server/handler.ts
var handleInitialize = (state) => ({
  protocolVersion: LATEST_PROTOCOL_VERSION,
  capabilities: state.capabilities,
  serverInfo: {
    name: state.name,
    version: state.version
  },
  instructions: state.instructions
});
var handlePing = () => ({});
var handleToolsList = (state, params) => {
  const allItems = Array.from(state.tools.entries()).map(([name, def]) => toProtocolTool(name, def));
  const { items, nextCursor } = paginate(allItems, params?.cursor, state.pagination);
  return { tools: items, nextCursor };
};
var handleToolsCall = async (state, params, ctx) => {
  const tool2 = state.tools.get(params.name);
  if (!tool2) {
    return {
      content: [{ type: "text", text: `Unknown tool: ${params.name}` }],
      isError: true
    };
  }
  const requestProgressToken = params._meta?.progressToken;
  const toolCtx = {
    signal: ctx.signal,
    progressToken: requestProgressToken,
    log: (level, data, logger) => {
      ctx.notify?.(Method.LogMessage, { level, logger, data });
    },
    progress: (current, options) => {
      if (requestProgressToken) {
        ctx.notify?.(Method.ProgressNotification, {
          progressToken: requestProgressToken,
          progress: current,
          total: options?.total,
          message: options?.message
        });
      }
    }
  };
  try {
    return await tool2.handler({ input: params.arguments ?? {}, ctx: toolCtx });
  } catch (error2) {
    return {
      content: [{ type: "text", text: `Tool error: ${error2}` }],
      isError: true
    };
  }
};
var handleResourcesList = (state, params) => {
  const allItems = Array.from(state.resources.entries()).map(([name, def]) => toProtocolResource(name, def));
  const { items, nextCursor } = paginate(allItems, params?.cursor, state.pagination);
  return { resources: items, nextCursor };
};
var handleResourceTemplatesList = (state, params) => {
  const allItems = Array.from(state.resourceTemplates.entries()).map(([name, def]) => toProtocolTemplate(name, def));
  const { items, nextCursor } = paginate(allItems, params?.cursor, state.pagination);
  return { resourceTemplates: items, nextCursor };
};
var handleResourcesRead = async (state, params, ctx) => {
  for (const [, def] of state.resources) {
    if (def.uri === params.uri) {
      return await def.handler(params.uri, ctx);
    }
  }
  for (const [, template] of state.resourceTemplates) {
    if (matchesTemplate(template.uriTemplate, params.uri)) {
      return await template.handler(params.uri, ctx);
    }
  }
  throw new Error(`Resource not found: ${params.uri}`);
};
var handlePromptsList = (state, params) => {
  const allItems = Array.from(state.prompts.entries()).map(([name, def]) => toProtocolPrompt(name, def));
  const { items, nextCursor } = paginate(allItems, params?.cursor, state.pagination);
  return { prompts: items, nextCursor };
};
var handlePromptsGet = async (state, params, ctx) => {
  const prompt2 = state.prompts.get(params.name);
  if (!prompt2) {
    throw new Error(`Unknown prompt: ${params.name}`);
  }
  return await prompt2.handler({ args: params.arguments ?? {}, ctx });
};
var handleLoggingSetLevel = (state, params) => {
  state.logLevel = params.level;
  return {};
};
var handleCompletionComplete = (state, params) => {
  const values = [];
  if (params.ref.type === "ref/prompt") {
    const prompt2 = params.ref.name ? state.prompts.get(params.ref.name) : undefined;
    if (prompt2?.arguments) {}
  } else if (params.ref.type === "ref/resource") {
    for (const [, resource2] of state.resources) {
      if (resource2.uri.includes(params.argument.value)) {
        values.push(resource2.uri);
      }
    }
  }
  return {
    completion: {
      values,
      hasMore: false
    }
  };
};
var handleResourcesSubscribe = (state, params) => {
  if (state.subscriptions) {
    state.subscriptions.add(params.uri);
  }
  return {};
};
var handleResourcesUnsubscribe = (state, params) => {
  if (state.subscriptions) {
    state.subscriptions.delete(params.uri);
  }
  return {};
};
var handleNotification = (notification2) => {
  switch (notification2.method) {
    case Method.Initialized:
      break;
    default:
      break;
  }
};
var dispatch = async (state, message2, ctx) => {
  if (isNotification(message2)) {
    handleNotification(message2);
    return { type: "none" };
  }
  if (isRequest(message2)) {
    try {
      const result = await handleRequest(state, message2, ctx);
      return {
        type: "response",
        response: success(message2.id, result)
      };
    } catch (error2) {
      return {
        type: "response",
        response: error(message2.id, ErrorCode.InternalError, error2 instanceof Error ? error2.message : String(error2))
      };
    }
  }
  return { type: "none" };
};
var handleRequest = async (state, req, ctx) => {
  switch (req.method) {
    case Method.Initialize:
      return handleInitialize(state);
    case Method.Ping:
      return handlePing();
    case Method.ToolsList:
      return handleToolsList(state, req.params);
    case Method.ToolsCall:
      return handleToolsCall(state, req.params, ctx);
    case Method.ResourcesList:
      return handleResourcesList(state, req.params);
    case Method.ResourcesTemplatesList:
      return handleResourceTemplatesList(state, req.params);
    case Method.ResourcesRead:
      return handleResourcesRead(state, req.params, ctx);
    case Method.PromptsList:
      return handlePromptsList(state, req.params);
    case Method.PromptsGet:
      return handlePromptsGet(state, req.params, ctx);
    case Method.LoggingSetLevel:
      return handleLoggingSetLevel(state, req.params);
    case Method.CompletionComplete:
      return handleCompletionComplete(state, req.params);
    case Method.ResourcesSubscribe:
      return handleResourcesSubscribe(state, req.params);
    case Method.ResourcesUnsubscribe:
      return handleResourcesUnsubscribe(state, req.params);
    default:
      throw new Error(`Unknown method: ${req.method}`);
  }
};

// src/server/server.ts
var createServer = (config) => {
  const name = config.name ?? "mcp-server";
  const version = config.version ?? "1.0.0";
  const state = buildState(config, name, version);
  const handle = async (input, options) => {
    const parsed = parseMessage(input);
    if (!parsed.ok) {
      const errorResponse = error(null, ErrorCode.ParseError, parsed.error);
      return stringify(errorResponse);
    }
    const ctx = {
      signal: undefined,
      notify: options?.notify
    };
    const result = await dispatch(state, parsed.value, ctx);
    return result.type === "response" ? stringify(result.response) : null;
  };
  const transport = config.transport({ name, version, handle }, noopEmitter);
  return {
    name,
    version,
    start: transport.start,
    stop: transport.stop
  };
};
var buildState = (config, name, version) => {
  const tools = new Map(Object.entries(config.tools ?? {}));
  const resources = new Map(Object.entries(config.resources ?? {}));
  const resourceTemplates = new Map(Object.entries(config.resourceTemplates ?? {}));
  const prompts = new Map(Object.entries(config.prompts ?? {}));
  const capabilities = {
    ...tools.size > 0 && { tools: { listChanged: true } },
    ...(resources.size > 0 || resourceTemplates.size > 0) && {
      resources: { subscribe: true, listChanged: true }
    },
    ...prompts.size > 0 && { prompts: { listChanged: true } },
    logging: {},
    completions: {}
  };
  return {
    name,
    version,
    instructions: config.instructions,
    tools,
    resources,
    resourceTemplates,
    prompts,
    capabilities,
    pagination: config.pagination,
    subscriptions: new Set
  };
};
// src/transports/http.ts
import {
  compose,
  get,
  cors as gustCors,
  json as json2,
  post,
  response,
  router,
  serve
} from "@sylphx/gust";
var sseEvent = (data, event, id) => {
  let result = "";
  if (id)
    result += `id: ${id}
`;
  if (event)
    result += `event: ${event}
`;
  result += `data: ${data}

`;
  return result;
};
var http = (options = {}) => {
  return (server, _notify) => {
    const port = options.port ?? 3000;
    const hostname = options.hostname ?? "localhost";
    const basePath = options.basePath ?? "/mcp";
    const sessions = new Map;
    const jsonRpcRoute = post(basePath, async (ctx) => {
      try {
        const body = ctx.body.toString();
        const accept = ctx.headers.accept ?? "";
        const acceptsSSE = accept.includes("text/event-stream");
        const sessionId = ctx.headers["mcp-session-id"];
        if (sessionId && !sessions.has(sessionId)) {
          return json2({ error: "Session not found" }, { status: 404 });
        }
        if (acceptsSSE) {
          const notifications = [];
          const notify = (method, params) => {
            const notification2 = notification(method, params);
            notifications.push(stringify(notification2));
          };
          const responseStr2 = await server.handle(body, { notify });
          let sseBody = "";
          for (const notification2 of notifications) {
            sseBody += sseEvent(notification2, "message");
          }
          if (responseStr2) {
            sseBody += sseEvent(responseStr2, "message");
          }
          const parsed2 = parseMessage(body);
          const headers2 = {
            "Content-Type": "text/event-stream",
            "Cache-Control": "no-cache"
          };
          if (parsed2.ok && isRequest(parsed2.value) && parsed2.value.method === "initialize") {
            const newSessionId = crypto.randomUUID();
            sessions.set(newSessionId, { createdAt: Date.now() });
            headers2["Mcp-Session-Id"] = newSessionId;
          }
          return response(sseBody, { status: 200, headers: headers2 });
        }
        const responseStr = await server.handle(body);
        if (!responseStr) {
          return response("", { status: 204 });
        }
        const parsed = parseMessage(body);
        const headers = {};
        if (parsed.ok && isRequest(parsed.value) && parsed.value.method === "initialize") {
          const newSessionId = crypto.randomUUID();
          sessions.set(newSessionId, { createdAt: Date.now() });
          headers["Mcp-Session-Id"] = newSessionId;
        }
        return json2(JSON.parse(responseStr), { headers });
      } catch (error2) {
        console.error("HTTP Transport Error:", error2);
        options.onError?.(error2 instanceof Error ? error2 : new Error(String(error2)));
        const errorResponse = error(null, ErrorCode.InternalError, "Internal server error");
        return json2(JSON.parse(stringify(errorResponse)), { status: 500 });
      }
    });
    const healthRoute = get(`${basePath}/health`, () => {
      return json2({
        status: "ok",
        server: server.name,
        version: server.version
      });
    });
    const routes = router({
      jsonRpc: jsonRpcRoute,
      health: healthRoute
    });
    const app = options.cors ? compose(gustCors({ origin: options.cors }))(routes.handler) : routes.handler;
    let gustServer = null;
    const start = async () => {
      gustServer = await serve({
        fetch: app,
        port,
        hostname
      });
    };
    const stop = async () => {
      sessions.clear();
      if (gustServer) {
        await gustServer.stop();
        gustServer = null;
      }
    };
    return { start, stop };
  };
};
// src/transports/stdio.ts
import { Readable } from "node:stream";
var stdio = (options = {}) => {
  return (server, _notify) => {
    let running = false;
    let writer = null;
    const encoder = new TextEncoder;
    const start = async () => {
      if (running)
        return;
      running = true;
      const stdin = options.stdin ?? Readable.toWeb(process.stdin);
      const stdout = options.stdout ?? {
        write: (data) => process.stdout.write(data),
        flush: () => {}
      };
      writer = stdout;
      const decoder = new TextDecoder;
      let buffer = "";
      const reader = stdin.getReader();
      try {
        while (running) {
          const { done, value } = await reader.read();
          if (done)
            break;
          buffer += decoder.decode(value, { stream: true });
          for (let newlineIndex = buffer.indexOf(`
`);newlineIndex !== -1; newlineIndex = buffer.indexOf(`
`)) {
            const line = buffer.slice(0, newlineIndex).trim();
            buffer = buffer.slice(newlineIndex + 1);
            if (line.length === 0)
              continue;
            try {
              const response2 = await server.handle(line);
              if (response2) {
                writer.write(encoder.encode(`${response2}
`));
                writer.flush();
              }
            } catch (error2) {
              options.onError?.(error2 instanceof Error ? error2 : new Error(String(error2)));
            }
          }
        }
      } finally {
        reader.releaseLock();
        running = false;
        writer = null;
      }
    };
    const stop = async () => {
      running = false;
    };
    return { start, stop };
  };
};
// src/elicitation/client.ts
var createElicitationClient = (sender) => {
  const elicit = async (message2, schema) => {
    const params = {
      message: message2,
      requestedSchema: schema
    };
    return sender("elicitation/create", params);
  };
  return { elicit };
};
// src/sampling/client.ts
var createSamplingClient = (send) => ({
  createMessage: async (params) => {
    const result = await send(Method.SamplingCreateMessage, params);
    return result;
  }
});
export {
  user,
  toolsListChanged,
  toolError,
  tool,
  text,
  success,
  stringify,
  stdio,
  resourcesListChanged,
  resourceUpdated,
  resourceText,
  resourceTemplate,
  resourceContents,
  resourceBlob,
  resource,
  request,
  promptsListChanged,
  promptResult,
  prompt,
  progress,
  parseMessage,
  paginate,
  notification,
  messages,
  message,
  log,
  json,
  isSuccess,
  isResponse,
  isRequest,
  isNotification,
  isError,
  interpolate,
  image,
  http,
  error,
  embedded,
  createServer,
  createSamplingClient,
  createElicitationClient,
  cancelled,
  audio,
  assistant,
  SUPPORTED_PROTOCOL_VERSIONS,
  Method,
  LATEST_PROTOCOL_VERSION,
  JSONRPC_VERSION,
  ErrorCode
};
